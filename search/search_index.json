{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"HiMatCal","text":"<p>Welcome to the documentation for the <code>himatcal</code> code!</p> <p>[!WARNING] \ud83d\udea7 This repository is still in the process of long-term construction. It is not intended to be directly utilized by end-users at present. \ud83d\udea7</p>"},{"location":"install/codes.html","title":"Extra Codes","text":""},{"location":"install/codes.html#xtb-and-xtb_ase","title":"xtb and xtb_ase","text":"<pre><code>micromamba install -c conda-forge xtb\nuv pip install git+https://github.com/Quantum-Accelerators/xtb_ase.git\n</code></pre>"},{"location":"install/codes.html#pysisyphus","title":"pysisyphus","text":"<pre><code>uv pip install git+https://github.com/CCSun21/pysisyphus.git@dev\n</code></pre>"},{"location":"install/install.html","title":"Installation","text":""},{"location":"install/install.html#using-micromamba","title":"using micromamba","text":"<p>Note</p> <p>Installing with micromamba and uv is the recommended way to install himatcal.</p> <pre><code>micromamba env create -n himatcal python==3.10\nmicromamba activate himatcal\n\npip install uv\nuv pip install himatcal\nuv pip install git+https://gitlab.com/ase/ase.git\n</code></pre>"},{"location":"install/install.html#optional-dependencies","title":"optional dependencies","text":"<pre><code>uv install git+https://github.com/Quantum-Accelerators/xtb_ase.git\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>himatcal<ul> <li>atoms<ul> <li>core</li> <li>parser</li> </ul> </li> <li>calculator<ul> <li>aimnet<ul> <li>aimnet2ase</li> <li>aimnet2pysis</li> <li>core</li> <li>ensemble</li> <li>models</li> <li>nblist</li> </ul> </li> <li>aio_ani</li> <li>gaussian_mcd</li> <li>mlp</li> <li>orca_mcd</li> <li>pyscf_calculator</li> </ul> </li> <li>recipes<ul> <li>crest<ul> <li>_base</li> <li>core</li> </ul> </li> <li>electrolyte<ul> <li>core</li> <li>redox</li> <li>sol_stru<ul> <li>_base</li> <li>build_box</li> <li>core</li> <li>genFF</li> <li>md</li> </ul> </li> </ul> </li> <li>gaussian<ul> <li>_base</li> <li>core</li> <li>flow</li> </ul> </li> <li>gsm<ul> <li>DE_GSM</li> <li>SE_GSM</li> <li>core</li> </ul> </li> <li>materials<ul> <li>core</li> <li>diffubarrier</li> </ul> </li> <li>mcd<ul> <li>core</li> </ul> </li> <li>mol<ul> <li>core</li> <li>pubgrep</li> </ul> </li> <li>newtonnet<ul> <li>ts</li> </ul> </li> <li>orca<ul> <li>core</li> </ul> </li> <li>quacc<ul> <li>_base</li> <li>core</li> </ul> </li> <li>reaction<ul> <li>_base</li> <li>core</li> <li>newtonnet</li> <li>utils</li> </ul> </li> </ul> </li> <li>settings</li> <li>tools<ul> <li>db</li> <li>mpdownload</li> </ul> </li> <li>utils<ul> <li>ase</li> <li>ct</li> <li>locache</li> <li>mcd<ul> <li>chem</li> <li>ic</li> <li>mcd</li> <li>process</li> <li>run</li> </ul> </li> <li>mol<ul> <li>cirpy</li> </ul> </li> <li>neb<ul> <li>coord_utils</li> <li>core</li> <li>geodesic</li> <li>interpolation</li> <li>quacc_schemas</li> </ul> </li> <li>os</li> <li>pretty</li> <li>rdkit<ul> <li>core</li> </ul> </li> <li>rmsd</li> <li>visualize</li> <li>visualizer<ul> <li>molbokeh</li> <li>molplotly</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/himatcal/settings.html","title":"settings","text":"<p>Settings for himatcal</p>"},{"location":"reference/himatcal/settings.html#himatcal.settings._DEFAULT_CONFIG_FILE_PATH","title":"_DEFAULT_CONFIG_FILE_PATH  <code>module-attribute</code>","text":"<pre><code>_DEFAULT_CONFIG_FILE_PATH = resolve()\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings","title":"HimatcalSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Settings for himatcal</p>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.AIMNET2_MODEL_PATH","title":"AIMNET2_MODEL_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AIMNET2_MODEL_PATH: Path = Field(Path(), description='Path to the aimnet2 model')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.CHEMSPIDER_API_KEY","title":"CHEMSPIDER_API_KEY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHEMSPIDER_API_KEY: str = Field('', description='API key for ChemSpider')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.CONFIG_FILE","title":"CONFIG_FILE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONFIG_FILE: Path = Field(_DEFAULT_CONFIG_FILE_PATH, description='Path to the YAML config file')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.CREST_EXE_PATH","title":"CREST_EXE_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CREST_EXE_PATH: Path = Field(Path(), description='Path to the crest executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.CREST_EXE_PATH_V3","title":"CREST_EXE_PATH_V3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CREST_EXE_PATH_V3: Path = Field(Path(), description='Path to the crest executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.DEBUG","title":"DEBUG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEBUG: bool = Field(False, description='Whether to enable debug logging')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.FORMCHK_PATH","title":"FORMCHK_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORMCHK_PATH: Path = Field(Path(), description='Path to the formchk executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.GROMACS_PATH","title":"GROMACS_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GROMACS_PATH: Path = Field(Path(), description='Path to the gromacs executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.ISOSTAT_EXE_PATH","title":"ISOSTAT_EXE_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ISOSTAT_EXE_PATH: Path = Field(Path(), description='Path to the isostat executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.MABASIS_PATH","title":"MABASIS_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MABASIS_PATH: Path = Field(Path(), description='Path to the mabasis')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.MAPI_KEY","title":"MAPI_KEY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAPI_KEY: str = Field('', description='API key for the Materials Project')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.MONGODB_URI","title":"MONGODB_URI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MONGODB_URI: str = Field('', description='MongoDB URI for the database connection')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.MULTIWFN_PATH","title":"MULTIWFN_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MULTIWFN_PATH: Path = Field(Path(), description='Path to the Multiwfn executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.OBABEL_PATH","title":"OBABEL_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OBABEL_PATH: Path = Field(Path(), description='Path to the obabel executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.ORCA_PATH","title":"ORCA_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORCA_PATH: Path = Field(Path(), description='Path to the ORCA executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.SGHPC1_KEY_PATH","title":"SGHPC1_KEY_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SGHPC1_KEY_PATH: Path = Field(Path(), description='Path to the ssh key file of sghpc1')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.SOBTOP_PATH","title":"SOBTOP_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SOBTOP_PATH: Path = Field(Path(), description='Path to the sobtop executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.XMU_KEY_PATH","title":"XMU_KEY_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XMU_KEY_PATH: Path = Field(Path(), description='Path to the ssh key file of XMU')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.XTB_EXE_PATH","title":"XTB_EXE_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XTB_EXE_PATH: Path = Field(Path(), description='Path to the xtb executable')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.YEESUAN_KEY_PATH","title":"YEESUAN_KEY_PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>YEESUAN_KEY_PATH: Path = Field(Path(), description='Path to the ssh key file of yeesuan')\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(env_prefix='himatcal_', env_nested_delimiter='__', env_parse_none_str='None', extra='forbid', validate_assignment=True)\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings.HimatcalSettings.load_user_setting","title":"load_user_setting  <code>classmethod</code>","text":"<pre><code>load_user_setting(settings: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Load user settings</p> Source code in <code>himatcal/settings.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef load_user_setting(cls, settings: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Load user settings\"\"\"\n    return _type_handler(_use_custom_config_settings(settings))\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings._type_handler","title":"_type_handler","text":"<pre><code>_type_handler(settings: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Convert common strings to their proper types.</p> <p>Parameters:</p> <ul> <li> <code>settings</code>               (<code>dict</code>)           \u2013            <p>Initial settings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Updated settings.</p> </li> </ul> Source code in <code>himatcal/settings.py</code> <pre><code>def _type_handler(settings: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert common strings to their proper types.\n\n    Parameters\n    ----------\n    settings : dict\n        Initial settings.\n\n    Returns\n    -------\n    dict\n        Updated settings.\n    \"\"\"\n    for key, value in settings.items():\n        if isinstance(value, str):\n            if value.lower() in {\"null\", \"none\"}:\n                settings[key] = None\n            elif value.lower() in {\"true\", \"false\"}:\n                settings[key] = value.lower() == \"true\"\n\n    return settings\n</code></pre>"},{"location":"reference/himatcal/settings.html#himatcal.settings._use_custom_config_settings","title":"_use_custom_config_settings","text":"<pre><code>_use_custom_config_settings(settings: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Use custom settings from the config file</p> Source code in <code>himatcal/settings.py</code> <pre><code>def _use_custom_config_settings(settings: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Use custom settings from the config file\"\"\"\n    from monty.serialization import loadfn\n\n    config_file_path = (\n        Path(settings.get(\"CONFIG_FILE\", _DEFAULT_CONFIG_FILE_PATH))\n        .expanduser()\n        .resolve()\n    )\n\n    new_settings = {}  # type: dict\n    if config_file_path.exists() and config_file_path.stat().st_size &gt; 0:\n        new_settings |= loadfn(config_file_path)\n\n    new_settings.update(settings)\n    return new_settings\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html","title":"core","text":""},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.Li","title":"Li  <code>module-attribute</code>","text":"<pre><code>Li = Atoms(symbols='Li', positions=[[0, 0, 0]])\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.Na","title":"Na  <code>module-attribute</code>","text":"<pre><code>Na = Atoms(symbols='Na', positions=[[0, 0, 0]])\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.PF6","title":"PF6  <code>module-attribute</code>","text":"<pre><code>PF6 = Atoms(symbols='PF6', positions=[[6.747, 7.453, 7.469], [7.944, 6.319, 7.953], [6.127, 6.381, 6.461], [5.794, 8.645, 7.001], [5.815, 7.032, 8.699], [7.617, 8.534, 8.484], [7.91, 7.908, 6.284]])\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.elements","title":"elements  <code>module-attribute</code>","text":"<pre><code>elements = ['', 'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Uub', 'Uut', 'Uuq', 'Uup', 'Uuh', 'Uus', 'Uuo']\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.add_cell","title":"add_cell","text":"<pre><code>add_cell(atoms, cell_parameters)\n</code></pre> <p>Add cell parameters to the atoms object.</p> <p>Args:</p> <pre><code>atoms (ase.Atoms): The atoms object.\ncell_parameters (list): The cell parameters.\n</code></pre> <p>Returns:</p> <pre><code>atoms (ase.Atoms): The atoms object with cell parameters.\n</code></pre> Source code in <code>himatcal/atoms/core.py</code> <pre><code>def add_cell(atoms, cell_parameters):\n    \"\"\"\n    Add cell parameters to the atoms object.\n\n    Args:\n\n        atoms (ase.Atoms): The atoms object.\n        cell_parameters (list): The cell parameters.\n\n    Returns:\n\n        atoms (ase.Atoms): The atoms object with cell parameters.\n    \"\"\"\n\n    atoms.set_cell(cell_parameters)\n    return atoms\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.dock_atoms","title":"dock_atoms","text":"<pre><code>dock_atoms(ship: Atoms, dock: Atoms | str = 'PF6', chg: int = 0, mult: int = 1, offset: float = 1.5, crest_sampling: bool = True, topo_change: bool = False)\n</code></pre> <p>Dock the ship\ud83d\udea2 atoms to the dock\u2693 atoms (default is PF6).</p> Parameters: <p>ship_atoms (ase.Atoms): The ship atoms.</p> Source code in <code>himatcal/atoms/core.py</code> <pre><code>def dock_atoms(\n    ship: Atoms,\n    dock: Atoms | str = \"PF6\",\n    chg: int = 0,\n    mult: int = 1,\n    offset: float = 1.5,\n    crest_sampling: bool = True,\n    topo_change: bool = False,\n):\n    \"\"\"\n    Dock the ship\ud83d\udea2 atoms to the dock\u2693 atoms (default is PF6).\n\n    Parameters:\n    -----------\n    ship_atoms (ase.Atoms): The ship atoms.\n    \"\"\"\n    dock_atoms_dict = {\"PF6\": PF6.copy(), \"Li\": Li.copy(), \"Na\": Na.copy()}\n\n    if isinstance(dock, str):\n        dock = dock_atoms_dict.get(dock, dock)\n\n    docked_atoms = ship.copy()\n    ship_atoms_center = docked_atoms.get_center_of_mass()\n    ship_atoms_center[0] = max(docked_atoms.positions.T[0])\n    dock_atoms_center = dock.get_center_of_mass()\n    dock_atoms_center[0] = min(dock.positions.T[0])\n    vector = ship_atoms_center - dock_atoms_center + [offset, 0, 0]\n    dock.positions += vector\n    docked_atoms.extend(dock)\n    if not crest_sampling:\n        return docked_atoms\n\n    processed_atoms = None\n    for _ in range(3):\n        logging.info(f\"Trying sampling the docked atoms using iMTD-GC the {_} time\")\n        with contextlib.suppress(Exception):\n            processed_atoms = iMTD_GC(\n                docked_atoms, chg=chg, mult=mult, topo_change=topo_change\n            )\n            break\n    if processed_atoms is None:\n        logging.info(\"Sampling failed, trying the docked atoms with topology change\")\n        for _ in range(3):\n            with contextlib.suppress(Exception):\n                processed_atoms = iMTD_GC(\n                    docked_atoms, chg=chg, mult=mult, topo_change=True\n                )\n                break\n        logging.info(\"Crest iMTD-GC Sampling failed!\")\n    return processed_atoms\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.tmp_atoms","title":"tmp_atoms","text":"<pre><code>tmp_atoms(atoms, filename='tmp.xyz', create_tmp_folder=True)\n</code></pre> <p>Write the atoms to a temporary file in the tmp folder and return the path.</p> <p>Args:</p> <pre><code>create_tmp_folder:\natoms (ase.Atoms): The atoms object.\nfilename (str): The filename of the temporary file.\n</code></pre> <p>Returns:</p> <pre><code>filepath (str): The path of the temporary file\n</code></pre> Source code in <code>himatcal/atoms/core.py</code> <pre><code>def tmp_atoms(atoms, filename=\"tmp.xyz\", create_tmp_folder=True):\n    \"\"\"\n    Write the atoms to a temporary file in the tmp folder and return the path.\n\n    Args:\n\n        create_tmp_folder:\n        atoms (ase.Atoms): The atoms object.\n        filename (str): The filename of the temporary file.\n\n    Returns:\n\n        filepath (str): The path of the temporary file\n    \"\"\"\n\n    _CWD = Path.cwd()\n    if create_tmp_folder:\n        from monty.os import makedirs_p\n\n        tmp_path = _CWD / \"tmp\"\n        makedirs_p(tmp_path)\n        filepath = _CWD / \"tmp\" / filename\n    else:\n        filepath = _CWD / filename\n    write(filepath, atoms, format=\"xyz\")\n    return filepath\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.unit_converter","title":"unit_converter","text":"<pre><code>unit_converter(file_content)\n</code></pre> <p>convert the unit from bohr to angstrom</p> Source code in <code>himatcal/atoms/core.py</code> <pre><code>def unit_converter(file_content):\n    \"\"\"\n    convert the unit from bohr to angstrom\n    \"\"\"\n    import tempfile\n\n    from ase.io import read\n\n    bohr_to_angstrom = 0.529177\n    try:\n        tempfile_path = write2tempxyz(file_content)\n    except Exception as e:\n        tempfile_path = write2tempxyz(file_content, mode=\"w+\")\n    atoms_bohr = read(tempfile_path)\n    atoms_angstrom = atoms_bohr.copy()\n    positions_bohr = atoms_bohr.get_positions()\n    positions_angstrom = positions_bohr * bohr_to_angstrom\n    atoms_angstrom.set_positions(positions_angstrom)\n    temp_angstrom_atoms_path = tempfile.mktemp(suffix=\".xyz\")\n    atoms_angstrom.write(temp_angstrom_atoms_path)\n    # print(temp_angstrom_atoms_path)\n    return temp_angstrom_atoms_path\n</code></pre>"},{"location":"reference/himatcal/atoms/core.html#himatcal.atoms.core.write2tempxyz","title":"write2tempxyz","text":"<pre><code>write2tempxyz(content, mode='wb+', format='.xyz')\n</code></pre> <p>Write the content to a temporary file in the tmp folder and return the path.</p> Source code in <code>himatcal/atoms/core.py</code> <pre><code>def write2tempxyz(content, mode=\"wb+\", format=\".xyz\"):\n    \"\"\"\n    Write the content to a temporary file in the tmp folder and return the path.\n    \"\"\"\n    import tempfile\n\n    tempfile_path = tempfile.mktemp(suffix=format)\n    # print(tempfile_path)\n    with open(tempfile_path, mode) as f:\n        f.write(content)\n    return tempfile_path\n</code></pre>"},{"location":"reference/himatcal/atoms/parser.html","title":"parser","text":""},{"location":"reference/himatcal/atoms/parser.html#himatcal.atoms.parser.mol2xyz","title":"mol2xyz","text":"<pre><code>mol2xyz(mol, comment=None)\n</code></pre> <p>Convert rdkit mol to xyz file. from https://github.com/yanfeiguan/QM_descriptors_calculation/blob/master/lib/file_parser.py</p> Source code in <code>himatcal/atoms/parser.py</code> <pre><code>def mol2xyz(mol, comment=None):\n    \"\"\"\n    Convert rdkit mol to xyz file.\n    from https://github.com/yanfeiguan/QM_descriptors_calculation/blob/master/lib/file_parser.py\n    \"\"\"\n    c = mol.GetConformers()[0]\n    coords = c.GetPositions()\n    atoms = [a.GetSymbol() for a in mol.GetAtoms()]\n\n    xyz = f\"{len(atoms)}\\n{comment}\\n\"\n    for a, c in zip(atoms, coords):\n        xyz += \"{}     {:14.9f}    {:14.9f}    {:14.9f}\\n\".format(a, *c)\n\n    return xyz\n</code></pre>"},{"location":"reference/himatcal/atoms/parser.html#himatcal.atoms.parser.xyz2mol","title":"xyz2mol","text":"<pre><code>xyz2mol(xyz, smiles)\n</code></pre> <p>Convert xyz files to rdkit mol. from https://github.com/yanfeiguan/QM_descriptors_calculation/blob/master/lib/file_parser.py</p> Source code in <code>himatcal/atoms/parser.py</code> <pre><code>def xyz2mol(xyz, smiles):\n    \"\"\"\n    Convert xyz files to rdkit mol.\n    from https://github.com/yanfeiguan/QM_descriptors_calculation/blob/master/lib/file_parser.py\n    \"\"\"\n    lines = xyz.splitlines()\n    N_atoms = int(lines[0])\n    comments = lines[1]\n\n    if N_atoms != len(lines[2:]):\n        raise ValueError(\"Number of atoms does not match\")\n\n    mol = Chem.MolFromSmiles(smiles)\n    AllChem.EmbedMolecule(mol, AllChem.ETKDG())\n    mol = Chem.AddHs(mol, addCoords=True)\n    try:\n        conf = mol.GetConformers()[0]\n    except Exception:\n        AllChem.EmbedMultipleConfs(\n            mol,\n            numConfs=1,\n            pruneRmsThresh=0.5,\n            randomSeed=1,\n            useExpTorsionAnglePrefs=True,\n            useBasicKnowledge=True,\n        )\n        try:\n            conf = mol.GetConformers()[0]\n        except Exception:\n            return None, None\n\n    atoms = [a.GetSymbol() for a in mol.GetAtoms()]\n    for i, coord in enumerate(lines[2:]):\n        split_coord = coord.split()\n\n        if atoms[i] != split_coord[0]:\n            raise ValueError(\"Atom does not match\")\n\n        conf.SetAtomPosition(i, np.array(split_coord[1:]).astype(\"float\"))\n\n    mol.SetProp(\"comments\", comments)\n    return mol, comments\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html","title":"aio_ani","text":"<p>https://github.com/dralgroup/aio-ani/blob/main/aio_ani.py</p>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.device","title":"device  <code>module-attribute</code>","text":"<pre><code>device = device('cuda' if is_available() else 'cpu')\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI","title":"AIO_ANI","text":"<pre><code>AIO_ANI(model_path, **kwargs)\n</code></pre> <p>               Bases: <code>Calculator</code></p> Source code in <code>himatcal/calculator/aio_ani.py</code> <pre><code>def __init__(self, model_path, **kwargs):\n    super().__init__(**kwargs)\n    self.model_path = model_path\n    self.device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    self.species_order = [1, 6, 7, 8]\n\n    self.AEV_setup()\n    self.NN_setup()\n    self.model_setup()\n    self.load()\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = device('cuda' if is_available() else 'cpu')\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.implemented_properties","title":"implemented_properties  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implemented_properties = ['energy', 'forces']\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.model_path","title":"model_path  <code>instance-attribute</code>","text":"<pre><code>model_path = model_path\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.species_order","title":"species_order  <code>instance-attribute</code>","text":"<pre><code>species_order = [1, 6, 7, 8]\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.AEV_setup","title":"AEV_setup","text":"<pre><code>AEV_setup()\n</code></pre> Source code in <code>himatcal/calculator/aio_ani.py</code> <pre><code>def AEV_setup(self):\n    self.Rcr = 5.2000e00\n    self.Rca = 4.0\n    nshiftA = 4\n    self.ShfA = torch.linspace(0.9, self.Rca, nshiftA + 1, device=self.device)[:-1]\n    self.EtaR = torch.tensor([1.6000000e01], device=self.device)\n    self.ShfR = torch.tensor(\n        [\n            9.0000000e-01,\n            1.1687500e00,\n            1.4375000e00,\n            1.7062500e00,\n            1.9750000e00,\n            2.2437500e00,\n            2.5125000e00,\n            2.7812500e00,\n            3.0500000e00,\n            3.3187500e00,\n            3.5875000e00,\n            3.8562500e00,\n            4.1250000e00,\n            4.3937500e00,\n            4.6625000e00,\n            4.9312500e00,\n        ],\n        device=self.device,\n    )\n    self.Zeta = torch.tensor([3.2000000e01], device=self.device)\n    self.ShfZ = torch.tensor(\n        [\n            1.9634954e-01,\n            5.8904862e-01,\n            9.8174770e-01,\n            1.3744468e00,\n            1.7671459e00,\n            2.1598449e00,\n            2.5525440e00,\n            2.9452431e00,\n        ],\n        device=self.device,\n    )\n    self.EtaA = torch.tensor([8.0000000e00], device=self.device)\n    self.aev_computer = torchani.AEVComputer(\n        self.Rcr,\n        self.Rca,\n        self.EtaR,\n        self.ShfR,\n        self.EtaA,\n        self.Zeta,\n        self.ShfA,\n        self.ShfZ,\n        len(self.species_order),\n    )\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.NN_setup","title":"NN_setup","text":"<pre><code>NN_setup()\n</code></pre> Source code in <code>himatcal/calculator/aio_ani.py</code> <pre><code>def NN_setup(self):\n    aev_dim = self.aev_computer.aev_length + 1\n    H_network = torch.nn.Sequential(\n        torch.nn.Linear(aev_dim, 256),\n        torch.nn.GELU(),\n        torch.nn.Linear(256, 192),\n        torch.nn.GELU(),\n        torch.nn.Linear(192, 160),\n        torch.nn.GELU(),\n        torch.nn.Linear(160, 1),\n    )\n\n    C_network = torch.nn.Sequential(\n        torch.nn.Linear(aev_dim, 224),\n        torch.nn.GELU(),\n        torch.nn.Linear(224, 192),\n        torch.nn.GELU(),\n        torch.nn.Linear(192, 160),\n        torch.nn.GELU(),\n        torch.nn.Linear(160, 1),\n    )\n\n    N_network = torch.nn.Sequential(\n        torch.nn.Linear(aev_dim, 192),\n        torch.nn.GELU(),\n        torch.nn.Linear(192, 160),\n        torch.nn.GELU(),\n        torch.nn.Linear(160, 128),\n        torch.nn.GELU(),\n        torch.nn.Linear(128, 1),\n    )\n\n    O_network = torch.nn.Sequential(\n        torch.nn.Linear(aev_dim, 192),\n        torch.nn.GELU(),\n        torch.nn.Linear(192, 160),\n        torch.nn.GELU(),\n        torch.nn.Linear(160, 128),\n        torch.nn.GELU(),\n        torch.nn.Linear(128, 1),\n    )\n\n    self.nn = torchani.ANIModel([H_network, C_network, N_network, O_network])\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.calculate","title":"calculate","text":"<pre><code>calculate(atoms: Atoms = None, properties=['energy'], system_changes=all_changes)\n</code></pre> Source code in <code>himatcal/calculator/aio_ani.py</code> <pre><code>def calculate(\n    self, atoms: Atoms = None, properties=[\"energy\"], system_changes=all_changes\n):\n    super().calculate(atoms, properties, system_changes)\n    level = \"CCSD(T)*/CBS\"\n\n    if level.lower() == \"ccsd(t)*/cbs\".lower():\n        self.method = np.array([1])\n        self.sae = self.modeldict[\"cc_sae\"]\n    elif level.lower() == \"wb97x/def2-tzvp\".lower():\n        self.method = np.array([0])\n        self.sae = self.modeldict[\"dft_sae\"]\n\n    from torchani.utils import ChemicalSymbolsToInts\n\n    species_to_tensor = ChemicalSymbolsToInts(self.species_order)\n    atomic_numbers = np.array(atoms.numbers)\n    coordinates = torch.tensor(atoms.positions).to(self.device).requires_grad_(True)\n\n    coordinates = coordinates.unsqueeze(0)\n    species = species_to_tensor(atomic_numbers).to(self.device).unsqueeze(0)\n    method_vector = torch.tensor([self.method], device=self.device)\n    _, ANI_NN_energies = self.model((species, coordinates, method_vector))\n    predicted_energies = ANI_NN_energies.item()\n    for ss in species[0]:\n        predicted_energies += self.sae[ss.item()]\n\n    self.results[\"energy\"] = predicted_energies\n\n    if \"forces\" in properties:\n        ANI_NN_energy_gradients = torch.autograd.grad(\n            ANI_NN_energies.sum(), coordinates, create_graph=True, retain_graph=True\n        )[0][0]\n        forces = -ANI_NN_energy_gradients.detach().cpu().numpy()\n        self.results[\"forces\"] = forces\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.load","title":"load","text":"<pre><code>load()\n</code></pre> Source code in <code>himatcal/calculator/aio_ani.py</code> <pre><code>def load(self):\n    self.modeldict = torch.load(self.model_path, map_location=torch.device(\"cpu\"))\n    self.nn.load_state_dict(self.modeldict[\"nn\"])\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.AIO_ANI.model_setup","title":"model_setup","text":"<pre><code>model_setup()\n</code></pre> Source code in <code>himatcal/calculator/aio_ani.py</code> <pre><code>def model_setup(self):\n    self.model = Sequential_modified(self.aev_computer, self.nn).to(self.device)\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.Sequential_modified","title":"Sequential_modified","text":"<pre><code>Sequential_modified(*modules)\n</code></pre> <p>               Bases: <code>ModuleList</code></p> Source code in <code>himatcal/calculator/aio_ani.py</code> <pre><code>def __init__(self, *modules):\n    super(Sequential_modified, self).__init__(modules)\n</code></pre>"},{"location":"reference/himatcal/calculator/aio_ani.html#himatcal.calculator.aio_ani.Sequential_modified.forward","title":"forward","text":"<pre><code>forward(input_: Tuple[Tensor, Tensor, Tensor], cell: Optional[Tensor] = None, pbc: Optional[Tensor] = None)\n</code></pre> Source code in <code>himatcal/calculator/aio_ani.py</code> <pre><code>def forward(\n    self,\n    input_: Tuple[Tensor, Tensor, Tensor],\n    cell: Optional[Tensor] = None,\n    pbc: Optional[Tensor] = None,\n):\n    input_1_ = self[0](input_[:2], cell=cell, pbc=pbc)\n    aev_vector = input_1_.aevs\n    methods_vector = input_[-1]\n    methods_vector_expand = methods_vector.unsqueeze(1).repeat(\n        1, aev_vector.shape[1], 1\n    )\n    aev_vector_method = torch.cat((aev_vector, methods_vector_expand), 2)\n\n    species = input_1_.species\n    from torchani.aev import SpeciesAEV\n\n    aev_vector_method = aev_vector_method.to(device).float()\n    species = species.to(device).float()\n    input_species_AEV_method = SpeciesAEV(species, aev_vector_method)\n    input_ = self[1](input_species_AEV_method, cell=cell, pbc=pbc)\n    return input_\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html","title":"gaussian_mcd","text":""},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.FastGaussian","title":"FastGaussian","text":"<pre><code>FastGaussian(command='g09', working_directory=None)\n</code></pre> <p>               Bases: <code>Gaussian</code></p> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def __init__(self, command=\"g09\", working_directory=None):\n    super().__init__(command, working_directory)\n    self.old_chk_name = \"old\"\n    self.new_chk_name = \"new\"\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.FastGaussian.new_chk_name","title":"new_chk_name  <code>instance-attribute</code>","text":"<pre><code>new_chk_name = 'new'\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.FastGaussian.old_chk_name","title":"old_chk_name  <code>instance-attribute</code>","text":"<pre><code>old_chk_name = 'old'\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.FastGaussian.change_chk_file","title":"change_chk_file","text":"<pre><code>change_chk_file()\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def change_chk_file(self):\n    old_chk_directory = os.path.join(\n        self.working_directory, self.old_chk_name + \".chk\"\n    )\n    new_chk_directory = os.path.join(\n        self.working_directory, self.new_chk_name + \".chk\"\n    )\n    os.system(f\"mv {new_chk_directory} {old_chk_directory}\")\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.FastGaussian.get_content","title":"get_content","text":"<pre><code>get_content()\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def get_content(self):\n    # Check whether old one exists\n    content = self.content\n    if os.path.exists(f\"{self.old_chk_name}.chk\"):\n        # print ('check point exists!!!')\n        content = f\"%oldchk={self.old_chk_name}.chk\\n\" + content\n        content = content + \" guess=read \"\n    content = f\"%chk={self.new_chk_name}.chk\\n\" + content\n    return content\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.FastGaussian.get_energy","title":"get_energy","text":"<pre><code>get_energy(molecule, chg=None, multiplicity=None, file_name='test', extra='', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def get_energy(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"test\",\n    extra=\"\",\n    save_directory=None,\n):\n    energy = super().get_energy(\n        molecule, chg, multiplicity, file_name, extra, save_directory\n    )\n    self.change_chk_file()\n    return energy\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.FastGaussian.get_force","title":"get_force","text":"<pre><code>get_force(molecule, chg=None, multiplicity=None, file_name='test', extra=' Symmetry = None', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def get_force(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"test\",\n    extra=\" Symmetry = None\",\n    save_directory=None,\n):\n    force = super().get_force(\n        molecule, chg, multiplicity, file_name, extra, save_directory\n    )\n    self.change_chk_file()\n    return force\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.FastGaussian.optimize_geometry","title":"optimize_geometry","text":"<pre><code>optimize_geometry(molecule, constraints={}, chg=None, multiplicity=None, file_name='test', extra='', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def optimize_geometry(\n    self,\n    molecule,\n    constraints={},\n    chg=None,\n    multiplicity=None,\n    file_name=\"test\",\n    extra=\"\",\n    save_directory=None,\n):\n    trajectory = super().optimize_geometry(\n        molecule, constraints, chg, multiplicity, file_name, extra, save_directory\n    )\n    self.change_chk_file()\n    return trajectory\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian","title":"Gaussian","text":"<pre><code>Gaussian(command='g16', working_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def __init__(self, command=\"g16\", working_directory=None):\n    # Check command\n    self.name = \"gaussian\"\n    check = distutils.spawn.find_executable(command)\n    if check is not None:\n        self.command = command\n    else:\n        # Check default command\n        commands = [\"g09\", \"g16\"]\n        found = False\n        for old_command in commands:\n            check = distutils.spawn.find_executable(old_command)\n            if check is not None:\n                self.command = old_command\n                print(\n                    f\"command {self.command} is used for running Gaussian, instead of {command}!\"\n                )\n                found = True\n                break\n        if not found:\n            print(\"Gaussian not found!\")\n            exit()\n\n    if working_directory is not None and not os.path.exists(working_directory):\n        os.system(f\"mkdir {working_directory}\")\n        if not os.path.exists(working_directory):\n            print(\"Defined working directory does not exist!!!\")\n            working_directory = None\n\n    if working_directory is None:\n        working_directory = os.getcwd()\n        print(\"working directory is set to current diretory:\", working_directory)\n\n    self.working_directory = working_directory\n    # Check save directory\n    self.content = \"#p pm6 scf(xqc) \"\n    self.energy_unit = \"Hartree\"\n    self.distance_unit = \"Bohr\"\n    self.radian_unit = \"Radian\"\n    self.basis = \"\"\n    self.error_directory = None\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.basis","title":"basis  <code>instance-attribute</code>","text":"<pre><code>basis = ''\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command = command\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content = '#p pm6 scf(xqc) '\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.distance_unit","title":"distance_unit  <code>instance-attribute</code>","text":"<pre><code>distance_unit = 'Bohr'\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.energy_unit","title":"energy_unit  <code>instance-attribute</code>","text":"<pre><code>energy_unit = 'Hartree'\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.error_directory","title":"error_directory  <code>instance-attribute</code>","text":"<pre><code>error_directory = None\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = 'gaussian'\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.radian_unit","title":"radian_unit  <code>instance-attribute</code>","text":"<pre><code>radian_unit = 'Radian'\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.working_directory","title":"working_directory  <code>instance-attribute</code>","text":"<pre><code>working_directory = working_directory\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def __str__(self):\n    content = \"\"\n    content += f\"working_directory: {self.working_directory}\\n\"\n    content += f\"command: {self.command}\\n\"\n    content += f\"Energy: {self.energy_unit}\\n\\n\"\n    content += f\"###### qc_input ######\\n{self.content}\\n\"\n    return content\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.change_working_directory","title":"change_working_directory","text":"<pre><code>change_working_directory(working_directory)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def change_working_directory(self, working_directory):\n    # Get current reaction coordinate\n    if not os.path.exists(working_directory):\n        print(\"Working directory does not exist! Creating new directory ...\")\n        os.system(f\"mkdir {working_directory}\")\n        if not os.path.exists(working_directory):\n            print(\n                \"Cannot create working directory!!!\\n Recheck your working directory ...\"\n            )\n            exit()\n        else:\n            print(\"working directory changed into:\", working_directory)\n            self.working_directory = working_directory\n    else:\n        print(\"working directory changed into:\", working_directory)\n        self.working_directory = working_directory\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.clean_scratch","title":"clean_scratch","text":"<pre><code>clean_scratch(file_name='test.com')\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def clean_scratch(self, file_name=\"test.com\"):\n    working_directory = self.working_directory\n    chk_directory = os.path.join(working_directory, \"old.chk\")\n    os.system(f\"rm {chk_directory}\")\n    chk_directory = os.path.join(working_directory, \"new.chk\")\n    os.system(f\"rm {chk_directory}\")\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.get_content","title":"get_content","text":"<pre><code>get_content()\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def get_content(self):\n    return self.content\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.get_default_mol_params","title":"get_default_mol_params","text":"<pre><code>get_default_mol_params(molecule)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def get_default_mol_params(self, molecule):\n    try:\n        chg = molecule.get_chg()\n    except:\n        chg = 0\n    try:\n        multiplicity = molecule.get_multiplicity()\n    except:\n        multiplicity = None\n    if multiplicity is None:\n        try:\n            e_list = molecule.get_num_of_lone_pair_list()\n            num_of_unpaired_e = len(np.where((2 * e_list) % 2 == 1)[0])\n            multiplicity = num_of_unpaired_e + 1\n        except:\n            z_sum = np.sum(molecule.get_z_list())\n            multiplicity = (z_sum - chg) % 2 + 1\n    return chg, multiplicity\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.get_energy","title":"get_energy","text":"<pre><code>get_energy(molecule, chg=None, multiplicity=None, file_name='sp', extra='', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def get_energy(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"sp\",\n    extra=\"\",\n    save_directory=None,\n):\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    if \"sp\" not in extra:\n        extra = \" sp \" + extra\n    self.make_input([molecule], chg, multiplicity, file_name=file_name, extra=extra)\n    os.system(f\"{self.command} {file_name}.com\")\n    # Read output\n    p = cclib.parser.Gaussian(f\"{file_name}.log\")\n    data = p.parse()\n    try:\n        data.scfenergies\n    except:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"gaussian.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Gaussian Energy Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return None\n    self.move_file(file_name, save_directory)\n    converter = 1\n    os.chdir(current_directory)\n    if str.lower(self.energy_unit) == \"kcal\":\n        converter = 23.06\n    if str.lower(self.energy_unit) == \"hartree\":\n        converter = 0.036749326681\n    # os.system('mv new.chk old.chk')\n    os.chdir(current_directory)\n    return converter * data.scfenergies[-1]\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.get_force","title":"get_force","text":"<pre><code>get_force(molecule, chg=None, multiplicity=None, file_name='force', extra=' Symmetry = None', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def get_force(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"force\",\n    extra=\" Symmetry = None\",\n    save_directory=None,\n):\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    if \"force\" not in extra:\n        extra = \" force \" + extra\n    if \"Symmetry\" not in extra:\n        extra = extra + \" Symmetry = None \"\n    self.make_input([molecule], chg, multiplicity, file_name=file_name, extra=extra)\n    os.system(f\"{self.command} {file_name}.com\")\n    # Read output\n    p = cclib.parser.Gaussian(f\"{file_name}.log\")\n    data = p.parse()\n    bohr_to_angstrom = 0.529177\n    try:\n        data.grads\n    except:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"gaussian.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Gaussian Force Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return None\n    self.move_file(file_name, save_directory)\n    # os.system('mv new.chk old.chk')\n    os.chdir(current_directory)\n    return data.grads[-1] / bohr_to_angstrom\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.get_hessian","title":"get_hessian","text":"<pre><code>get_hessian(molecule, chg=None, multiplicity=None, file_name='hessian', extra=' Symmetry = None', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def get_hessian(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"hessian\",\n    extra=\" Symmetry = None\",\n    save_directory=None,\n):\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    original_content = self.content\n    if \"chk\" not in self.content:\n        self.content = \"%chk=hessian.chk\\n\" + self.content\n    if \"freq\" not in extra:\n        extra = \" freq \" + extra\n    if \"Symmetry\" not in extra:\n        extra = extra + \" Symmetry = None \"\n    self.make_input([molecule], chg, multiplicity, file_name=file_name, extra=extra)\n    os.system(f\"{self.command} {file_name}.com\")\n    os.system(\"formchk hessian.chk\")\n    force = []\n    hessian = []\n    bohr_to_angstrom = 0.529177  # Units are Hartree/bohr in chkpoint file\n\n    if not os.path.exists(\"hessian.chk\"):\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"gaussian.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Gaussian Hessian Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return None\n\n    # Read fchk file\n    with open(\"hessian.fchk\", \"r\") as f:\n        lines = f.readlines()\n        index = 0\n        while index &lt; len(lines):\n            line = lines[index]\n            if \"Cartesian Gradient\" in line:\n                index += 1\n                line = lines[index]\n                infos = line.strip().split()\n                # Read line\n                while True:\n                    try:\n                        float(infos[0])\n                    except:\n                        break\n                    force = force + [float(info) for info in infos]\n                    index += 1\n                    line = lines[index]\n                    infos = line.strip().split()\n\n            if \"Cartesian Force Constant\" in line:\n                index += 1\n                line = lines[index]\n                infos = line.strip().split()\n                # Read line\n                while True:\n                    try:\n                        float(infos[0])\n                    except:\n                        break\n                    hessian = hessian + [float(info) for info in infos]\n                    index += 1\n                    line = lines[index]\n                    infos = line.strip().split()\n\n            index += 1\n            if len(force) &gt; 0 and len(hessian) &gt; 0:\n                break\n\n    n = len(molecule.atom_list)\n    force = -np.array(force)\n    force = np.reshape(force, (n, 3))\n    new_hessian = np.zeros((3 * n, 3 * n))\n    cnt = 0\n    for i in range(3 * n):\n        for j in range(i + 1):\n            new_hessian[i][j] = new_hessian[j][i] = hessian[cnt]\n            cnt += 1\n    hessian = new_hessian\n    self.move_file(file_name, save_directory)\n    # os.system('mv new.chk old.chk')\n    os.chdir(current_directory)\n    self.content = original_content\n    return force / bohr_to_angstrom, hessian / bohr_to_angstrom**2\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.load_basis","title":"load_basis","text":"<pre><code>load_basis(basis_directory)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def load_basis(self, basis_directory):\n    if os.path.exists(basis_directory):\n        basis = \"\"\n        with open(basis_directory) as f:\n            for line in f:\n                basis = basis + line\n        self.basis = basis\n    else:\n        print(\"basis file does not exist!!!\")\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.load_content","title":"load_content","text":"<pre><code>load_content(template_directory)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def load_content(self, template_directory):\n    if os.path.exists(template_directory):\n        content = \"\"\n        with open(template_directory) as f:\n            lines = f.readlines()\n            n = len(lines)\n            for i, line in enumerate(lines):\n                if i == n - 1:\n                    line = line.strip()\n                content = content + line\n        self.content = content\n    else:\n        print(\"qc input file does not exist!!!\")\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.make_input","title":"make_input","text":"<pre><code>make_input(molecules, chg=None, multiplicity=None, file_name='test', constraints={}, extra='')\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def make_input(\n    self,\n    molecules,\n    chg=None,\n    multiplicity=None,\n    file_name=\"test\",\n    constraints={},\n    extra=\"\",\n):\n    f = open(f\"{file_name}.com\", \"w\")\n    if chg is None or multiplicity is None:\n        if molecules[0] is not None:\n            chg, multiplicity = self.get_default_mol_params(molecules[0])\n        elif molecules[-1] is not None:\n            chg, multiplicity = self.get_default_mol_params(molecules[-1])\n    content = self.get_content()\n    if len(constraints) &gt; 0:\n        if \"modredundant\" not in extra:\n            print(\"WARNING! Fixed optimization is not working ...\")\n            print(\"constraints:\", constraints, extra)\n    content = content + f\"{extra}\\n\\n\"\n    f.write(content)\n    labels = [\"R\", \"P\", \"TS\"]\n    for i, molecule in enumerate(molecules):\n        if molecule is not None:\n            f.write(f\"{labels[i]}\\n\\n\")\n            self.write_molecule_info(f, molecule, chg, multiplicity)\n    ### Write constraints\n    for constraint in constraints:\n        constraint_info = []\n        if len(constraint) == 1:\n            constraint_info.append(\"X\")\n        elif len(constraint) == 2:\n            constraint_info.append(\"B\")\n        elif len(constraint) == 3:\n            constraint_info.append(\"A\")\n        else:\n            constraint_info.append(\"D\")\n        for index in constraint:\n            constraint_info.append(str(index + 1))\n        constraint_info.append(\"F\")\n        f.write(\" \".join(constraint_info) + \"\\n\")\n    f.write(\"\\n\")  # Additional empty line required\n    self.write_basis(f)\n    f.write(\"\\n\")\n    f.close()\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.make_uff_input","title":"make_uff_input","text":"<pre><code>make_uff_input(molecule, chg=None, multiplicity=None, option='opt', file_name='test', constraints={})\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def make_uff_input(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    option=\"opt\",\n    file_name=\"test\",\n    constraints={},\n):\n    bo_matrix = molecule.get_bo_matrix()\n    if bo_matrix is None:\n        bo_matrix = molecule.get_adj_matrix()\n        if bo_matrix is None:\n            bo_matrix = process.get_adj_matrix_from_distance(molecule, 1.2)\n            if bo_matrix is None:\n                print(\"Cannot define connectivity !!!\")\n                return None\n    # bo matrix is now defined ...\n    f = open(f\"{file_name}.com\", \"w\")\n    if chg is None or multiplicity is None:\n        chg, multiplicity = self.get_default_mol_params(molecule)\n    content = \"\"\n    content = content + option + \"\\n\\ntest\\n\\n\"\n    f.write(content)\n    self.write_molecule_info(f, molecule, chg, multiplicity)\n    ### Write constraints\n    for constraint in constraints:\n        constraint_info = []\n        if len(constraint) == 1:\n            constraint_info.append(\"X\")\n        elif len(constraint) == 2:\n            constraint_info.append(\"B\")\n        elif len(constraint) == 3:\n            constraint_info.append(\"A\")\n        else:\n            constraint_info.append(\"D\")\n        for index in constraint:\n            constraint_info.append(str(index + 1))\n        constraint_info.append(\"F\")\n        f.write(\" \".join(constraint_info) + \"\\n\")\n    f.write(\"\\n\")  # Additional empty line required\n    self.write_basis(f)\n    f.write(\"\\n\")\n    f.close()\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.move_file","title":"move_file","text":"<pre><code>move_file(file_name, save_directory)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def move_file(self, file_name, save_directory):\n    if file_name is not None and save_directory is not None:\n        os.system(f\"mv {file_name}.com {save_directory}/\")\n        os.system(f\"mv {file_name}.log {save_directory}/\")\n        os.system(f\"mv *chk {save_directory}/\")\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.optimize_geometry","title":"optimize_geometry","text":"<pre><code>optimize_geometry(molecule, constraints={}, chg=None, multiplicity=None, file_name='test', extra='', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def optimize_geometry(\n    self,\n    molecule,\n    constraints={},\n    chg=None,\n    multiplicity=None,\n    file_name=\"test\",\n    extra=\"\",\n    save_directory=None,\n):\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    if \"opt\" not in extra:\n        extra = \" opt \" + extra\n    self.make_input([molecule], chg, multiplicity, file_name, constraints, extra)\n    os.system(f\"{self.command} {file_name}.com\")\n    # Read output\n    p = cclib.parser.Gaussian(f\"{file_name}.log\")\n    data = p.parse()\n    self.move_file(file_name, save_directory)\n    trajectory = []\n\n    try:\n        geometries = data.atomcoords\n        energies = data.scfenergies\n    except:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"gaussian.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Gaussian Optimization Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return []\n\n    if len(geometries) &lt; 1:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"gaussian.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Gaussian Optimization Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return []\n\n    converter = 1\n    if str.lower(self.energy_unit) == \"kcal\":\n        converter = 23.06\n    if str.lower(self.energy_unit) == \"hartree\":\n        converter = 0.036749326681\n        # converter = 1/27.2114\n\n    energies *= converter\n    minimum_energy = 10000000\n    min_index = 0\n\n    for i, coordinate_list in enumerate(geometries):\n        copied_molecule = molecule.copy()\n        process.locate_molecule(copied_molecule, coordinate_list)\n        copied_molecule.adj_matrix = None\n        copied_molecule.bo_matrix = None\n        copied_molecule.energy = energies[i]\n        trajectory.append(copied_molecule)\n        if minimum_energy &gt; energies[i]:\n            min_index = i\n            minimum_energy = energies[i]\n\n    coordinate_list = geometries[\n        min_index\n    ]  # Sometimes length is not matched, it performs extra scfenergy calculation\n    process.locate_molecule(molecule, coordinate_list)\n    molecule.energy = energies[min_index]\n    # os.system('mv new.chk old.chk')\n    os.chdir(current_directory)\n    return trajectory\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.relax_geometry","title":"relax_geometry","text":"<pre><code>relax_geometry(molecule, constraints, chg=None, multiplicity=None, file_name='test', num_relaxation=10000, maximal_displacement=1000, extra='', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def relax_geometry(\n    self,\n    molecule,\n    constraints,\n    chg=None,\n    multiplicity=None,\n    file_name=\"test\",\n    num_relaxation=10000,\n    maximal_displacement=1000,\n    extra=\"\",\n    save_directory=None,\n):\n    options = []\n    if len(constraints) &gt; 0:\n        options.append(\"modredundant,loose\")\n    else:\n        options.append(\"loose\")\n    if maximal_displacement is not None and maximal_displacement &lt; 100:\n        max_step = int(maximal_displacement * 100) + 1\n        options.append(f\"maxstep={max_step},notrust\")\n    if num_relaxation is not None and num_relaxation &lt; 10000:\n        options.append(f\"maxcycles={num_relaxation}\")\n    if len(options) &gt; 0:\n        content = \" opt(\" + \",\".join(options) + \") \"\n    else:\n        content = \" opt \"\n    extra = content + extra + \" Symmetry = None\"\n    return self.optimize_geometry(\n        molecule, constraints, chg, multiplicity, file_name, extra, save_directory\n    )\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.run","title":"run","text":"<pre><code>run(molecule, chg=None, multiplicity=None, file_name='test', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def run(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"test\",\n    save_directory=None,\n):  # Running with user defined result and return raw data\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    self.make_input(molecule, chg, multiplicity, file_name, {}, \"\")\n    os.system(f\"{self.command} {file_name}.com\")\n    # Read output\n    p = cclib.parser.Gaussian(f\"{file_name}.log\")\n    data = p.parse()\n    self.move_file(file_name, save_directory)\n    converter = 1\n    if str.lower(self.energy_unit) == \"kcal\":\n        converter = 23.06\n    if str.lower(self.energy_unit) == \"hartree\":\n        converter = 0.036749326681\n    if \"opt\" in self.content:\n        print(\"Running optimization !!!\")\n        index = np.argmin(data.scfenergies)\n        if index &gt; len(data.atomcoords) - 1:\n            index = -1\n        coordinate_list = data.atomcoords[\n            index\n        ]  # Sometimes length is not matched, it performs extra scfenergy calculation\n        energy = data.scfenergies[index] * converter\n        process.locate_molecule(molecule, coordinate_list)\n        molecule.energy = energy\n    os.chdir(current_directory)\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.set_error_directory","title":"set_error_directory","text":"<pre><code>set_error_directory(error_directory)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def set_error_directory(self, error_directory):\n    try:\n        if os.path.exists(error_directory):\n            self.error_directory = error_directory\n        else:\n            print(f\"Given error directory: {error_directory} does not exist!!! \")\n    except:\n        print(error_directory)\n        print(\"Check your error directory !!!\")\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.write_basis","title":"write_basis","text":"<pre><code>write_basis(f)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def write_basis(self, f):\n    if self.basis != \"\":\n        f.write(f\"{self.basis}\\n\")\n</code></pre>"},{"location":"reference/himatcal/calculator/gaussian_mcd.html#himatcal.calculator.gaussian_mcd.Gaussian.write_molecule_info","title":"write_molecule_info","text":"<pre><code>write_molecule_info(f, molecule, chg, multiplicity)\n</code></pre> Source code in <code>himatcal/calculator/gaussian_mcd.py</code> <pre><code>def write_molecule_info(self, f, molecule, chg, multiplicity):\n    f.write(f\"{int(chg)} {int(multiplicity)}\\n\")\n    for atom in molecule.atom_list:\n        f.write(atom.get_content())\n    f.write(\"\\n\")\n</code></pre>"},{"location":"reference/himatcal/calculator/mlp.html","title":"mlp","text":""},{"location":"reference/himatcal/calculator/mlp.html#himatcal.calculator.mlp.get_calc","title":"get_calc","text":"<pre><code>get_calc(label, kwargs: dict | None = None)\n</code></pre> Source code in <code>himatcal/calculator/mlp.py</code> <pre><code>def get_calc(label, kwargs: dict | None = None):\n    \"\"\" \"\"\"\n    kwargs = kwargs or {}\n    device = kwargs.get(\"device\", \"cuda\" if label.startswith(\"orb\") else \"cpu\")\n\n    if label.startswith(\"orb\"):  # * orb_v2, orb_d3_v2, orb_d3_xm_v2, orb_d3_sm_v2\n        from orb_models.forcefield import pretrained\n        from orb_models.forcefield.calculator import ORBCalculator\n\n        model_path = kwargs.get(\"model\")\n        orbff = (\n            getattr(pretrained, label)(device=device, weight_path=model_path)\n            if model_path\n            else getattr(pretrained, label)(device=device)\n        )\n        return ORBCalculator(orbff, device=device)\n\n    if label == \"mace_mp\":\n        from mace.calculators import mace_mp\n\n        return mace_mp(\n            model=kwargs.get(\"model\", \"medium\"),  # * small , medium, large\n            device=device,  # * cpu, cuda\n            default_dtype=kwargs.get(\"default_type\", \"float32\"),\n            dispersion=kwargs.get(\"dispersion\", True),\n            damping=kwargs.get(\"damping\", \"bj\"),\n            dispersion_xc=kwargs.get(\"dispersion_xc\", \"pbe\"),\n            dispersion_cutoff=kwargs.get(\"dispersion_cutoff\", 40 * units.Bohr),\n        )\n\n    if label == \"mace_off\":\n        from mace.calculators import mace_off\n\n        return mace_off(\n            model=kwargs.get(\"model\", \"medium\"),\n            device=device,\n            default_dtype=kwargs.get(\"default_dtype\", \"float64\"),\n        )\n\n    if label == \"mace_anicc\":\n        from mace.calculators import mace_anicc\n\n        return mace_anicc(model_path=kwargs.get(\"model\"), device=device)\n\n    if label == \"chgnet\":\n        from chgnet.model.dynamics import CHGNetCalculator\n\n        return CHGNetCalculator(model_path=kwargs.get(\"model\"), use_device=device)\n    if label == \"aimnet2\":\n        from himatcal.calculator.aimnet import AIMNet2ASE\n\n        return AIMNet2ASE(\"aimnet2_b973c\", charge=kwargs.get(\"charge\", 0), mult=kwargs.get(\"mult\", 1))\n    return None\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html","title":"orca_mcd","text":""},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.data","title":"data  <code>module-attribute</code>","text":"<pre><code>data = parse_hessian(directory)\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.directory","title":"directory  <code>module-attribute</code>","text":"<pre><code>directory = argv[1]\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca","title":"Orca","text":"<pre><code>Orca(command='orca', working_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def __init__(self, command=\"orca\", working_directory=None):\n    check = distutils.spawn.find_executable(command)\n    self.name = \"orca\"\n    if check is None:\n        print(\"orca not found!\")\n        exit()\n    self.command = command\n    self.nproc = 1\n    self.content = \"! XTB2 \"\n    self.energy_unit = \"Hartree\"\n    # self.distance_unit = 'Bohr'\n    # self.radian_unit = 'Radian'\n\n    if working_directory is not None:\n        if not os.path.exists(working_directory):\n            os.system(f\"mkdir {working_directory}\")\n            if not os.path.exists(working_directory):\n                print(\"Defined working directory does not exist!!!\")\n                working_directory = None\n\n    if working_directory is None:\n        working_directory = os.getcwd()\n        print(\"working directory is set to current diretory:\", working_directory)\n\n    self.working_directory = working_directory\n    self.error_directory = None\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command = command\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content = '! XTB2 '\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.energy_unit","title":"energy_unit  <code>instance-attribute</code>","text":"<pre><code>energy_unit = 'Hartree'\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.error_directory","title":"error_directory  <code>instance-attribute</code>","text":"<pre><code>error_directory = None\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = 'orca'\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.nproc","title":"nproc  <code>instance-attribute</code>","text":"<pre><code>nproc = 1\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.working_directory","title":"working_directory  <code>instance-attribute</code>","text":"<pre><code>working_directory = working_directory\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def __str__(self):\n    content = \"\"\n    content = content + f\"working_directory: {self.working_directory}\\n\"\n    content = content + f\"command: {self.command}\\n\"\n    content = content + f\"Energy: {self.energy_unit}\\n\\n\"\n    content = content + f\"###### qc_input ######\\n{self.content}\\n\"\n    return content\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.change_working_directory","title":"change_working_directory","text":"<pre><code>change_working_directory(working_directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def change_working_directory(self, working_directory):\n    # Get current reaction coordinate\n    if not os.path.exists(working_directory):\n        print(\"Working directory does not exist! Creating new directory ...\")\n        os.system(f\"mkdir {working_directory}\")\n        if not os.path.exists(working_directory):\n            print(\n                \"Cannot create working directory!!!\\n Recheck your working directory ...\"\n            )\n            exit()\n        else:\n            print(\"working directory changed into:\", working_directory)\n            self.working_directory = working_directory\n    else:\n        print(\"working directory changed into:\", working_directory)\n        self.working_directory = working_directory\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.get_default_mol_params","title":"get_default_mol_params","text":"<pre><code>get_default_mol_params(molecule)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def get_default_mol_params(self, molecule):\n    try:\n        chg = molecule.get_chg()\n    except:\n        chg = 0\n    try:\n        e_list = molecule.get_num_of_lone_pair_list()\n        num_of_unpaired_e = len(np.where((2 * e_list) % 2 == 1)[0])\n        multiplicity = num_of_unpaired_e + 1\n    except:\n        z_sum = np.sum(molecule.get_z_list())\n        multiplicity = (z_sum - chg) % 2 + 1\n    return chg, multiplicity\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.get_energy","title":"get_energy","text":"<pre><code>get_energy(molecule, chg=None, multiplicity=None, file_name='sp', extra='', save_directory=None)\n</code></pre> <p>Must return energy with desired unit defined in the Calculator</p> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def get_energy(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"sp\",\n    extra=\"\",\n    save_directory=None,\n):\n    \"\"\"\n    Must return energy with desired unit defined in the Calculator\n    \"\"\"\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    self.make_input(molecule, chg, multiplicity, file_name=file_name, extra=extra)\n    os.system(f\"{self.command} {file_name}.com &gt; {file_name}.log\")\n    energy = parse_energy(\n        os.path.join(self.working_directory, f\"{file_name}.energy\")\n    )\n    self.move_file(file_name, save_directory)\n    converter = 1\n    if energy is None:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"orca.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Orca Energy Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return None\n    if self.energy_unit == \"kcal\":\n        converter = 627.509\n    if self.energy_unit == \"eV\":\n        converter = 27.2114079527\n    os.chdir(current_directory)\n    return converter * energy\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.get_force","title":"get_force","text":"<pre><code>get_force(molecule, chg=None, multiplicity=None, file_name='force', extra='', save_directory=None)\n</code></pre> <p>Must return force with desired unit defined in the Calculator</p> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def get_force(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"force\",\n    extra=\"\",\n    save_directory=None,\n):\n    \"\"\"\n    Must return force with desired unit defined in the Calculator\n    \"\"\"\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    if \"engrad\" not in extra:\n        extra = \" engrad \" + extra\n    self.make_input(molecule, chg, multiplicity, file_name=file_name, extra=extra)\n    os.system(f\"{self.command} {file_name}.com &gt; {file_name}.log\")\n    self.move_file(file_name, save_directory)\n    energy, force = parse_force(\n        os.path.join(self.working_directory, f\"{file_name}.engrad\")\n    )\n    bohr_to_angstrom = 0.529177  # Units are Hartree/bohr in chkpoint file\n    if force is None:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"orca.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Orca Force Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return None\n    os.chdir(current_directory)\n    return force / bohr_to_angstrom\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.get_hessian","title":"get_hessian","text":"<pre><code>get_hessian(molecule, chg=None, multiplicity=None, file_name='hessian', extra='', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def get_hessian(\n    self,\n    molecule,\n    chg=None,\n    multiplicity=None,\n    file_name=\"hessian\",\n    extra=\"\",\n    save_directory=None,\n):\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    original_content = self.content\n    if \"engrad\" not in extra:\n        extra = \"engrad \" + extra\n    if \"freq\" not in extra:\n        extra = \" freq \" + extra\n    self.make_input(molecule, chg, multiplicity, file_name=file_name, extra=extra)\n    os.system(f\"{self.command} {file_name}.com &gt; {file_name}.log\")\n    energy, force = parse_force(\n        os.path.join(self.working_directory, f\"{file_name}.engrad\")\n    )\n    hessian = parse_hessian(\n        os.path.join(self.working_directory, f\"{file_name}.hess\")\n    )\n    bohr_to_angstrom = 0.529177  # Units are Hartree/bohr in chkpoint file\n    if force is None:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"orca.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Orca Force Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return None, None\n    if hessian is None:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"orca.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Orca Hessian Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return None, None\n    self.move_file(file_name, save_directory)\n    os.chdir(current_directory)\n    return force / bohr_to_angstrom, hessian / bohr_to_angstrom**2\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.load_basis","title":"load_basis","text":"<pre><code>load_basis(basis_directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def load_basis(self, basis_directory):\n    basis = \"\"\n    with open(basis_directory) as f:\n        for line in f:\n            basis = basis + line\n    self.basis = basis\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.load_content","title":"load_content","text":"<pre><code>load_content(template_directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def load_content(self, template_directory):\n    content = \"\"\n    with open(template_directory) as f:\n        for line in f:\n            content = content + line\n    self.content = content\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.make_input","title":"make_input","text":"<pre><code>make_input(molecule, chg, multiplicity, file_name='test', constraints={}, extra='')\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def make_input(\n    self, molecule, chg, multiplicity, file_name=\"test\", constraints={}, extra=\"\"\n):\n    if chg is None or multiplicity is None:\n        chg, multiplicity = self.get_default_mol_params(molecule)\n\n    inpstring = self.content.strip()\n    if inpstring[0] == \"#\":\n        inpstring = inpstring[1:]\n    inpstring = inpstring + extra\n\n    \"\"\"\n    inpstring += '%scf\\nMaxIter 300\\nconvergence strong\\n sthresh 1e-7\\n'\n    inpstring += 'thresh 1e-11\\n tcut 1e-13 \\n directresetfreq 1 \\n SOSCFStart 0.00033\\nend\\n'\n    inpstring += '%scf\\nMaxIter 300\\nend\\n'\n    inpstring += '\\n%maxcore 1000\\n\\n'\n    inpstring += '%pal\\nnproc {}\\nend\\n\\n'.format(self.nproc)\n    \"\"\"\n    # if len(constraints) &gt; 0:\n    inpstring += f\"\\n*xyz {chg} {multiplicity}\\n\"\n    for atom in molecule.atom_list:\n        inpstring += atom.get_content()\n\n    inpstring += \"*\"\n    with open(f\"{file_name}.com\", \"w\") as f:\n        f.write(inpstring)\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.move_file","title":"move_file","text":"<pre><code>move_file(file_name, save_directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def move_file(self, file_name, save_directory):\n    if file_name is not None and save_directory is not None:\n        os.system(f\"mv {file_name}.* {save_directory}/\")\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.optimize_geometry","title":"optimize_geometry","text":"<pre><code>optimize_geometry(molecule, constraints={}, chg=None, multiplicity=None, file_name='opt', extra='', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def optimize_geometry(\n    self,\n    molecule,\n    constraints={},\n    chg=None,\n    multiplicity=None,\n    file_name=\"opt\",\n    extra=\"\",\n    save_directory=None,\n):\n    current_directory = os.getcwd()\n    os.chdir(self.working_directory)\n    if \"opt\" not in extra:\n        extra = \" opt \" + extra\n\n    # Additional constraint\n    if len(constraints) &gt; 0:\n        if \"geom\" not in extra:\n            extra = extra + \"\\n\\n%geom\\nConstraints\\n\"\n        else:\n            extra = extra + \"Constraints\\n\"\n        for constraint in constraints:\n            constraint_info = []\n            if len(constraint) == 2:\n                constraint_info.append(\"{B\")\n            elif len(constraint) == 3:\n                constraint_info.append(\"{A\")\n            else:\n                constraint_info.append(\"{D\")\n            for index in constraint:\n                constraint_info.append(str(index))\n            constraint_info.append(\"C}\")\n            extra += \" \".join(constraint_info) + \"\\n\"\n        extra += \"end\\n\"\n        extra += \"end\\n\"\n\n    self.make_input(\n        molecule,\n        chg,\n        multiplicity,\n        file_name=file_name,\n        extra=extra,\n        constraints=constraints,\n    )\n    os.system(f\"{self.command} {file_name}.com &gt; {file_name}.log\")\n    relaxing_path = parse_opt(\n        os.path.join(self.working_directory, f\"{file_name}_trj.xyz\")\n    )\n    if len(relaxing_path) &lt; 2:\n        if self.error_directory is not None:\n            file_directory = os.path.join(self.error_directory, \"orca.err\")\n            with open(file_directory, \"w\") as f:\n                f.write(\"Orca Optimization Calculation failed !!!\\n\")\n                name = f\"{file_name}.log\"\n                f.write(f\"Check {os.path.join(self.working_directory,name)} ...\\n\")\n        return []\n    energy, force = parse_force(\n        os.path.join(self.working_directory, f\"{file_name}.engrad\")\n    )\n    print(\"energy\", energy)\n    process.locate_molecule(molecule, relaxing_path[-1].get_coordinate_list())\n    molecule.energy = energy\n    os.chdir(current_directory)\n    return relaxing_path\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.relax_geometry","title":"relax_geometry","text":"<pre><code>relax_geometry(molecule, constraints, chg=None, multiplicity=None, file_name='opt', num_relaxation=5, maximal_displacement=1000, extra='', save_directory=None)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def relax_geometry(\n    self,\n    molecule,\n    constraints,\n    chg=None,\n    multiplicity=None,\n    file_name=\"opt\",\n    num_relaxation=5,\n    maximal_displacement=1000,\n    extra=\"\",\n    save_directory=None,\n):\n    \"\"\" \"\"\"\n    extra = \"\\n%geom\\n\"\n    if maximal_displacement &lt; 1000:\n        maximal_displacement = -abs(maximal_displacement)\n        extra = extra + f\"Trust {maximal_displacement}\\n\"\n    if num_relaxation is not None and num_relaxation &gt; 0:\n        extra = extra + f\"MaxIter {num_relaxation}\\n\"\n    return self.optimize_geometry(\n        molecule, constraints, chg, multiplicity, file_name, extra, save_directory\n    )\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.Orca.set_error_directory","title":"set_error_directory","text":"<pre><code>set_error_directory(error_directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def set_error_directory(self, error_directory):\n    try:\n        if os.path.exists(error_directory):\n            self.error_directory = error_directory\n        else:\n            print(f\"Given error directory: {error_directory} does not exist!!! \")\n    except:\n        print(error_directory)\n        print(\"Check your error directory !!!\")\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.parse_energy","title":"parse_energy","text":"<pre><code>parse_energy(directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def parse_energy(directory):  # Read {file_name}.energy\n    try:\n        with open(directory, \"r\") as f:\n            lines = f.readlines()\n    except:\n        return None\n\n    temp = 100000\n    for i, line in enumerate(lines):\n        if \"$energy\\n\" in line:\n            temp = i\n        if i &gt; temp:\n            energy = float(line.split()[-1])\n            return energy\n    return None\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.parse_force","title":"parse_force","text":"<pre><code>parse_force(directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def parse_force(directory):  # Read {file_name}.engrad\n    with open(directory) as f:\n        lines = f.readlines()\n\n    temp = 100000\n    grads = []\n    energy = None\n    for i, line in enumerate(lines):\n        if \"# The current total energy\" in line:\n            energy = float(lines[i + 2].strip())\n        if \"# The current gradient in Eh/bohr\" in line:\n            temp = i\n        if i &gt; temp + 1:\n            if \"#\" in line:\n                break\n            grads.append(float(line.strip()))\n    try:\n        n = len(grads)\n    except:\n        return None, None\n\n    if n == 0:\n        return None, None\n\n    if n % 3 != 0:\n        print(\"what?\")\n        return None, None\n\n    n = int(n / 3)\n    force = -np.array(grads)  # F = -g\n    force = np.reshape(force, (n, 3))\n    return energy, force\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.parse_hessian","title":"parse_hessian","text":"<pre><code>parse_hessian(directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def parse_hessian(directory):  # Read {file_name}.hess\n    target_line = 0\n    # Find $hessian\n    try:\n        with open(directory, \"r\") as f:\n            lines = f.readlines()\n            for idx, line in enumerate(lines):\n                if \"$hessian\" in line:\n                    index = idx\n                    index += 1\n                    break\n    except:\n        return None\n    n = int(lines[index])\n    index += 1\n    hessian = np.zeros((n, n))\n    cnt = 0\n    while cnt &lt; n:\n        index_infos = lines[index].strip().split()\n        index += 1\n        for i in range(n):\n            values = lines[index].strip().split()\n            index += 1\n            for j, index_info in enumerate(index_infos):\n                index_info = int(index_info)\n                hessian[i][index_info] = float(values[j + 1])\n        cnt += len(index_infos)\n        # print (cnt)\n    return hessian\n</code></pre>"},{"location":"reference/himatcal/calculator/orca_mcd.html#himatcal.calculator.orca_mcd.parse_opt","title":"parse_opt","text":"<pre><code>parse_opt(directory)\n</code></pre> Source code in <code>himatcal/calculator/orca_mcd.py</code> <pre><code>def parse_opt(directory):  # Read {file_name}.trj.xyz\n    # Open ORCA output file and read its contents\n    try:\n        with open(directory) as f:\n            lines = f.readlines()\n    except:\n        return []\n\n    trajectory = []\n    index = 0\n    while index &lt; len(lines):\n        num_atom = int(lines[index].strip())  # read num_atom\n        index += 1\n        infos = lines[index].strip().split()  # Read energy\n        energy = float(infos[-1])\n        index += 1\n        atom_list = []\n        for i in range(num_atom):\n            atom_info = lines[index].strip().split()\n            index += 1\n            element = atom_info[0]\n            x = float(atom_info[1])\n            y = float(atom_info[2])\n            z = float(atom_info[3])\n            atom = chem.Atom(element)\n            atom.x = x\n            atom.y = y\n            atom.z = z\n            atom_list.append(atom)\n        if len(atom_list) &gt; 0:\n            molecule = chem.Molecule()\n            molecule.atom_list = atom_list\n            molecule.energy = energy\n            trajectory.append(molecule)\n        else:\n            break\n    return trajectory\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html","title":"pyscf_calculator","text":"<p>ASE pySCF calcuator, from scm</p>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.atoms","title":"atoms  <code>module-attribute</code>","text":"<pre><code>atoms = molecule('H2O')\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator","title":"PySCFCalculator","text":"<pre><code>PySCFCalculator(xc: str = 'pbe', basis: str = '631g*', symmetry: bool = True, **kwargs)\n</code></pre> <p>               Bases: <code>Calculator</code></p> <p>Example DFT calculator for PySCF. Only some minimal options are supported.</p> Source code in <code>himatcal/calculator/pyscf_calculator.py</code> <pre><code>def __init__(\n    self,\n    xc: str = \"pbe\",  # https://pyscf.org/_modules/pyscf/dft/xcfun.html\n    basis: str = \"631g*\",  # https://pyscf.org/_modules/pyscf/gto/basis.html\n    symmetry: bool = True,\n    **kwargs,\n):\n    super().__init__(**kwargs)\n    self.xc = xc\n    self.basis = basis\n    self.symmetry = symmetry\n    self.M = pyscf.M()\n    self.dm1 = None  # density matrix\n    self.ams_capabilities: Any = None\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.M","title":"M  <code>instance-attribute</code>","text":"<pre><code>M = M()\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.ams_capabilities","title":"ams_capabilities  <code>instance-attribute</code>","text":"<pre><code>ams_capabilities: Any = None\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.basis","title":"basis  <code>instance-attribute</code>","text":"<pre><code>basis = basis\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.dm1","title":"dm1  <code>instance-attribute</code>","text":"<pre><code>dm1 = None\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.implemented_properties","title":"implemented_properties  <code>class-attribute</code>","text":"<pre><code>implemented_properties: list[str] = ['energy', 'forces', 'dipole', 'charges']\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.symmetry","title":"symmetry  <code>instance-attribute</code>","text":"<pre><code>symmetry = symmetry\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.xc","title":"xc  <code>instance-attribute</code>","text":"<pre><code>xc = xc\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.atoms2pyscf","title":"atoms2pyscf  <code>staticmethod</code>","text":"<pre><code>atoms2pyscf(atoms: Atoms) -&gt; list[tuple[str, tuple[float, float, float]]]\n</code></pre> <p>Convert ASE Atoms to the list of symbols and coordinates required by pySCF</p> Source code in <code>himatcal/calculator/pyscf_calculator.py</code> <pre><code>@staticmethod\ndef atoms2pyscf(atoms: ase.Atoms) -&gt; list[tuple[str, tuple[float, float, float]]]:\n    \"\"\"Convert ASE Atoms to the list of symbols and coordinates required by pySCF\"\"\"\n    return [\n        (symbol, (xyz[0], xyz[1], xyz[2]))\n        for symbol, xyz in zip(atoms.get_chemical_symbols(), atoms.get_positions())\n    ]\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.PySCFCalculator.calculate","title":"calculate","text":"<pre><code>calculate(atoms=None, properties=None, system_changes=None) -&gt; None\n</code></pre> <p>Perform DFT calculation, populate self.results with energy, forces, dipole, charge</p> Source code in <code>himatcal/calculator/pyscf_calculator.py</code> <pre><code>def calculate(self, atoms=None, properties=None, system_changes=None) -&gt; None:\n    \"\"\"Perform DFT calculation, populate self.results with energy, forces, dipole, charge\"\"\"\n    Calculator.calculate(\n        self, atoms=atoms, properties=properties, system_changes=system_changes\n    )\n    self.results = {}\n    if atoms is None:\n        return\n\n    pyscf_atoms = self.atoms2pyscf(atoms)\n    pyscf_mol = pyscf.M(\n        atom=pyscf_atoms,\n        basis=self.basis,\n        symmetry=self.symmetry,\n    )\n\n    self.mf = pyscf.dft.RKS(pyscf_mol)\n    self.mf.xc = self.xc\n\n    self.mf.kernel(verbose=0, dm0=self.dm1)\n    self.dm1 = (\n        self.mf.make_rdm1()\n    )  # try to reuse density matrix for next calculation\n\n    self.mf.analyze(verbose=0)\n    _, charges = self.mf.mulliken_pop(verbose=0)\n\n    self.results = {\"energy\": self.mf.energy_tot() * ase.units.Hartree}\n    self.results[\"forces\"] = (\n        -np.array(self.mf.Gradients().kernel()) * ase.units.Hartree / ase.units.Bohr\n    )\n    self.results[\"dipole\"] = (\n        self.mf.dip_moment(verbose=0, unit=\"atomic\") * ase.units.Bohr\n    )\n    self.results[\"charges\"] = np.array(charges)\n</code></pre>"},{"location":"reference/himatcal/calculator/pyscf_calculator.html#himatcal.calculator.pyscf_calculator.get_calculator","title":"get_calculator","text":"<pre><code>get_calculator(**kwargs) -&gt; PySCFCalculator\n</code></pre> <p>Function used by the AMS-ASE interface</p> Source code in <code>himatcal/calculator/pyscf_calculator.py</code> <pre><code>def get_calculator(**kwargs) -&gt; PySCFCalculator:\n    \"\"\"Function used by the AMS-ASE interface\"\"\"\n    from scm.amspipe import AMSExternalCapabilities\n\n    calc = PySCFCalculator(**kwargs)\n    calc.ams_capabilities = AMSExternalCapabilities()\n    calc.ams_capabilities.apply_implemented_properties(calc.implemented_properties)\n    return calc\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html","title":"aimnet2ase","text":"<p>https://github.com/isayevlab/AIMNet2/blob/main/aimnet2calc/aimnet2ase.py</p>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE","title":"AIMNet2ASE","text":"<pre><code>AIMNet2ASE(base_calc: AIMNet2Calculator | str = 'aimnet2', charge=0, mult=1)\n</code></pre> <p>               Bases: <code>Calculator</code></p> Source code in <code>himatcal/calculator/aimnet/aimnet2ase.py</code> <pre><code>def __init__(\n    self, base_calc: AIMNet2Calculator | str = \"aimnet2\", charge=0, mult=1\n):\n    super().__init__()\n    if isinstance(base_calc, str):\n        base_calc = AIMNet2Calculator(base_calc)\n    self.base_calc = base_calc\n    self.charge = charge\n    self.mult = mult\n    self.reset()\n    # list of implemented species\n    if hasattr(base_calc, \"implemented_species\"):\n        self.implemented_species = base_calc.implemented_species.cpu().numpy()\n    else:\n        self.implemented_species = None\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.base_calc","title":"base_calc  <code>instance-attribute</code>","text":"<pre><code>base_calc = base_calc\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.charge","title":"charge  <code>instance-attribute</code>","text":"<pre><code>charge = charge\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.implemented_properties","title":"implemented_properties  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implemented_properties = ['energy', 'forces', 'free_energy', 'charges', 'stress']\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.implemented_species","title":"implemented_species  <code>instance-attribute</code>","text":"<pre><code>implemented_species = numpy()\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.mult","title":"mult  <code>instance-attribute</code>","text":"<pre><code>mult = mult\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.calculate","title":"calculate","text":"<pre><code>calculate(atoms=None, properties=None, system_changes=all_changes)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2ase.py</code> <pre><code>def calculate(self, atoms=None, properties=None, system_changes=all_changes):\n    if properties is None:\n        properties = [\"energy\"]\n    super().calculate(atoms, properties, system_changes)\n    self.update_tensors()\n\n    if self.atoms.cell is not None and self.atoms.pbc.any():\n        # assert self.base_calc.cutoff_lr &lt; float('inf'), 'Long-range cutoff must be finite for PBC'\n        cell = self.atoms.cell.array\n    else:\n        cell = None\n\n    results = self.base_calc(\n        {\n            \"coord\": torch.tensor(\n                self.atoms.positions,\n                dtype=torch.float32,\n                device=self.base_calc.device,\n            ),\n            \"numbers\": self._t_numbers,\n            \"cell\": cell,\n            \"mol_idx\": self._t_mol_idx,\n            \"charge\": self._t_charge,\n            \"mult\": self._t_mult,\n        },\n        forces=\"forces\" in properties,\n        stress=\"stress\" in properties,\n    )\n    for k, v in results.items():\n        results[k] = v.detach().cpu().numpy()\n\n    self.results[\"energy\"] = results[\"energy\"][0]\n    self.results[\"charges\"] = results[\"charges\"]\n    if \"forces\" in properties:\n        self.results[\"forces\"] = results[\"forces\"]\n    if \"stress\" in properties:\n        self.results[\"stress\"] = results[\"stress\"]\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2ase.py</code> <pre><code>def reset(self):\n    super().reset()\n    self._t_numbers = None\n    self._t_charge = None\n    self._t_mult = None\n    self._t_mol_idx = None\n    self.charge = 0.0\n    self.mult = 1.0\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.set_atoms","title":"set_atoms","text":"<pre><code>set_atoms(atoms)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2ase.py</code> <pre><code>def set_atoms(self, atoms):\n    if (\n        self.implemented_species is not None\n        and not np.isin(atoms.numbers, self.implemented_species).all()\n    ):\n        raise ValueError(\n            \"Some species are not implemented in the AIMNet2Calculator\"\n        )\n    self.reset()\n    self.atoms = atoms\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.set_charge","title":"set_charge","text":"<pre><code>set_charge(charge)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2ase.py</code> <pre><code>def set_charge(self, charge):\n    self.charge = charge\n    self._t_charge = None\n    self.update_tensors()\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.set_mult","title":"set_mult","text":"<pre><code>set_mult(mult)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2ase.py</code> <pre><code>def set_mult(self, mult):\n    self.mult = mult\n    self._t_mult = None\n    self.update_tensors()\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2ase.html#himatcal.calculator.aimnet.aimnet2ase.AIMNet2ASE.update_tensors","title":"update_tensors","text":"<pre><code>update_tensors()\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2ase.py</code> <pre><code>def update_tensors(self):\n    if self._t_numbers is None:\n        self._t_numbers = torch.tensor(\n            self.atoms.numbers, dtype=torch.int64, device=self.base_calc.device\n        )\n    if self._t_charge is None:\n        self._t_charge = torch.tensor(\n            self.charge, dtype=torch.float32, device=self.base_calc.device\n        )\n    if self._t_mult is None:\n        self._t_mult = torch.tensor(\n            self.mult, dtype=torch.float32, device=self.base_calc.device\n        )\n    if self._t_mol_idx is None:\n        self.mol_idx = torch.zeros(\n            len(self.atoms), dtype=torch.int64, device=self.base_calc.device\n        )\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html","title":"aimnet2pysis","text":""},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.EV2AU","title":"EV2AU  <code>module-attribute</code>","text":"<pre><code>EV2AU = 1 / AU2EV\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis","title":"AIMNet2Pysis","text":"<pre><code>AIMNet2Pysis(model: Union[AIMNet2Calculator, str] = 'aimnet2', charge=0, mult=1, **kwargs)\n</code></pre> <p>               Bases: <code>Calculator</code></p> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>def __init__(\n    self,\n    model: Union[AIMNet2Calculator, str] = \"aimnet2\",\n    charge=0,\n    mult=1,\n    **kwargs,\n):\n    super().__init__(charge=charge, mult=mult, **kwargs)\n    if isinstance(model, str):\n        model = AIMNet2Calculator(model)\n    self.model = model\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis.implemented_properties","title":"implemented_properties  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implemented_properties = ['energy', 'forces', 'free_energy', 'charges', 'stress']\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = model\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis._prepere_input","title":"_prepere_input","text":"<pre><code>_prepere_input(atoms, coord)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>def _prepere_input(self, atoms, coord):\n    device = self.model.device\n    numbers = torch.as_tensor(\n        [ATOMIC_NUMBERS[a.lower()] for a in atoms], device=device\n    )\n    coord = (\n        torch.as_tensor(coord, dtype=torch.float, device=device).view(-1, 3)\n        * BOHR2ANG\n    )\n    charge = torch.as_tensor([self.charge], dtype=torch.float, device=device)\n    mult = torch.as_tensor([self.mult], dtype=torch.float, device=device)\n    return dict(coord=coord, numbers=numbers, charge=charge, mult=mult)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis._results_get_energy","title":"_results_get_energy  <code>staticmethod</code>","text":"<pre><code>_results_get_energy(results)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>@staticmethod\ndef _results_get_energy(results):\n    return results[\"energy\"].item() * EV2AU\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis._results_get_forces","title":"_results_get_forces  <code>staticmethod</code>","text":"<pre><code>_results_get_forces(results)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>@staticmethod\ndef _results_get_forces(results):\n    return (\n        (results[\"forces\"].detach() * (EV2AU / ANG2BOHR))\n        .flatten()\n        .to(torch.double)\n        .cpu()\n        .numpy()\n    )\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis._results_get_hessian","title":"_results_get_hessian  <code>staticmethod</code>","text":"<pre><code>_results_get_hessian(results)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>@staticmethod\ndef _results_get_hessian(results):\n    return (\n        (\n            results[\"hessian\"].flatten(0, 1).flatten(-2, -1)\n            * (EV2AU / ANG2BOHR / ANG2BOHR)\n        )\n        .to(torch.double)\n        .cpu()\n        .numpy()\n    )\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis.get_energy","title":"get_energy","text":"<pre><code>get_energy(atoms, coords)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>def get_energy(self, atoms, coords):\n    _in = self._prepere_input(atoms, coords)\n    res = self.model(_in)\n    energy = self._results_get_energy(res)\n    return dict(energy=energy)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis.get_forces","title":"get_forces","text":"<pre><code>get_forces(atoms, coords)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>def get_forces(self, atoms, coords):\n    _in = self._prepere_input(atoms, coords)\n    res = self.model(_in, forces=True)\n    energy = self._results_get_energy(res)\n    forces = self._results_get_forces(res)\n    return dict(energy=energy, forces=forces)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.AIMNet2Pysis.get_hessian","title":"get_hessian","text":"<pre><code>get_hessian(atoms, coords)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>def get_hessian(self, atoms, coords):\n    _in = self._prepere_input(atoms, coords)\n    res = self.model(_in, forces=True, hessian=True)\n    energy = self._results_get_energy(res)\n    forces = self._results_get_forces(res)\n    hessian = self._results_get_hessian(res)\n    return dict(energy=energy, forces=forces, hessian=hessian)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/aimnet2pysis.html#himatcal.calculator.aimnet.aimnet2pysis.run_pysis","title":"run_pysis","text":"<pre><code>run_pysis()\n</code></pre> Source code in <code>himatcal/calculator/aimnet/aimnet2pysis.py</code> <pre><code>def run_pysis():\n    from pysisyphus import run\n\n    run.CALC_DICT[\"aimnet\"] = AIMNet2Pysis\n    run.run()\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html","title":"core","text":""},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator","title":"AIMNet2Calculator","text":"<pre><code>AIMNet2Calculator(model: str | Module = 'aimnet2')\n</code></pre> <p>Genegic AIMNet2 calculator A helper class to load AIMNet2 models and perform inference.</p> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def __init__(self, model: str | torch.nn.Module = \"aimnet2\"):\n    self.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    if isinstance(model, str):\n        p = get_model_path(model)\n        self.model = torch.jit.load(p, map_location=self.device)\n    elif isinstance(model, nn.Module):\n        self.model = model.to(self.device)\n    else:\n        raise AttributeError(\"Invalid model type/name.\")\n\n    self.cutoff = self.model.cutoff\n    self.lr = hasattr(self.model, \"cutoff_lr\")\n    self.cutoff_lr = getattr(self.model, \"cutoff_lr\", float(\"inf\"))\n\n    # indicator if input was flattened\n    self._batch = None\n    # placeholder for tensors that require grad\n    self._saved_for_grad = None\n    # set flag of current Coulomb model\n    coul_methods = {\n        getattr(mod, \"method\", None) for mod in iter_lrcoulomb_mods(self.model)\n    }\n    assert len(coul_methods) &lt;= 1, \"Multiple Coulomb modules found.\"\n    self._coulomb_method = coul_methods.pop() if len(coul_methods) else None\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator._batch","title":"_batch  <code>instance-attribute</code>","text":"<pre><code>_batch = None\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator._coulomb_method","title":"_coulomb_method  <code>instance-attribute</code>","text":"<pre><code>_coulomb_method = pop() if len(coul_methods) else None\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator._saved_for_grad","title":"_saved_for_grad  <code>instance-attribute</code>","text":"<pre><code>_saved_for_grad = None\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.atom_feature_keys","title":"atom_feature_keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>atom_feature_keys = ['coord', 'numbers', 'charges', 'forces']\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.cutoff","title":"cutoff  <code>instance-attribute</code>","text":"<pre><code>cutoff = cutoff\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.cutoff_lr","title":"cutoff_lr  <code>instance-attribute</code>","text":"<pre><code>cutoff_lr = getattr(model, 'cutoff_lr', float('inf'))\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.device","title":"device  <code>instance-attribute</code>","text":"<pre><code>device = 'cuda' if is_available() else 'cpu'\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.keys_in","title":"keys_in  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys_in = {'coord': float, 'numbers': int, 'charge': float}\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.keys_in_optional","title":"keys_in_optional  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys_in_optional = {'mult': float, 'mol_idx': int, 'nbmat': int, 'nbmat_lr': int, 'nb_pad_mask': bool, 'nb_pad_mask_lr': bool, 'shifts': float, 'shifts_lr': float, 'cell': float}\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.keys_out","title":"keys_out  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys_out = ['energy', 'charges', 'forces', 'hessian', 'stress']\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.lr","title":"lr  <code>instance-attribute</code>","text":"<pre><code>lr = hasattr(model, 'cutoff_lr')\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model = load(p, map_location=device)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    return self.eval(*args, **kwargs)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.calculate_hessian","title":"calculate_hessian  <code>staticmethod</code>","text":"<pre><code>calculate_hessian(forces, coord)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>@staticmethod\ndef calculate_hessian(forces, coord):\n    # here forces have shape (N, 3) and coord has shape (N+1, 3)\n    # return hessian with shape (N, 3, N, 3)\n    hessian = -torch.stack(\n        [\n            torch.autograd.grad(_f, coord, retain_graph=True)[0]\n            for _f in forces.flatten().unbind()\n        ]\n    ).view(-1, 3, coord.shape[0], 3)[:-1, :, :-1, :]\n    return hessian\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.eval","title":"eval","text":"<pre><code>eval(data: dict[str, Any], forces=False, stress=False, hessian=False) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def eval(\n    self, data: dict[str, Any], forces=False, stress=False, hessian=False\n) -&gt; dict[str, Tensor]:\n    data = self.prepare_input(data)\n    if hessian and data[\"mol_idx\"][-1] &gt; 0:\n        raise NotImplementedError(\n            \"Hessian calculation is not supported for multiple molecules\"\n        )\n    data = self.set_grad_tensors(\n        data, forces=forces, stress=stress, hessian=hessian\n    )\n    with torch.jit.optimized_execution(False):\n        data = self.model(data)\n    data = self.get_derivatives(data, forces=forces, stress=stress, hessian=hessian)\n    data = self.process_output(data)\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.get_derivatives","title":"get_derivatives","text":"<pre><code>get_derivatives(data: dict[str, Tensor], forces=False, stress=False, hessian=False) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def get_derivatives(\n    self, data: dict[str, Tensor], forces=False, stress=False, hessian=False\n) -&gt; dict[str, Tensor]:\n    training = getattr(self.model, \"training\", False)\n    _create_graph = hessian or training\n    x = []\n    if hessian:\n        forces = True\n    if forces and (\n        \"forces\" not in data or (_create_graph and not data[\"forces\"].requires_grad)\n    ):\n        forces = True\n        x.append(self._saved_for_grad[\"coord\"])\n    if stress:\n        x.append(self._saved_for_grad[\"scaling\"])\n    if x:\n        tot_energy = data[\"energy\"].sum()\n        deriv = torch.autograd.grad(tot_energy, x, create_graph=_create_graph)\n        if forces:\n            data[\"forces\"] = -deriv[0]\n        if stress:\n            dedc = deriv[1] if forces else deriv[0]\n            data[\"stress\"] = dedc / data[\"cell\"].detach().det().abs()\n    if hessian:\n        data[\"hessian\"] = self.calculate_hessian(\n            data[\"forces\"], self._saved_for_grad[\"coord\"]\n        )\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.keep_only","title":"keep_only","text":"<pre><code>keep_only(data: dict[str, Tensor]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def keep_only(self, data: dict[str, Tensor]) -&gt; dict[str, Tensor]:\n    ret = {}\n    for k, v in data.items():\n        if k in self.keys_out or (k.endswith(\"_std\") and k[:-4] in self.keys_out):\n            ret[k] = v\n    return ret\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.make_nbmat","title":"make_nbmat","text":"<pre><code>make_nbmat(data: dict[str, Tensor]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def make_nbmat(self, data: dict[str, Tensor]) -&gt; dict[str, Tensor]:\n    if \"cell\" in data and data[\"cell\"] is not None:\n        assert data[\"cell\"].ndim == 2, \"Expected 2D tensor for cell\"\n        if \"nbmat\" not in data:\n            data[\"coord\"] = move_coord_to_cell(data[\"coord\"], data[\"cell\"])\n            mat_idxj, mat_pad, mat_S = nblists_torch_pbc(\n                data[\"coord\"], data[\"cell\"], self.cutoff\n            )\n            data[\"nbmat\"], data[\"nb_pad_mask\"], data[\"shifts\"] = (\n                mat_idxj,\n                mat_pad,\n                mat_S,\n            )\n            if self.lr:\n                if \"nbmat_lr\" not in data:\n                    assert (\n                        self.cutoff_lr &lt; torch.inf\n                    ), \"Long-range cutoff must be finite for PBC\"\n                    data[\"nbmat_lr\"], data[\"nb_pad_mask_lr\"], data[\"shifts_lr\"] = (\n                        nblists_torch_pbc(\n                            data[\"coord\"], data[\"cell\"], self.cutoff_lr\n                        )\n                    )\n                    data[\"cutoff_lr\"] = torch.tensor(\n                        self.cutoff_lr, device=self.device\n                    )\n    else:\n        if \"nbmat\" not in data:\n            data[\"nbmat\"] = nblist_torch_cluster(\n                data[\"coord\"], self.cutoff, data[\"mol_idx\"], max_nb=128\n            )\n            if self.lr:\n                if \"nbmat_lr\" not in data:\n                    data[\"nbmat_lr\"] = nblist_torch_cluster(\n                        data[\"coord\"], self.cutoff_lr, data[\"mol_idx\"], max_nb=1024\n                    )\n                data[\"cutoff_lr\"] = torch.tensor(self.cutoff_lr, device=self.device)\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.mol_flatten","title":"mol_flatten","text":"<pre><code>mol_flatten(data: dict[str, Tensor]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def mol_flatten(self, data: dict[str, Tensor]) -&gt; dict[str, Tensor]:\n    assert data[\"coord\"].ndim in {2, 3}, \"Expected 2D or 3D tensor for coord\"\n    if data[\"coord\"].ndim == 3:\n        B, N = data[\"coord\"].shape[:2]\n        self._batch = B\n        data[\"mol_idx\"] = torch.repeat_interleave(\n            torch.arange(0, B, device=self.device),\n            torch.full((B,), N, device=self.device),\n        )\n        for k, v in data.items():\n            if k in self.atom_feature_keys:\n                assert (\n                    v.ndim &gt;= 2\n                ), f\"Expected at least 2D tensor for {k}, got {v.ndim}D\"\n                data[k] = v.flatten(0, 1)\n    else:\n        self._batch = None\n        if \"mol_idx\" not in data:\n            data[\"mol_idx\"] = torch.zeros(\n                data[\"coord\"].shape[0], device=self.device\n            )\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.mol_unflatten","title":"mol_unflatten","text":"<pre><code>mol_unflatten(data: dict[str, Tensor], batch=None) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def mol_unflatten(self, data: dict[str, Tensor], batch=None) -&gt; dict[str, Tensor]:\n    batch = batch or self._batch\n    if batch is not None:\n        for k, v in data.items():\n            if k in self.atom_feature_keys:\n                data[k] = v.view(self._batch, -1, *v.shape[1:])\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.pad_input","title":"pad_input","text":"<pre><code>pad_input(data: dict[str, Tensor]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def pad_input(self, data: dict[str, Tensor]) -&gt; dict[str, Tensor]:\n    N = data[\"nbmat\"].shape[0]\n    data[\"coord\"] = maybe_pad_dim0(data[\"coord\"], N)\n    data[\"numbers\"] = maybe_pad_dim0(data[\"numbers\"], N)\n    data[\"mol_idx\"] = maybe_pad_dim0(data[\"mol_idx\"], N, value=data[\"mol_idx\"][-1])\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.prepare_input","title":"prepare_input","text":"<pre><code>prepare_input(data: dict[str, Any]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def prepare_input(self, data: dict[str, Any]) -&gt; dict[str, Tensor]:\n    data = self.to_input_tensors(data)\n    data = self.mol_flatten(data)\n    if data.get(\"cell\") is not None:\n        if data[\"mol_idx\"][-1] &gt; 0:\n            raise NotImplementedError(\n                \"PBC with multiple molecules is not implemented yet.\"\n            )\n        if self._coulomb_method == \"simple\":\n            print(\"Switching to DSF Coulomb for PBC\")\n            self.set_lrcoulomb_method(\"dsf\")\n    data = self.make_nbmat(data)\n    data = self.pad_input(data)\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.process_output","title":"process_output","text":"<pre><code>process_output(data: dict[str, Tensor]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def process_output(self, data: dict[str, Tensor]) -&gt; dict[str, Tensor]:\n    data = self.unpad_output(data)\n    data = self.mol_unflatten(data)\n    data = self.keep_only(data)\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.set_grad_tensors","title":"set_grad_tensors","text":"<pre><code>set_grad_tensors(data: dict[str, Tensor], forces=False, stress=False, hessian=False) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def set_grad_tensors(\n    self, data: dict[str, Tensor], forces=False, stress=False, hessian=False\n) -&gt; dict[str, Tensor]:\n    self._saved_for_grad = {}\n    if forces or hessian:\n        data[\"coord\"].requires_grad_(True)\n        self._saved_for_grad[\"coord\"] = data[\"coord\"]\n    if stress:\n        assert \"cell\" in data, \"Stress calculation requires cell\"\n        scaling = torch.eye(\n            3,\n            requires_grad=True,\n            dtype=data[\"cell\"].dtype,\n            device=data[\"cell\"].device,\n        )\n        data[\"coord\"] = data[\"coord\"] @ scaling\n        data[\"cell\"] = data[\"cell\"] @ scaling\n        self._saved_for_grad[\"scaling\"] = scaling\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.set_lrcoulomb_method","title":"set_lrcoulomb_method","text":"<pre><code>set_lrcoulomb_method(method, cutoff=15.0, dsf_alpha=0.2)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def set_lrcoulomb_method(self, method, cutoff=15.0, dsf_alpha=0.2):\n    assert method in (\"simple\", \"dsf\", \"ewald\"), f\"Invalid method: {method}\"\n    if method == \"simple\":\n        for mod in iter_lrcoulomb_mods(self.model):\n            mod.method = \"simple\"\n            self.cutoff_lr = float(\"inf\")\n    elif method == \"dsf\":\n        for mod in iter_lrcoulomb_mods(self.model):\n            mod.method = \"dsf\"\n            self.cutoff_lr = cutoff\n            mod.dsf_alpha = dsf_alpha\n    elif method == \"ewald\":\n        for mod in iter_lrcoulomb_mods(self.model):\n            mod.method = \"ewald\"\n            self.cutoff_lr = cutoff\n    self._coulomb_method = method\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.to_input_tensors","title":"to_input_tensors","text":"<pre><code>to_input_tensors(data: dict[str, Any]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def to_input_tensors(self, data: dict[str, Any]) -&gt; dict[str, Tensor]:\n    ret = dict()\n    for k in self.keys_in:\n        assert k in data, f\"Missing key {k} in the input data\"\n        # always detach !!\n        ret[k] = torch.as_tensor(\n            data[k], device=self.device, dtype=self.keys_in[k]\n        ).detach()\n    for k in self.keys_in_optional:\n        if k in data and data[k] is not None:\n            ret[k] = torch.as_tensor(\n                data[k], device=self.device, dtype=self.keys_in_optional[k]\n            ).detach()\n    # convert any scalar tensors to shape (1,) tensors\n    for k, v in ret.items():\n        if v.ndim == 0:\n            ret[k] = v.unsqueeze(0)\n    return ret\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.AIMNet2Calculator.unpad_output","title":"unpad_output","text":"<pre><code>unpad_output(data: dict[str, Tensor]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def unpad_output(self, data: dict[str, Tensor]) -&gt; dict[str, Tensor]:\n    N = data[\"nbmat\"].shape[0] - 1\n    for k, v in data.items():\n        if k in self.atom_feature_keys:\n            data[k] = maybe_unpad_dim0(v, N)\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core._named_children_rec","title":"_named_children_rec","text":"<pre><code>_named_children_rec(module)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def _named_children_rec(module):\n    if isinstance(module, torch.nn.Module):\n        for name, module in module.named_children():\n            yield name, module\n            yield from _named_children_rec(module)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.iter_lrcoulomb_mods","title":"iter_lrcoulomb_mods","text":"<pre><code>iter_lrcoulomb_mods(model)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def iter_lrcoulomb_mods(model):\n    for name, module in _named_children_rec(model):\n        if name == \"lrcoulomb\":\n            yield module\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.maybe_pad_dim0","title":"maybe_pad_dim0","text":"<pre><code>maybe_pad_dim0(a: Tensor, N: int, value=0.0) -&gt; Tensor\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def maybe_pad_dim0(a: Tensor, N: int, value=0.0) -&gt; Tensor:\n    _shape_diff = N - a.shape[0]\n    assert _shape_diff in [0, 1], \"Invalid shape\"\n    if _shape_diff == 1:\n        a = pad_dim0(a, value=value)\n    return a\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.maybe_unpad_dim0","title":"maybe_unpad_dim0","text":"<pre><code>maybe_unpad_dim0(a: Tensor, N: int) -&gt; Tensor\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def maybe_unpad_dim0(a: Tensor, N: int) -&gt; Tensor:\n    _shape_diff = a.shape[0] - N\n    assert _shape_diff in [0, 1], \"Invalid shape\"\n    if _shape_diff == 1:\n        a = a[:-1]\n    return a\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.move_coord_to_cell","title":"move_coord_to_cell","text":"<pre><code>move_coord_to_cell(coord, cell)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def move_coord_to_cell(coord, cell):\n    coord_f = coord @ cell.inverse()\n    coord_f = coord_f % 1\n    return coord_f @ cell\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/core.html#himatcal.calculator.aimnet.core.pad_dim0","title":"pad_dim0","text":"<pre><code>pad_dim0(a: Tensor, value=0.0) -&gt; Tensor\n</code></pre> Source code in <code>himatcal/calculator/aimnet/core.py</code> <pre><code>def pad_dim0(a: Tensor, value=0.0) -&gt; Tensor:\n    shapes = [0] * ((a.ndim - 1) * 2) + [0, 1]\n    a = torch.nn.functional.pad(a, shapes, mode=\"constant\", value=value)\n    return a\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html","title":"ensemble","text":""},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.args","title":"args  <code>module-attribute</code>","text":"<pre><code>args = parse_args()\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.ens","title":"ens  <code>module-attribute</code>","text":"<pre><code>ens = EnsembledModel(models, out=out_keys, detach=detach)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.models","title":"models  <code>module-attribute</code>","text":"<pre><code>models = [load(m, map_location='cpu') for m in models]\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.parser","title":"parser  <code>module-attribute</code>","text":"<pre><code>parser = ArgumentParser()\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.EnsembledModel","title":"EnsembledModel","text":"<pre><code>EnsembledModel(models: List[Module], out=['energy', 'forces', 'charges'], detach=False)\n</code></pre> <p>               Bases: <code>Module</code></p> Source code in <code>himatcal/calculator/aimnet/ensemble.py</code> <pre><code>def __init__(\n    self, models: List[nn.Module], out=[\"energy\", \"forces\", \"charges\"], detach=False\n):\n    super().__init__()\n    self.models = nn.ModuleList(models)\n    self.out = out\n    self.detach = detach\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.EnsembledModel.detach","title":"detach  <code>instance-attribute</code>","text":"<pre><code>detach = detach\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.EnsembledModel.models","title":"models  <code>instance-attribute</code>","text":"<pre><code>models = ModuleList(models)\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.EnsembledModel.out","title":"out  <code>instance-attribute</code>","text":"<pre><code>out = out\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.EnsembledModel.forward","title":"forward","text":"<pre><code>forward(data: dict[str, Tensor]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/ensemble.py</code> <pre><code>def forward(self, data: dict[str, Tensor]) -&gt; dict[str, Tensor]:\n    res: List[dict[str, Tensor]] = []\n    for model in self.models:\n        _in = dict()\n        for k in data:\n            _in[k] = data[k]\n        _out = model(_in)\n        _r = dict()\n        for k in _out:\n            if k in self.out:\n                _r[k] = _out[k]\n                if self.detach:\n                    _r[k] = _r[k].detach()\n        res.append(_r)\n\n    for k in res[0]:\n        v = [x[k] for x in res]\n        vv = torch.stack(v, dim=0)\n        data[k] = vv.mean(dim=0)\n        data[f\"{k}_std\"] = vv.std(dim=0)\n\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.Forces","title":"Forces","text":"<pre><code>Forces(module: Module, x: str = 'coord', y: str = 'energy', key_out: str = 'forces', detach: bool = True)\n</code></pre> <p>               Bases: <code>Module</code></p> <p>Compute forces from energy using autograd.</p> Source code in <code>himatcal/calculator/aimnet/ensemble.py</code> <pre><code>def __init__(\n    self,\n    module: nn.Module,\n    x: str = \"coord\",\n    y: str = \"energy\",\n    key_out: str = \"forces\",\n    detach: bool = True,\n):\n    super().__init__()\n    self.add_module(\"module\", module)\n    self.x = x\n    self.y = y\n    self.key_out = key_out\n    self.detach = detach\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.Forces.detach","title":"detach  <code>instance-attribute</code>","text":"<pre><code>detach = detach\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.Forces.key_out","title":"key_out  <code>instance-attribute</code>","text":"<pre><code>key_out = key_out\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.Forces.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x = x\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.Forces.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y = y\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/ensemble.html#himatcal.calculator.aimnet.ensemble.Forces.forward","title":"forward","text":"<pre><code>forward(data: dict[str, Tensor]) -&gt; dict[str, Tensor]\n</code></pre> Source code in <code>himatcal/calculator/aimnet/ensemble.py</code> <pre><code>def forward(self, data: dict[str, Tensor]) -&gt; dict[str, Tensor]:\n    prev = torch.is_grad_enabled()\n    torch.set_grad_enabled(True)\n    data[self.x].requires_grad_(True)\n    data = self.module(data)\n    y = data[self.y]\n    create_graph = self.training or not self.detach\n    g = torch.autograd.grad([y.sum()], [data[self.x]], create_graph=create_graph)[0]\n    assert g is not None\n    data[self.key_out] = -g\n    torch.set_grad_enabled(prev)\n    return data\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/models.html","title":"models","text":""},{"location":"reference/himatcal/calculator/aimnet/models.html#himatcal.calculator.aimnet.models.model_registry_aliases","title":"model_registry_aliases  <code>module-attribute</code>","text":"<pre><code>model_registry_aliases = {}\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/models.html#himatcal.calculator.aimnet.models.get_model_path","title":"get_model_path","text":"<pre><code>get_model_path(s: str)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/models.py</code> <pre><code>def get_model_path(s: str):\n    # direct file path\n    if os.path.isfile(s):\n        print(\"Found model file:\", s)\n        return s\n    # check aliases\n    if s in model_registry_aliases:\n        s = model_registry_aliases[s]\n    # add jpt extension\n    if not s.endswith(\".jpt\"):\n        s = s + \".jpt\"\n    sdir = os.path.dirname(s)\n    os.makedirs(os.path.join(os.path.dirname(__file__), \"assets\", sdir), exist_ok=True)\n    s_local = os.path.join(os.path.dirname(__file__), \"assets\", s)\n    if os.path.isfile(s_local):\n        print(\"Found model file:\", s_local)\n    else:\n        url = f\"https://github.com/zubatyuk/aimnet-model-zoo/raw/main/{s}\"\n        print(\"Downloading model file from\", url)\n        r = requests.get(url)\n        r.raise_for_status()\n        with open(s_local, \"wb\") as f:\n            f.write(r.content)\n        print(\"Saved to \", s_local)\n    return s_local\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html","title":"nblist","text":""},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist._numba_cuda_available","title":"_numba_cuda_available  <code>module-attribute</code>","text":"<pre><code>_numba_cuda_available = True\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist._calc_shifts","title":"_calc_shifts","text":"<pre><code>_calc_shifts(inv_distances, cutoff)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/nblist.py</code> <pre><code>def _calc_shifts(inv_distances, cutoff):\n    num_repeats = torch.ceil(cutoff * inv_distances).to(torch.long)\n    dc = [\n        torch.arange(-num_repeats[i], num_repeats[i] + 1, device=inv_distances.device)\n        for i in range(len(num_repeats))\n    ]\n    shifts = torch.cartesian_prod(*dc).to(torch.float)\n    return shifts\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist._cpu_dense_nb_mat_sft","title":"_cpu_dense_nb_mat_sft","text":"<pre><code>_cpu_dense_nb_mat_sft(conn_matrix)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/nblist.py</code> <pre><code>@numba.njit(cache=True, parallel=True)\ndef _cpu_dense_nb_mat_sft(conn_matrix):\n    N, S = conn_matrix.shape[:2]\n    # figure out max number of neighbors\n    _s_flat_conn_matrix = conn_matrix.reshape(N, -1)\n    maxnb = np.max(np.sum(_s_flat_conn_matrix, axis=-1))\n    M = maxnb\n    # atom idx matrix\n    mat_idxj = np.full((N + 1, M), N, dtype=np.int_)\n    # padding matrix\n    mat_pad = np.ones((N + 1, M), dtype=np.bool_)\n    # shitfs matrix\n    mat_S_idx = np.zeros((N + 1, M), dtype=np.int_)\n    for _n in numba.prange(N):\n        _i = 0\n        for _s in range(S):\n            for _m in range(N):\n                if conn_matrix[_n, _s, _m] is True:\n                    mat_idxj[_n, _i] = _m\n                    mat_pad[_n, _i] = False\n                    mat_S_idx[_n, _i] = _s\n                    _i += 1\n    return mat_idxj, mat_pad, mat_S_idx\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist._cuda_dense_nb_mat_sft","title":"_cuda_dense_nb_mat_sft","text":"<pre><code>_cuda_dense_nb_mat_sft(conn_matrix, mat_idxj, mat_pad, mat_S_idx)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/nblist.py</code> <pre><code>@numba.cuda.jit(cache=True)\ndef _cuda_dense_nb_mat_sft(conn_matrix, mat_idxj, mat_pad, mat_S_idx):\n    i = numba.cuda.grid(1)\n    if i &lt; conn_matrix.shape[0]:\n        k = 0\n        for s in range(conn_matrix.shape[1]):\n            for j in range(conn_matrix.shape[2]):\n                if conn_matrix[i, s, j] &gt; 0:\n                    mat_idxj[i, k] = j\n                    mat_pad[i, k] = 0\n                    mat_S_idx[i, k] = s\n                    k += 1\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist._nblist_pbc_cpu","title":"_nblist_pbc_cpu","text":"<pre><code>_nblist_pbc_cpu(conn_mat, shifts, device)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/nblist.py</code> <pre><code>def _nblist_pbc_cpu(conn_mat, shifts, device):\n    conn_mat = conn_mat.cpu().numpy()\n    mat_idxj, mat_pad, mat_S_idx = _cpu_dense_nb_mat_sft(conn_mat)\n    mat_idxj = torch.from_numpy(mat_idxj).to(device)\n    mat_pad = torch.from_numpy(mat_pad).to(device)\n    mat_S_idx = torch.from_numpy(mat_S_idx).to(device)\n    mat_S = shifts[mat_S_idx]\n    return mat_idxj, mat_pad, mat_S\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist._nblist_pbc_cuda","title":"_nblist_pbc_cuda","text":"<pre><code>_nblist_pbc_cuda(conn_mat, shifts)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/nblist.py</code> <pre><code>def _nblist_pbc_cuda(conn_mat, shifts):\n    N = conn_mat.shape[0]\n    M = conn_mat.view(N, -1).sum(-1).max()\n    threadsperblock = 32\n    blockspergrid = (N + (threadsperblock - 1)) // threadsperblock\n    idx_j = torch.full((N + 1, M), N, dtype=torch.int64, device=conn_mat.device)\n    mat_pad = torch.ones((N + 1, M), dtype=torch.int8, device=conn_mat.device)\n    S_idx = torch.zeros((N + 1, M), dtype=torch.int64, device=conn_mat.device)\n    conn_mat = conn_mat.to(torch.int8)\n    _conn_mat = numba.cuda.as_cuda_array(conn_mat)\n    _idx_j = numba.cuda.as_cuda_array(idx_j)\n    _mat_pad = numba.cuda.as_cuda_array(mat_pad)\n    _S_idx = numba.cuda.as_cuda_array(S_idx)\n    _cuda_dense_nb_mat_sft[blockspergrid, threadsperblock](\n        _conn_mat, _idx_j, _mat_pad, _S_idx\n    )\n    mat_pad = mat_pad.to(torch.bool)\n    return idx_j, mat_pad, shifts[S_idx]\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist.nblist_torch_cluster","title":"nblist_torch_cluster","text":"<pre><code>nblist_torch_cluster(coord: Tensor, cutoff: float, mol_idx: Tensor | None = None, max_nb: int = 256)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/nblist.py</code> <pre><code>def nblist_torch_cluster(\n    coord: Tensor, cutoff: float, mol_idx: Tensor | None = None, max_nb: int = 256\n):\n    device = coord.device\n    assert coord.ndim == 2, \"Expected 2D tensor for coord, got {coord.ndim}D\"\n    assert coord.shape[0] &lt; 2147483646, \"Too many atoms, max supported is 2147483646\"\n    max_num_neighbors = max_nb\n    while True:\n        sparse_nb = radius_graph(\n            coord, batch=mol_idx, r=cutoff, max_num_neighbors=max_nb\n        ).to(torch.int32)\n        nnb = torch.unique(sparse_nb[0], return_counts=True)[1]\n        if nnb.numel() == 0:\n            break\n        max_num_neighbors = nnb.max().item()\n        if max_num_neighbors &lt; max_nb:\n            break\n        max_nb *= 2\n    sparse_nb_half = sparse_nb[:, sparse_nb[0] &gt; sparse_nb[1]]\n    dense_nb = sparse_nb_to_dense_half(\n        sparse_nb_half.mT.cpu().numpy(), coord.shape[0], max_num_neighbors\n    )\n    dense_nb = torch.as_tensor(dense_nb, device=device)\n    return dense_nb\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist.nblists_torch_pbc","title":"nblists_torch_pbc","text":"<pre><code>nblists_torch_pbc(coord: Tensor, cell: Tensor, cutoff: float) -&gt; tuple[Tensor, Tensor, Tensor]\n</code></pre> <p>Compute dense neighbor lists for periodic boundary conditions case. Coordinates must be in cartesian coordinates and be within the unit cell. Single crystal only, no support for batched coord or multiple unit cells.</p> Source code in <code>himatcal/calculator/aimnet/nblist.py</code> <pre><code>def nblists_torch_pbc(\n    coord: Tensor, cell: Tensor, cutoff: float\n) -&gt; tuple[Tensor, Tensor, Tensor]:\n    \"\"\"Compute dense neighbor lists for periodic boundary conditions case.\n    Coordinates must be in cartesian coordinates and be within the unit cell.\n    Single crystal only, no support for batched coord or multiple unit cells.\n    \"\"\"\n    assert coord.ndim == 2, \"Expected 2D tensor for coord, got {coord.ndim}D\"\n    # non-PBC version\n    device = coord.device\n\n    reciprocal_cell = cell.inverse().t()\n    inv_distances = reciprocal_cell.norm(2, -1)\n    shifts = _calc_shifts(inv_distances, cutoff)\n    d = torch.cdist(\n        coord.unsqueeze(0), coord.unsqueeze(0) + (shifts @ cell).unsqueeze(1)\n    )\n    conn_mat = ((d &lt; cutoff) &amp; (d &gt; 0.1)).transpose(0, 1).contiguous()\n    if device.type == \"cuda\" and _numba_cuda_available:\n        _fn = _nblist_pbc_cuda\n    else:\n        _fn = _nblist_pbc_cpu\n    mat_idxj, mat_pad, mat_S = _fn(conn_mat, shifts)\n    return mat_idxj, mat_pad, mat_S\n</code></pre>"},{"location":"reference/himatcal/calculator/aimnet/nblist.html#himatcal.calculator.aimnet.nblist.sparse_nb_to_dense_half","title":"sparse_nb_to_dense_half","text":"<pre><code>sparse_nb_to_dense_half(idx, natom, max_nb)\n</code></pre> Source code in <code>himatcal/calculator/aimnet/nblist.py</code> <pre><code>@numba.njit(cache=True)\ndef sparse_nb_to_dense_half(idx, natom, max_nb):\n    dense_nb = np.full((natom + 1, max_nb), natom, dtype=np.int32)\n    last_idx = np.zeros((natom,), dtype=np.int32)\n    for k in range(idx.shape[0]):\n        i, j = idx[k]\n        il, jl = last_idx[i], last_idx[j]\n        dense_nb[i, il] = j\n        dense_nb[j, jl] = i\n        last_idx[i] += 1\n        last_idx[j] += 1\n    return dense_nb\n</code></pre>"},{"location":"reference/himatcal/recipes/crest/_base.html","title":"_base","text":"<p>crest recipes</p>"},{"location":"reference/himatcal/recipes/crest/_base.html#himatcal.recipes.crest._base.write_general_input","title":"write_general_input","text":"<pre><code>write_general_input(input_type: str = 'struc.xyz', runtype: Literal['none', 'ancopt', 'optimize', 'ancopt_ensemble', 'optimize_ensemble', 'md', 'mtd', 'dynamics', 'metadynamics', 'mecp', 'mecp_search'] = 'none', threads: int = 4, preopt: bool = False, topo: bool = 'False')\n</code></pre> Source code in <code>himatcal/recipes/crest/_base.py</code> <pre><code>def write_general_input(\n    input_type: str = \"struc.xyz\",\n    runtype: Literal[\n        \"none\",\n        \"ancopt\",\n        \"optimize\",\n        \"ancopt_ensemble\",\n        \"optimize_ensemble\",\n        \"md\",\n        \"mtd\",\n        \"dynamics\",\n        \"metadynamics\",\n        \"mecp\",\n        \"mecp_search\",\n    ] = \"none\",\n    threads: int = 4,\n    preopt: bool = False,\n    topo: bool = \"False\",\n):\n    with Path.open(Path(\"input.toml\"),\"w\") as f:\n        toml.dump(\n            {\n                \"input\": input_type,\n                \"runtype\": runtype,\n                \"threads\": threads,\n                \"preopt\": preopt,\n                \"topo\": topo,\n                \"calculation\":{\n                    \"type\" : \"mecp\",\n                    \"hess_update\": \"bfgs\",\n                    \"level\":{\n                        \"method\":\"xtb\",\n                    }\n                }\n            },\n            f,\n        )\n</code></pre>"},{"location":"reference/himatcal/recipes/crest/core.html","title":"core","text":"<p>core recipes for crest calculations</p>"},{"location":"reference/himatcal/recipes/crest/core.html#himatcal.recipes.crest.core.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/himatcal/recipes/crest/core.html#himatcal.recipes.crest.core.iMTD_GC","title":"iMTD_GC","text":"<pre><code>iMTD_GC(atoms: Atoms, chg: int = 0, mult: int = 1, gfn_level: Literal['gfn1', 'gfn2', 'gfnff', 'gfn2//gfnff'] = 'gfn2', alpb: str | None = None, topo_change: bool = False, threads: int = 16)\n</code></pre> Source code in <code>himatcal/recipes/crest/core.py</code> <pre><code>def iMTD_GC(\n    atoms: Atoms,\n    chg: int = 0,\n    mult: int = 1,\n    gfn_level: Literal[\"gfn1\", \"gfn2\", \"gfnff\", \"gfn2//gfnff\"] = \"gfn2\",\n    alpb: str | None = None,\n    topo_change: bool = False,\n    threads: int = 16,\n):\n    scratch_folder = Path(f\"crest_opt_{datetime.now(timezone.utc).strftime('%Y-%m-%d-%H-%M-%S-%f')}\")\n    Path.mkdir(scratch_folder)\n    with cd(scratch_folder):\n        atoms_name = \"input.xyz\"\n        write(atoms_name, atoms)\n        uhf = mult - 1\n        if SETTINGS.CREST_EXE_PATH_V3 is None:\n            logger.error(\"CREST_EXE_PATH_V3 is not set in the settings.\")\n            return None\n        protonate_cmd = f\"{SETTINGS.CREST_EXE_PATH_V3} {atoms_name} --{gfn_level} -chrg {chg} -uhf {uhf} --T {threads}\"\n        if alpb:\n            protonate_cmd += f\" -alpb {alpb}\"\n        if topo_change:\n            protonate_cmd += \" --noreftopo\"\n        with Path.open(Path(\"crest_opt.sh\"), \"w\") as f:\n            f.write(f\"#!/bin/bash\\n{protonate_cmd}\")\n        log_file_path = Path(\"crest_opt.log\")\n        with log_file_path.open(\"w\") as log_file:\n            subprocess.run(\n                [\"bash\", \"crest_opt.sh\"],\n                stdout=log_file,\n                stderr=subprocess.STDOUT,\n                check=True,\n            )\n        try:\n            return read(\"crest_best.xyz\")\n        except FileNotFoundError:\n            logger.error(\n                \"The computation did not finish successfully, please check the log file.\"\n            )\n            return None\n</code></pre>"},{"location":"reference/himatcal/recipes/crest/core.html#himatcal.recipes.crest.core.protonate","title":"protonate","text":"<pre><code>protonate(atoms: Atoms, ion: str = 'li+', chg: int = 0, mult: int = 1, gfn_level: Literal['gfn1', 'gfn2', 'gfnff', 'gfn2//gfnff'] = 'gfn2', alpb: str | None = None, threads: int = 16)\n</code></pre> <p>Protonate a structure using CREST, default is to protonate with Li</p> Source code in <code>himatcal/recipes/crest/core.py</code> <pre><code>def protonate(\n    atoms: Atoms,\n    ion: str = \"li+\",\n    chg: int = 0,\n    mult: int = 1,\n    gfn_level: Literal[\"gfn1\", \"gfn2\", \"gfnff\", \"gfn2//gfnff\"] = \"gfn2\",\n    alpb: str | None = None,\n    threads: int = 16,\n):\n    \"\"\"\n    Protonate a structure using CREST, default is to protonate with Li\n    \"\"\"\n    scratch_folder = Path(f\"crest_opt_{datetime.now(timezone.utc).strftime('%Y-%m-%d-%H-%M-%S-%f')}\")\n    Path.mkdir(scratch_folder)\n    with cd(scratch_folder):\n        atoms_name = \"input.xyz\"\n        write(atoms_name, atoms)\n        uhf = mult - 1\n        protonate_cmd = f\"{SETTINGS.CREST_EXE_PATH_V3} {atoms_name} --protonate --swel {ion} --{gfn_level} -chrg {chg} -uhf {uhf} --T {threads}\"\n        if alpb:\n            protonate_cmd += f\" -alpb {alpb}\"\n        with Path.open(Path(\"crest_opt.sh\"), \"w\") as f:\n            f.write(f\"#!/bin/bash\\n{protonate_cmd}\")\n        log_file_path = Path(\"crest_opt.log\")\n        with log_file_path.open(\"w\") as log_file:\n            subprocess.run(\n                [\"bash\", \"crest_opt.sh\"],\n                stdout=log_file,\n                stderr=subprocess.STDOUT,\n                check=True,\n            )\n        try:\n            return read(\"protonated.xyz\", index=0)\n        except FileNotFoundError:\n            logger.error(\n                \"The protonation did not complete successfully, please check the log file.\"\n            )\n            return None\n</code></pre>"},{"location":"reference/himatcal/recipes/crest/core.html#himatcal.recipes.crest.core.relax","title":"relax","text":"<pre><code>relax(atoms: Atoms, chg: int = 0, mult: int = 1, gfn_level: Literal['gfn1', 'gfn2', 'gfnff', 'gfn2//gfnff'] = 'gfn2', alpb: str | None = None, threads: int = 16)\n</code></pre> <p>Relax a molecular system using the CREST optimization program.</p> <p>Args:     atoms: The molecular system to relax.     chg: The charge of the system.     mult: The multiplicity of the system.     gfn_level: The level of the GFN method to use (default is \"gfn2\").     alpb: The solvent model to use (default is \"acetone\").     threads: The number of threads to use for optimization (default is 4).</p> <p>Returns:     The relaxed molecular system.</p> <p>Raises:     FileNotFoundError: If the output file \"crestopt.xyz\" is not found after optimization.</p> Source code in <code>himatcal/recipes/crest/core.py</code> <pre><code>def relax(\n    atoms: Atoms,\n    chg: int = 0,\n    mult: int = 1,\n    gfn_level: Literal[\"gfn1\", \"gfn2\", \"gfnff\", \"gfn2//gfnff\"] = \"gfn2\",\n    alpb: str | None = None,\n    threads: int = 16,\n):\n    \"\"\"\n    Relax a molecular system using the CREST optimization program.\n\n    Args:\n        atoms: The molecular system to relax.\n        chg: The charge of the system.\n        mult: The multiplicity of the system.\n        gfn_level: The level of the GFN method to use (default is \"gfn2\").\n        alpb: The solvent model to use (default is \"acetone\").\n        threads: The number of threads to use for optimization (default is 4).\n\n    Returns:\n        The relaxed molecular system.\n\n    Raises:\n        FileNotFoundError: If the output file \"crestopt.xyz\" is not found after optimization.\n    \"\"\"\n    scratch_folder = Path(f\"crest_opt_{datetime.now(timezone.utc).strftime('%Y-%m-%d-%H-%M-%S-%f')}\")\n    Path.mkdir(scratch_folder)\n    with cd(scratch_folder):\n        atoms_name = \"input.xyz\"\n        write(atoms_name, atoms)\n        uhf = mult - 1\n        protonate_cmd = f\"{SETTINGS.CREST_EXE_PATH_V3} {atoms_name} --opt --{gfn_level} -chrg {chg} -uhf {uhf} --T {threads}\"\n        if alpb:\n            protonate_cmd += f\" -alpb {alpb}\"\n        with Path.open(Path(\"crest_opt.sh\"), \"w\") as f:\n            f.write(f\"#!/bin/bash\\n{protonate_cmd}\")\n        log_file_path = Path(\"crest_opt.log\")\n        with log_file_path.open(\"w\") as log_file:\n            subprocess.run(\n                [\"bash\", \"crest_opt.sh\"],\n                stdout=log_file,\n                stderr=subprocess.STDOUT,\n                check=True,\n            )\n        try:\n            return read(\"crestopt.xyz\")\n        except FileNotFoundError:\n            logger.error(\n                \"The relaxation did not complete successfully, please check the log file.\"\n            )\n            return None\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html","title":"core","text":""},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential","title":"RedoxPotential","text":"<pre><code>RedoxPotential(neutral_molecule: Atoms | None = None, charged_molecule: Atoms | None = None, chg_mult: list[int] | None = None, calc_type: Literal['ox', 're'] = 'ox', calc_kwards: dict | None = None)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/core.py</code> <pre><code>def __init__(\n    self,\n    neutral_molecule: Atoms | None = None,\n    charged_molecule: Atoms | None = None,\n    chg_mult: list[int]\n    | None = None,  # * default for oxdiation potential calculation, for reduction, set [1, 1, 0, 2]\n    calc_type: Literal[\"ox\", \"re\"] = \"ox\",\n    calc_kwards: dict | None = None,\n):\n    if calc_kwards is None:\n        calc_kwards = {\n            \"opt_xc\": \"b3lyp\",\n            \"opt_basis\": \"6-31G* em=GD3BJ\",\n            \"gas_xc\": \"b3lyp\",\n            \"gas_basis\": \"6-311+G**\",\n            \"sol_xc\": \"m062x\",\n            \"sol_basis\": \"6-31G*\",  # only for solvent gibbs free energy correction\n            \"solvent\": \"Acetone\",\n        }\n    if chg_mult is None:\n        chg_mult = [-1, 1, 0, 2]\n    self.neutral_molecule = neutral_molecule\n    self.charged_molecule = charged_molecule\n    self.chg_mult = chg_mult\n    self.calc_type = calc_type\n    self.calc_kwards = calc_kwards\n    # Ensure 'gas_xc' and 'gas_basis' keys exist\n    self.calc_kwards.setdefault(\"gas_xc\", \"m062x\")\n    self.calc_kwards.setdefault(\"gas_basis\", \"6-311G**\")\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.calc_kwards","title":"calc_kwards  <code>instance-attribute</code>","text":"<pre><code>calc_kwards = calc_kwards\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.calc_type","title":"calc_type  <code>instance-attribute</code>","text":"<pre><code>calc_type = calc_type\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.charged_molecule","title":"charged_molecule  <code>instance-attribute</code>","text":"<pre><code>charged_molecule = charged_molecule\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.chg_mult","title":"chg_mult  <code>instance-attribute</code>","text":"<pre><code>chg_mult = chg_mult\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.neutral_molecule","title":"neutral_molecule  <code>instance-attribute</code>","text":"<pre><code>neutral_molecule = neutral_molecule\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.cal_cycle","title":"cal_cycle","text":"<pre><code>cal_cycle()\n</code></pre> <p>calculate the potential from neutral and charged molecule, return the potential, the unit is eV real_potential = potential - 1.44 eV</p> Source code in <code>himatcal/recipes/electrolyte/core.py</code> <pre><code>def cal_cycle(self):\n    \"\"\"\n    calculate the potential from neutral and charged molecule, return the potential, the unit is eV\n    real_potential = potential - 1.44 eV\n    \"\"\"\n    neutral_gas_gibbs, neutral_gas_spe = self.cal_energy(\n        chg_status=\"neutral\", phase_status=\"gas\"\n    )\n    charged_gas_gibbs, charged_gas_spe = self.cal_energy(\n        chg_status=\"charged\", phase_status=\"gas\"\n    )\n    neutral_solvent_gibbs, neutral_solvent_spe = self.cal_energy(\n        chg_status=\"neutral\", phase_status=\"solvent\"\n    )\n    charged_solvent_gibbs, charged_solvent_spe = self.cal_energy(\n        chg_status=\"charged\", phase_status=\"solvent\"\n    )\n\n    # * \\delta G_{gas} = G_{charged}^{gas} - G_{neutral}^{gas}\n    delta_G_gas = charged_gas_gibbs - neutral_gas_gibbs\n\n    # * \\delta G_{solvention}(neutral) = E_{neutral}^{solvent} - E_{neutral}^{gas}\n    # * \\delta G_{solvention}(charged) = E_{charged}^{solvent} - E_{charged}^{gas}\n    delta_G_solvention_neutral = neutral_solvent_spe - neutral_gas_spe\n    delta_G_solvention_charged = charged_solvent_spe - charged_gas_spe\n\n    if self.calc_type == \"ox\":\n        potential = (\n            delta_G_gas - delta_G_solvention_neutral + delta_G_solvention_charged\n        )\n    if self.calc_type == \"re\":\n        potential = -(\n            delta_G_gas - delta_G_solvention_neutral + delta_G_solvention_charged\n        )\n\n    logging.info(\n        r\"default potential unit is V, referring to Li/Li+, which is chosen as E_{abs} - 4.42 + 3.02 = E_{abs} - 1.4  V; To convert to SHE, please add 1.4 and then minus 4.42 V; more detail please refer to the paper Borodin, O.; Behl, W.; Jow, T. R. Oxidative Stability and Initial Decomposition Reactions of Carbonate, Sulfone, and Alkyl Phosphate-Based Electrolytes. J. Phys. Chem. C 2013, 117 (17), 8661-8682. https://doi.org/10.1021/jp400527c.\"\n    )\n    return potential - 1.4\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.cal_energy","title":"cal_energy","text":"<pre><code>cal_energy(chg_status: Literal['neutral', 'charged'], phase_status: Literal['gas', 'solvent'])\n</code></pre> <p>Calculates the Gibbs free energy and single point energy of a molecular system.</p> <p>This function determines the energy of a molecule based on its charge and phase status, performing necessary calculations to obtain the Gibbs free energy and single point energy. It adjusts the molecule's properties according to the specified charge and phase, and logs the results.</p> <p>Args:     chg_status: A string indicating the charge status of the molecule, either \"neutral\" or \"charged\".     phase_status: A string indicating the phase of the molecule, either \"gas\" or \"solvent\".</p> <p>Returns:     tuple: A tuple containing the Gibbs free energy and single point energy in eV.</p> Source code in <code>himatcal/recipes/electrolyte/core.py</code> <pre><code>def cal_energy(\n    self,\n    chg_status: Literal[\"neutral\", \"charged\"],\n    phase_status: Literal[\"gas\", \"solvent\"],\n):\n    \"\"\"\n    Calculates the Gibbs free energy and single point energy of a molecular system.\n\n    This function determines the energy of a molecule based on its charge and phase status, performing necessary calculations to obtain the Gibbs free energy and single point energy. It adjusts the molecule's properties according to the specified charge and phase, and logs the results.\n\n    Args:\n        chg_status: A string indicating the charge status of the molecule, either \"neutral\" or \"charged\".\n        phase_status: A string indicating the phase of the molecule, either \"gas\" or \"solvent\".\n\n    Returns:\n        tuple: A tuple containing the Gibbs free energy and single point energy in eV.\n\n    \"\"\"\n    if chg_status == \"neutral\":\n        if self.neutral_molecule is None:\n            raise ValueError(\"neutral_molecule is None\")\n        self.molecule = self.neutral_molecule.copy()\n        self.chg = self.chg_mult[0]\n        self.mult = self.chg_mult[1]\n    elif chg_status == \"charged\":\n        if self.charged_molecule is None:\n            raise ValueError(\"charged_molecule is None\")\n        self.molecule = self.charged_molecule.copy()\n        self.chg = self.chg_mult[2]\n        self.mult = self.chg_mult[3]\n    if phase_status == \"solvent\":\n        kwargs = {\n            \"xc\": self.calc_kwards[\"sol_xc\"],\n            \"basis\": self.calc_kwards[\"sol_basis\"],\n            \"scrf\": [\"SMD\", f\"solvent={self.calc_kwards['solvent']}\"],\n        }\n    elif phase_status == \"gas\":\n        kwargs = {\n            \"xc\": self.calc_kwards[\"gas_xc\"],\n            \"basis\": self.calc_kwards[\"gas_basis\"],\n        }\n    # * 1. relax the molecule in low level of theory\n    opt_kwargs = {\n        \"xc\": self.calc_kwards[\"opt_xc\"],\n        \"basis\": self.calc_kwards[\"opt_basis\"],\n    }\n    relax_results, relax_cclib_results = self.relax_llot(\n        chg=self.chg, mult=self.mult, kwargs=opt_kwargs\n    )\n    self.molecule = relax_results[\"atoms\"]\n    # * 2.calculate the single point energy from low level of theory to get the Gibbs free energy\n    sp_results, sp_cclib_results = self.sp_hlot(\n        chg=self.chg, mult=self.mult, kwargs=kwargs\n    )\n\n    # * 3.calculate the single point energy at solvation level to get the spe energy\n\n    Gibbs_energy = (\n        sp_cclib_results.scfenergies[0]\n        + relax_cclib_results.freeenergy * 27.211\n        - relax_cclib_results.scfenergies[0]\n    )\n    SPE_energy = sp_cclib_results.scfenergies[0]\n    logging.info(\n        f\"{chg_status} molecule in {phase_status} phase Gibbs free energy: {Gibbs_energy} eV, Single point energy: {SPE_energy} eV\"\n    )\n    return Gibbs_energy, SPE_energy\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.relax_llot","title":"relax_llot","text":"<pre><code>relax_llot(chg: int, mult: int, kwargs: dict | None = None)\n</code></pre> <p>low level of theory calculation for neutral and charged molecule, using for structure optimization and gibbs free energy correction if using in solvent, please pass {\"scrf\": [\"SMD\", f\"solvent={self.calc_kwards[\"solvent\"}\"]}  to kwargs</p> Source code in <code>himatcal/recipes/electrolyte/core.py</code> <pre><code>def relax_llot(self, chg: int, mult: int, kwargs: dict | None = None):\n    # sourcery skip: class-extract-method\n    \"\"\"\n    low level of theory calculation for neutral and charged molecule, using for structure optimization and gibbs free energy correction\n    if using in solvent, please pass {\"scrf\": [\"SMD\", f\"solvent={self.calc_kwards[\"solvent\"}\"]}  to kwargs\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n    calc_keywords = {\n        \"label\": \"relax_llot\",\n        \"mem\": \"64GB\",\n        \"chk\": \"Gaussian.chk\",\n        \"nprocshared\": 64,\n        \"xc\": \"b3lyp\",\n        \"basis\": \"6-31G* em=GD3BJ\",\n        \"opt\": \"\",\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"nosymmetry\": \"\",\n        \"pop\": \"CM5\",\n        \"ioplist\": [\"2/9=2000\"],\n    } | kwargs\n    logging.info(f\"Relaxing {chg} charge molecule in low level of theory\")\n    quacc_results = relax_job(\n        self.molecule,\n        charge=chg,\n        spin_multiplicity=mult,\n        freq=True,\n        **calc_keywords,\n    )\n    cclib_results = cclib_result(Path(quacc_results[\"dir_name\"]))\n    logging.info(f\"Relaxation of {chg} charge molecule in low level of theory done\")\n    return (quacc_results, cclib_results)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/core.html#himatcal.recipes.electrolyte.core.RedoxPotential.sp_hlot","title":"sp_hlot","text":"<pre><code>sp_hlot(chg: int, mult: int, kwargs: dict)\n</code></pre> <p>high level of theory single point energy calculation for neutral and charged molecule, using for gibbs the base of free energy if using in solvent, please pass {\"scrf\": [\"SMD\", f\"solvent={self.calc_kwards[\"solvent\"}\"]}  to kwargs</p> Source code in <code>himatcal/recipes/electrolyte/core.py</code> <pre><code>def sp_hlot(self, chg: int, mult: int, kwargs: dict):\n    \"\"\"\n    high level of theory single point energy calculation for neutral and charged molecule, using for gibbs the base of free energy\n    if using in solvent, please pass {\"scrf\": [\"SMD\", f\"solvent={self.calc_kwards[\"solvent\"}\"]}  to kwargs\n    \"\"\"\n    calc_keywords = {\n        \"label\": \"sp_hlot\",\n        \"mem\": \"64GB\",\n        \"chk\": \"Gaussian.chk\",\n        \"nprocshared\": 64,\n        \"xc\": \"m062x\",\n        \"basis\": \"6-311+G**\",\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"nosymmetry\": \"\",\n        \"pop\": \"CM5\",\n        \"ioplist\": [\"2/9=2000\"],\n    } | kwargs\n    logging.info(\n        f\"Calculating single point energy for {chg} charge molecule in high level of theory\"\n    )\n    quacc_results = static_job(\n        self.molecule, charge=chg, spin_multiplicity=mult, **calc_keywords\n    )\n    cclib_results = cclib_result(Path(quacc_results[\"dir_name\"]))\n    logging.info(\n        f\"Single point energy calculation for {chg} charge molecule in high level of theory done\"\n    )\n    return (quacc_results, cclib_results)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html","title":"redox","text":""},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal","title":"RedoxCal","text":"<p>               Bases: <code>BaseModel</code></p> <p>A class to calculate the oxidation and reduction potentials of a molecular system.</p> <p>This class provides methods to compute the oxidation and reduction potentials based on the molecular structure and specified ions. It allows for the inclusion of ions and various calculation parameters to tailor the analysis.</p> <p>Attributes:     molecule (Atoms | None): The molecular structure for the calculations.     chg_mult (list[int] | None): Charge multiplicities for the calculations.     add_ion (bool): Indicates whether to include an anion in the system.     ions (list[Atoms | str] | None): Ions involved in the calculations.     label (str): A label for the calculations.     calc_kwards (dict | None): Keyword arguments for calculation methods.     machine_kwards (dict | None): Machine-specific keyword arguments.</p> <p>Methods:     get_ox(): Calculates the oxidation potential of the molecular system.     get_re(): Calculates the reduction potential of the molecular system.     get_redox(): Retrieves both oxidation and reduction potentials.</p>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.add_ion","title":"add_ion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>add_ion: bool = Field(True, description='Indicates whether to include an ion in the system.')\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.calc_kwards","title":"calc_kwards  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calc_kwards: dict = Field(default_factory=lambda: {'opt_xc': 'b3lyp', 'opt_basis': '6-311+G(d,p)', 'sol_xc': 'm062x', 'sol_basis': '6-31G*', 'solvent': 'Acetone'}, description='Keyword arguments for calculation methods.')\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.charged_molecule","title":"charged_molecule  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>charged_molecule: Atoms | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.chg_mult","title":"chg_mult  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chg_mult: list[int] = Field(default_factory=lambda: [-1, 1, 0, 2, 1, 1, 0, 2], description='Charge multiplicities for the calculations.')\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.ions","title":"ions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ions: list[Atoms | str] = Field(default_factory=lambda: [PF6, 'Li'], description='Ions involved in the calculations.')\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: str = Field('redox', description='A label for the calculations.')\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.machine_kwards","title":"machine_kwards  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>machine_kwards: dict = Field(default_factory=lambda: {'xtb_proc': 16}, description='keyword arguments for Machine-specific.')\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.molecule","title":"molecule  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>molecule: Atoms | None = Field(None, description='The molecular structure for the calculations.')\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.neutral_molecule","title":"neutral_molecule  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>neutral_molecule: Atoms | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.protonate_ion_string","title":"protonate_ion_string  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>protonate_ion_string: bool = Field(True, description='Indicates whether to protonate the ion.')\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.Config","title":"Config","text":""},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.Config.arbitrary_types_allowed","title":"arbitrary_types_allowed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arbitrary_types_allowed = True\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.cal_ox","title":"cal_ox","text":"<pre><code>cal_ox()\n</code></pre> <p>Calculates the oxidation potential of a molecular system.</p> <p>This function generates the neutral and charged molecules required for calculating the oxidation potential, either by docking with ions or relaxing the molecule, depending on the presence of ions. It then computes the redox potential based on these generated molecules.</p> <p>Args:     None</p> <p>Returns:     float: The calculated oxidation potential in eV.</p> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>def cal_ox(self):\n    \"\"\"\n    Calculates the oxidation potential of a molecular system.\n\n    This function generates the neutral and charged molecules required for calculating the oxidation potential, either by docking with ions or relaxing the molecule, depending on the presence of ions. It then computes the redox potential based on these generated molecules.\n\n    Args:\n        None\n\n    Returns:\n        float: The calculated oxidation potential in eV.\n\n    \"\"\"\n\n    # * calculate the oxidation state energies (in eV)\n    logging.info(\"Calculating oxidation potential\")\n    redox_potential = RedoxPotential(\n        neutral_molecule=self.neutral_molecule,\n        charged_molecule=self.charged_molecule,\n        chg_mult=self.chg_mult[:4],\n        calc_type=\"ox\",\n        calc_kwards=self.calc_kwards,\n    ).cal_cycle()\n    logging.info(f\"{self.label} oxidation potential: {redox_potential} eV\")\n    return redox_potential\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.cal_re","title":"cal_re","text":"<pre><code>cal_re()\n</code></pre> <p>Calculates the reduction potential of a molecular system.</p> <p>This function generates the neutral and charged molecules required for calculating the reduction potential, either by protonation or relaxation, depending on the presence of ions. It utilizes a helper function to streamline the process of generating molecules and logs the resulting reduction potential.</p> <p>Args:     add_ion: A boolean indicating whether to include an anion in the system.     molecule: An Atoms object representing the molecule for the calculation.     ions: A list containing Atoms or strings representing the ions involved in the calculation.     chg_mult: A list of integers specifying the charge multiplicities for the calculation.     calc_kwards: A dictionary containing keyword arguments for the calculation methods.</p> <p>Returns:     float: The calculated reduction potential in eV.</p> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>def cal_re(self):\n    \"\"\"\n    Calculates the reduction potential of a molecular system.\n\n    This function generates the neutral and charged molecules required for calculating the reduction potential, either by protonation or relaxation, depending on the presence of ions. It utilizes a helper function to streamline the process of generating molecules and logs the resulting reduction potential.\n\n    Args:\n        add_ion: A boolean indicating whether to include an anion in the system.\n        molecule: An Atoms object representing the molecule for the calculation.\n        ions: A list containing Atoms or strings representing the ions involved in the calculation.\n        chg_mult: A list of integers specifying the charge multiplicities for the calculation.\n        calc_kwards: A dictionary containing keyword arguments for the calculation methods.\n\n    Returns:\n        float: The calculated reduction potential in eV.\n\n    \"\"\"\n    # * calculate the oxidation state energies (in eV)\n    logging.info(\"Calculating reduction potential\")\n    redox_potential = RedoxPotential(\n        neutral_molecule=self.neutral_molecule,\n        charged_molecule=self.charged_molecule,\n        chg_mult=self.chg_mult[4:8],\n        calc_type=\"re\",\n        calc_kwards=self.calc_kwards,\n    ).cal_cycle()\n    logging.info(f\"{self.label} reduction potential: {redox_potential} eV\")\n    return redox_potential\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.get_ox","title":"get_ox","text":"<pre><code>get_ox()\n</code></pre> <p>Calculates the oxidation potential of a molecular system.</p> <p>This function generates the neutral and charged molecules required for calculating the oxidation potential, either by docking with ions or relaxing the molecule, depending on the presence of ions. It then computes the redox potential based on these generated molecules.</p> <p>Args:     None</p> <p>Returns:     float: The calculated oxidation potential in eV.</p> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>def get_ox(self):\n    \"\"\"\n    Calculates the oxidation potential of a molecular system.\n\n    This function generates the neutral and charged molecules required for calculating the oxidation potential, either by docking with ions or relaxing the molecule, depending on the presence of ions. It then computes the redox potential based on these generated molecules.\n\n    Args:\n        None\n\n    Returns:\n        float: The calculated oxidation potential in eV.\n\n    \"\"\"\n    self.prepare_ox()\n    return self.cal_ox()\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.get_re","title":"get_re","text":"<pre><code>get_re()\n</code></pre> <p>Calculates the reduction potential of a molecular system.</p> <p>This function generates the neutral and charged molecules required for calculating the reduction potential, either by protonation or relaxation, depending on the presence of ions. It utilizes a helper function to streamline the process of generating molecules and logs the resulting reduction potential.</p> <p>Args:     None</p> <p>Returns:     float: The calculated reduction potential in eV.</p> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>def get_re(self):\n    \"\"\"\n    Calculates the reduction potential of a molecular system.\n\n    This function generates the neutral and charged molecules required for calculating the reduction potential, either by protonation or relaxation, depending on the presence of ions. It utilizes a helper function to streamline the process of generating molecules and logs the resulting reduction potential.\n\n    Args:\n        None\n\n    Returns:\n        float: The calculated reduction potential in eV.\n\n    \"\"\"\n    self.prepare_re()\n    return self.cal_re()\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.get_redox","title":"get_redox","text":"<pre><code>get_redox()\n</code></pre> <p>Calculates the oxidation and reduction potentials of a molecular system.</p> <p>This function retrieves the oxidation and reduction potentials by calling the respective methods and returns them as a list. It provides a convenient way to access both potentials in a single call.</p> <p>Args:     None</p> <p>Returns:     list: A list containing the oxidation potential and reduction potential.</p> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>def get_redox(self):\n    \"\"\"\n    Calculates the oxidation and reduction potentials of a molecular system.\n\n    This function retrieves the oxidation and reduction potentials by calling the respective methods and returns them as a list. It provides a convenient way to access both potentials in a single call.\n\n    Args:\n        None\n\n    Returns:\n        list: A list containing the oxidation potential and reduction potential.\n\n    \"\"\"\n\n    oxidation_potential = self.get_ox()\n    reduction_potential = self.get_re()\n    return [oxidation_potential, reduction_potential]\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.prepare_ox","title":"prepare_ox","text":"<pre><code>prepare_ox()\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>def prepare_ox(self):\n    # * generate solvated molecules using ion and counter-ion\n    if self.add_ion:\n        logging.info(\"Generate and relax molecules clusters using crest\")\n        self.neutral_molecule = dock_atoms(\n            self.molecule,\n            dock=self.ions[0],\n            crest_sampling=True,\n            chg=self.chg_mult[0],\n            mult=self.chg_mult[1],\n        )\n        self.charged_molecule = dock_atoms(\n            self.molecule,\n            dock=self.ions[0],\n            crest_sampling=True,\n            chg=self.chg_mult[2],\n            mult=self.chg_mult[3],\n        )\n    else:\n        logging.info(\"Relaxing molecules using crest\")\n        self.neutral_molecule = relax(\n            self.molecule, chg=self.chg_mult[0], mult=self.chg_mult[1]\n        )\n        self.charged_molecule = relax(\n            self.molecule, chg=self.chg_mult[2], mult=self.chg_mult[3]\n        )\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.prepare_re","title":"prepare_re","text":"<pre><code>prepare_re()\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>def prepare_re(self):\n    def generate_molecule(\n        molecule, ion, chg, mult, protonate_ion_string, threads=16\n    ):\n        \"\"\"\n        Generates a molecular structure by either protonating or docking the specified molecule.\n\n        This function attempts to protonate the given molecule using the specified ion and charge parameters. If protonation fails, it falls back to docking the molecule with the specified ion, logging the failure of the protonation attempt.\n\n        If the protonation will fail or results a mis-protonated molecule, please consider docking your ion into it by setting 'protonate_ion_string' to False in class RedoxCal. This will allow the docking attempt to work normally.\n\n        Args:\n            molecule: The molecular structure to be modified.\n            ion: The ion used for protonation or docking.\n            chg: The charge associated with the ion.\n            mult: The multiplicity of the ion.\n            protonate_ion_string: A boolean indicating whether to attempt protonation.\n            threads (int, optional): The number of threads to use for the operation. Defaults to 16.\n\n        Returns:\n            The modified molecular structure after protonation or docking, or None if both attempts fail.\n        \"\"\"\n\n        mol = (\n            protonate(molecule, ion=ion, chg=chg, mult=mult, threads=threads)\n            if protonate_ion_string is True and isinstance(ion, str)\n            else None\n        )\n        if mol is None:\n            logging.info(\"Protonation failed or skipped, trying docking\")\n            mol = dock_atoms(\n                molecule, dock=ion, crest_sampling=True, chg=chg, mult=mult\n            )\n        return mol\n\n    if self.add_ion:\n        logging.info(\"Generate and relax molecules clusters using crest\")\n        self.neutral_molecule = generate_molecule(\n            self.molecule,\n            self.ions[1],\n            self.chg_mult[4],\n            self.chg_mult[5],\n            protonate_ion_string=self.protonate_ion_string,\n        )\n        self.charged_molecule = generate_molecule(\n            self.molecule,\n            self.ions[1],\n            self.chg_mult[6],\n            self.chg_mult[7],\n            protonate_ion_string=self.protonate_ion_string,\n        )\n    else:\n        logging.info(\"Relaxing molecules using crest\")\n        self.neutral_molecule = relax(\n            self.molecule, chg=self.chg_mult[4], mult=self.chg_mult[5]\n        )\n        self.charged_molecule = relax(\n            self.molecule, chg=self.chg_mult[6], mult=self.chg_mult[7]\n        )\n    logging.info(\"Molecule generation and relaxation complete\")\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.set_calc_kwards","title":"set_calc_kwards","text":"<pre><code>set_calc_kwards(v)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>@field_validator(\"calc_kwards\")\ndef set_calc_kwards(cls, v):\n    return v or {\n        \"opt_xc\": \"b3lyp\",\n        \"opt_basis\": \"6-311+G(d,p)\",\n        \"sol_xc\": \"m062x\",\n        \"sol_basis\": \"6-31G*\",\n        \"solvent\": \"Acetone\",\n    }\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.set_chg_mult","title":"set_chg_mult","text":"<pre><code>set_chg_mult(v)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>@field_validator(\"chg_mult\")\ndef set_chg_mult(cls, v):\n    return v or [-1, 1, 0, 2, 1, 1, 0, 2]\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/redox.html#himatcal.recipes.electrolyte.redox.RedoxCal.set_ions","title":"set_ions","text":"<pre><code>set_ions(v)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/redox.py</code> <pre><code>@field_validator(\"ions\")\ndef set_ions(cls, v):\n    return v or [PF6, \"Li\"]\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html","title":"_base","text":""},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html#himatcal.recipes.electrolyte.sol_stru._base.formchkpath","title":"formchkpath  <code>module-attribute</code>","text":"<pre><code>formchkpath = str(getattr(SETTINGS, 'FORMCHK_PATH', ''))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html#himatcal.recipes.electrolyte.sol_stru._base.multiwfnpath","title":"multiwfnpath  <code>module-attribute</code>","text":"<pre><code>multiwfnpath = str(getattr(SETTINGS, 'MULTIWFN_PATH', ''))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html#himatcal.recipes.electrolyte.sol_stru._base.charges_to_json","title":"charges_to_json","text":"<pre><code>charges_to_json(charges, label)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/_base.py</code> <pre><code>def charges_to_json(charges, label):\n    charge_data = []\n    for charge in charges:\n        import re\n\n        if match := re.match(r\"(\\d+)\\((\\w+)\\s*\\)\", charge):\n            atom_index, atom_type = match.groups()\n        else:\n            raise ValueError(f\"Unexpected charge format: {charge}\")\n        atom_charge = float(charge.split()[2])\n        charge_data.append(\n            {\n                \"atom_index\": atom_index,\n                \"atom_type\": atom_type,\n                \"atom_charge\": atom_charge,\n            }\n        )\n    return json.dumps({\"label\": label, \"charges\": charge_data}, indent=4)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html#himatcal.recipes.electrolyte.sol_stru._base.extract_resp2","title":"extract_resp2","text":"<pre><code>extract_resp2(fchk_file)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/_base.py</code> <pre><code>def extract_resp2(fchk_file):\n    label = Path(fchk_file).stem\n    result = subprocess.Popen(\n        multiwfnpath,\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    if result.stdin:\n        result.stdin.write(f\"{fchk_file}\\n\")\n        result.stdin.write(\"7\\n18\\n1\\ny\\n0\\n0\\nq\\n\")  # * Multiwfn RESP2 calculation\n    else:\n        raise RuntimeError(\"Failed to write to stdin of the subprocess\")\n    out, err = result.communicate()\n    charges = []\n    capture = False\n    for line in out.splitlines():\n        if \"Center       Charge\" in line:\n            capture = True\n            continue\n        if capture:\n            if line.strip() == \"\" or \"Sum of charges\" in line:\n                break\n            charges.append(line.strip())\n    return charges_to_json(charges, label)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html#himatcal.recipes.electrolyte.sol_stru._base.formchk","title":"formchk","text":"<pre><code>formchk(chk_file: str)\n</code></pre> <p>Convert a check file to a formatted check file using an external command.</p> <p>This function takes a check file as input, executes a subprocess to convert it to a formatted check file, and returns the path of the newly created file. It ensures that the conversion process is executed correctly by checking for errors during the subprocess call.</p> <p>Args:     chk_file (str): The path to the check file to be converted.</p> <p>Returns:     Path: The path to the newly created formatted check file with a .fchk suffix.</p> <p>Raises:     subprocess.CalledProcessError: If the subprocess command fails.</p> <p>Examples:     fchk_file = formchk(\"/path/to/file.chk\")</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/_base.py</code> <pre><code>def formchk(chk_file: str):\n    \"\"\"\n    Convert a check file to a formatted check file using an external command.\n\n    This function takes a check file as input, executes a subprocess to convert it to a formatted check file, and returns the path of the newly created file. It ensures that the conversion process is executed correctly by checking for errors during the subprocess call.\n\n    Args:\n        chk_file (str): The path to the check file to be converted.\n\n    Returns:\n        Path: The path to the newly created formatted check file with a .fchk suffix.\n\n    Raises:\n        subprocess.CalledProcessError: If the subprocess command fails.\n\n    Examples:\n        fchk_file = formchk(\"/path/to/file.chk\")\n    \"\"\"\n\n    chk_file_path = Path(chk_file)\n    subprocess.run(f\"{formchkpath} {chk_file}\", shell=True, check=True)\n    return chk_file_path.with_suffix(\".fchk\")\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html#himatcal.recipes.electrolyte.sol_stru._base.gen_resp2_chg","title":"gen_resp2_chg","text":"<pre><code>gen_resp2_chg(chk_file: str)\n</code></pre> <p>Generate a charge file from a given check file by performing a RESP calculation.</p> <p>This function converts a check file to a formatted check file, runs a RESP calculation to extract charge data, and writes the results to a JSON file. It returns the path to the generated charge file with a .chg suffix.</p> <p>Args:     chk_file (str): The path to the check file to be processed, both .chk and .fchk files are supported.</p> <p>Returns:     Path: The path to the generated charge file with a .chg suffix.</p> <p>Examples:     charge_file = gen_resp2_chg(\"path/to/check_file.chk\")</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/_base.py</code> <pre><code>def gen_resp2_chg(chk_file: str):\n    \"\"\"\n    Generate a charge file from a given check file by performing a RESP calculation.\n\n    This function converts a check file to a formatted check file, runs a RESP calculation to extract charge data, and writes the results to a JSON file. It returns the path to the generated charge file with a .chg suffix.\n\n    Args:\n        chk_file (str): The path to the check file to be processed, both .chk and .fchk files are supported.\n\n    Returns:\n        Path: The path to the generated charge file with a .chg suffix.\n\n    Examples:\n        charge_file = gen_resp2_chg(\"path/to/check_file.chk\")\n    \"\"\"\n    # * Convert the check files to formatted check files.\n    fchk_file = chk_file if chk_file.endswith(\".fchk\") else str(formchk(chk_file))\n    # * Run the RESP calculation using Multiwfn.\n    with cd(Path(fchk_file).parent):\n        charges_json = extract_resp2(fchk_file=fchk_file)\n        # write the chages to a json file\n        json_file_path = Path(chk_file).with_suffix(\".json\")\n        with json_file_path.open(\"w\") as f:\n            f.write(charges_json)\n        return Path(chk_file).with_suffix(\".chg\")\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html#himatcal.recipes.electrolyte.sol_stru._base.merge_chgs","title":"merge_chgs","text":"<pre><code>merge_chgs(chg_file_1, chg_file_2)\n</code></pre> <p>Merge two charge files by averaging the charges of corresponding atoms.</p> <p>This function reads two charge files, parses their contents to extract atom data and charges, and computes the average charge for each atom. The results are then written to a new charge file, which is returned with a modified filename.</p> <p>Args:     chg_file_1 (str): The path to the first charge file to be merged.     chg_file_2 (str): The path to the second charge file to be merged.</p> <p>Returns:     Path: The path to the newly created merged charge file with a .merged.chg suffix.</p> <p>Raises:     ValueError: If there is a mismatch in atom data between the two charge files.</p> <p>Examples:     merged_file = merge_chgs(\"path/to/first.chg\", \"path/to/second.chg\")</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/_base.py</code> <pre><code>def merge_chgs(chg_file_1, chg_file_2):\n    \"\"\"\n    Merge two charge files by averaging the charges of corresponding atoms.\n\n    This function reads two charge files, parses their contents to extract atom data and charges, and computes the average charge for each atom. The results are then written to a new charge file, which is returned with a modified filename.\n\n    Args:\n        chg_file_1 (str): The path to the first charge file to be merged.\n        chg_file_2 (str): The path to the second charge file to be merged.\n\n    Returns:\n        Path: The path to the newly created merged charge file with a .merged.chg suffix.\n\n    Raises:\n        ValueError: If there is a mismatch in atom data between the two charge files.\n\n    Examples:\n        merged_file = merge_chgs(\"path/to/first.chg\", \"path/to/second.chg\")\n    \"\"\"\n\n    def parse_chg_file(chg_file):\n        with Path(chg_file).open() as f:\n            lines = f.readlines()\n        parsed_data = []\n        for line in lines:\n            parts = line.split()\n            atom_data = parts[:-1]\n            charge = float(parts[-1])\n            parsed_data.append((atom_data, charge))\n        return parsed_data\n\n    def average_charges(data1, data2):\n        averaged_data = []\n        for (atom_data1, charge1), (atom_data2, charge2) in zip(data1, data2):\n            if atom_data1 != atom_data2:\n                raise ValueError(\"Atom data mismatch between charge files\")\n            averaged_charge = (charge1 + charge2) / 2\n            averaged_data.append((atom_data1, averaged_charge))\n        return averaged_data\n\n    def write_chg_file(data, output_file):\n        with Path(output_file).open(\"w\") as f:\n            for atom_data, charge in data:\n                f.write(\" \".join(atom_data) + f\" {charge:.10f}\\n\")\n\n    data1 = parse_chg_file(chg_file_1)\n    data2 = parse_chg_file(chg_file_2)\n    averaged_data = average_charges(data1, data2)\n    output_file = Path(chg_file_1).with_suffix(\".merged.chg\")\n    write_chg_file(averaged_data, output_file)\n    return output_file\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/_base.html#himatcal.recipes.electrolyte.sol_stru._base.write_sobtopini","title":"write_sobtopini","text":"<pre><code>write_sobtopini()\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/_base.py</code> <pre><code>def write_sobtopini():\n    ## * write a sobtop.ini file in the current directory\n    content = f\"\"\"  nthreads= 4  // Number of threads used for parallel calculation\n        iskipgendih= 0  // 1: Skip generating dihedral terms, 0: Do not skip\n        ioutatminfo= 0  // 1: Output atomic coordinates and connectivities when to atminfo.txt in current folder when loading input file, 0: Do not output to file but shown on screen\n        ichggeom= 1  // 1: When loading .chg file, replace current geometry with that in .chg file, 0: Do not replace\n        k_method= 2  // Default method of determining k. 1: Seminario, 2: mSeminario, 3: m2Seminario, 4: DRIH\n        bondcrit= 1.15  // When pdb/pqr is used as input, two atoms are considered as bonded if their distance is smaller than sum of their covalent radii multiplied by this factor. Priority is lower than the criteria defined in bondcrit.dat\n        Multiwfn_cmd= \"{SETTINGS.MULTIWFN_PATH}\"// Path of executable file of Multiwfn\n        OpenBabel_cmd= \"{SETTINGS.OBABEL_PATH}\" // Path of executable file of OpenBabel\"\"\"\n    with Path.cwd().joinpath(\"sobtop.ini\").open(\"w\") as f:\n        f.write(content)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html","title":"build_box","text":""},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder","title":"ElectrolyteBuilder","text":"<pre><code>ElectrolyteBuilder(mol_path, mol_name_list: list | None = None)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/build_box.py</code> <pre><code>def __init__(self, mol_path, mol_name_list: list | None = None):\n    self.mol_path = Path(mol_path)\n    self.EC = mb.load(str(self.mol_path / \"EC.pdb\"))\n    self.DEC = mb.load(str(self.mol_path / \"DEC.pdb\"))\n    self.EMC = mb.load(str(self.mol_path / \"EMC.pdb\"))\n    self.DMC = mb.load(str(self.mol_path / \"DMC.pdb\"))\n    self.Li = mb.load(str(self.mol_path / \"Li.pdb\"))\n    self.PF6 = mb.load(str(self.mol_path / \"PF6.pdb\"))\n    if mol_name_list:\n        for mol_name in mol_name_list:\n            setattr(self, mol_name, mb.load(str(self.mol_path / f\"{mol_name}.pdb\")))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.DEC","title":"DEC  <code>instance-attribute</code>","text":"<pre><code>DEC = load(str(mol_path / 'DEC.pdb'))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.DMC","title":"DMC  <code>instance-attribute</code>","text":"<pre><code>DMC = load(str(mol_path / 'DMC.pdb'))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.EC","title":"EC  <code>instance-attribute</code>","text":"<pre><code>EC = load(str(mol_path / 'EC.pdb'))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.EMC","title":"EMC  <code>instance-attribute</code>","text":"<pre><code>EMC = load(str(mol_path / 'EMC.pdb'))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.Li","title":"Li  <code>instance-attribute</code>","text":"<pre><code>Li = load(str(mol_path / 'Li.pdb'))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.PF6","title":"PF6  <code>instance-attribute</code>","text":"<pre><code>PF6 = load(str(mol_path / 'PF6.pdb'))\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.mol_path","title":"mol_path  <code>instance-attribute</code>","text":"<pre><code>mol_path = Path(mol_path)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.build_box","title":"build_box","text":"<pre><code>build_box(box_electrolyte_composition, density, box, save_path, capital=True)\n</code></pre> <p>\u4f7f\u7528mbuild\u586b\u5145\u76d2\u5b50\u5e76\u4fee\u6b63\u6b8b\u57fa\u540d\u548c\u6b8b\u57fa\u5e8f\u53f7</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/build_box.py</code> <pre><code>def build_box(\n    self, box_electrolyte_composition, density, box, save_path, capital=True\n):\n    \"\"\"\n    \u4f7f\u7528mbuild\u586b\u5145\u76d2\u5b50\u5e76\u4fee\u6b63\u6b8b\u57fa\u540d\u548c\u6b8b\u57fa\u5e8f\u53f7\n    \"\"\"\n    box_compound = [getattr(self, key) for key in box_electrolyte_composition]\n    box_n_compounds = [\n        box_electrolyte_composition[key][\"mol\"]\n        for key in box_electrolyte_composition\n    ]\n    if density:\n        box_electrolyte = mb.packing.fill_box(\n            compound=box_compound,\n            n_compounds=box_n_compounds,\n            density=density * 1000,  # kg/m^3\n            # ratio=[1,1,1],\n            # box=[3,3,3]\n        )\n    else:\n        box_electrolyte = mb.packing.fill_box(\n            compound=box_compound,\n            n_compounds=box_n_compounds,\n            density=density *1000,# kg/m^3\n            # ratio=[1,1,1],\n            box=box,\n        )\n\n    box_electrolyte.save(save_path, overwrite=True)\n    self.fix_pdb(save_path, box_electrolyte_composition, save_path, capital=capital)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.extracted_LiPF6","title":"extracted_LiPF6","text":"<pre><code>extracted_LiPF6(round_componds_dict, arg1)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/build_box.py</code> <pre><code>def extracted_LiPF6(self, round_componds_dict, arg1):\n    MOL_LPF6 = round_componds_dict[arg1][\"mol\"]\n    del round_componds_dict[arg1]\n    round_componds_dict[\"PF6\"] = {\"mol\": MOL_LPF6, \"n_atoms\": MOL_LPF6 * 7}\n    round_componds_dict[\"Li\"] = {\"mol\": MOL_LPF6, \"n_atoms\": MOL_LPF6 * 1}\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/build_box.html#himatcal.recipes.electrolyte.sol_stru.build_box.ElectrolyteBuilder.fix_pdb","title":"fix_pdb","text":"<pre><code>fix_pdb(pdb_path, round_componds_dict, pdb_save_path, capital=True)\n</code></pre> <p>\u5c06build_electrolytes\u751f\u6210\u7684\u7535\u89e3\u6db2\u7ec4\u6210\u7684pdb\u6587\u4ef6\u4e2d\u7684RESIDUE NAME\u548cRESIDUE INDEX\u4fee\u6539\u4e3a\u6b63\u786e\u7684\u503c</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/build_box.py</code> <pre><code>def fix_pdb(self, pdb_path, round_componds_dict, pdb_save_path, capital=True):\n    # The same code as before...\n    \"\"\"\n    \u5c06build_electrolytes\u751f\u6210\u7684\u7535\u89e3\u6db2\u7ec4\u6210\u7684pdb\u6587\u4ef6\u4e2d\u7684RESIDUE NAME\u548cRESIDUE INDEX\u4fee\u6539\u4e3a\u6b63\u786e\u7684\u503c\n    \"\"\"\n    mb_compound_list = list(round_componds_dict.keys())\n    if \"LiPF6(M)\" in mb_compound_list:\n        self.extracted_LiPF6(round_componds_dict, \"LiPF6(M)\")\n    if \"LiPF6\" in mb_compound_list:\n        self.extracted_LiPF6(round_componds_dict, \"LiPF6\")\n    mb_compound_list = list(round_componds_dict.keys())\n    # print(mb_compound_list)\n    line_start = 1\n    line_stop = 1\n    with Path.open(Path(pdb_path), \"r\") as f:\n        lines = f.readlines()\n    for compound_index in range(len(mb_compound_list)):\n        if compound_index == 0:\n            line_start = 1\n            line_stop = (\n                1 + round_componds_dict[mb_compound_list[compound_index]][\"n_atoms\"]\n            )\n        else:\n            line_start = line_stop\n            line_stop = (\n                line_start\n                + round_componds_dict[mb_compound_list[compound_index]][\"n_atoms\"]\n            )\n        # print(line_start, line_stop)\n        compound = mb_compound_list[compound_index]\n        resdiue_index = 1\n        for j in range(line_start, line_stop):\n            n_compounds = round_componds_dict[compound][\"mol\"]\n            atom_per_compound = (\n                round_componds_dict[compound][\"n_atoms\"] / n_compounds\n            )\n            resdiue_index = int((j - line_start) / atom_per_compound) + 1\n            if capital:\n                resdiue_name = mb_compound_list[compound_index]\n            else:\n                resdiue_name = mb_compound_list[compound_index].lower()\n            # resdiue_name = mb_compound_list[compound_index]\n            lines[j] = (\n                (\n                    (\n                        lines[j][:17]\n                        + str(\" \" * (3 - len(resdiue_name)) + str(resdiue_name))\n                    )\n                    + lines[j][20:22]\n                )\n                + str(\" \" * (4 - len(str(resdiue_index))) + str(resdiue_index))\n                + lines[j][26:]\n            )\n            # lines[j] = lines[j].replace('HETATM','ATOM  ')\n    with Path.open(Path(pdb_save_path), \"w\") as f:\n        f.writelines(lines)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html","title":"core","text":""},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.mdp_min","title":"mdp_min  <code>module-attribute</code>","text":"<pre><code>mdp_min = '\\n;define                  = -DFLEXIBLE\\n; run control\\nintegrator      = steep                 ; steepest descents minimization\\nemtol           = 100.0                 ; stop when max force &lt; 100.0 kJ/mol/nm\\nemstep          = 0.01                  ; energy step size\\nnsteps          = 50000                 ; max number of steps\\n\\n\\n; output control\\nnstxout     = 500                       ; steps per position save\\nnstlog      = 500                       ; steps per log entry\\nnstenergy   = 50                        ; steps per energy file entry\\n\\n; cutoffs\\ncutoff-scheme   = Verlet\\nnstlist                 = 10            ; neighbor list update frequency\\nns_type                 = grid          ; neighbor list method (simple, grid)\\npbc                     = xyz           ; periodic boundary conditions\\n\\ncoulombtype             = PME           ; method for electrostatics\\nrcoulomb                = 1.2           ; Short-range electrostatic cutoff\\nrvdw                    = 1.2           ; van der Waals cutoff\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.mdp_npt","title":"mdp_npt  <code>module-attribute</code>","text":"<pre><code>mdp_npt = '\\n; run control\\nintegrator      = md\\ndt              = 0.001                 ; 2 fs\\nnsteps          = 100000                ; steps, =100 ps\\n\\n; Ooutput control\\nnstxout     = 500                       ; steps per position save\\nnstlog      = 500                       ; steps per log entry\\nnstenergy   = 50                        ; steps per energy file entry\\n\\n; cutoffs\\ncutoff-scheme   = Verlet\\nnstlist                 = 10            ; neighbor list update frequency\\nns_type                 = grid          ; neighbor list method (simple, grid)\\npbc                     = xyz           ; periodic boundary conditions\\n\\ncoulombtype             = PME           ; method for electrostatics\\nrcoulomb                = 1.2           ; Short-range electrostatic cutoff\\nrvdw                    = 1.2           ; van der Waals cutoff\\nDispCorr                = EnerPres      ; long-distance contributions to E, P\\n\\n; temperature control\\ntcoupl          = v-rescale ; velocity rescaling thermostat\\ntc_grps         = system        ; coupled to entire system\\ntau_t           = 1.0           ; time constant\\nref_t           = 300           ; temperature (K)\\n\\n; pressure control\\npcoupl          = berendsen ; barostat type\\ntau_p           = 10.0                  ; time constant\\nref_p           = 1.0                   ; pressure (bar)\\ncompressibility = 4.5e-5                ; pressure bath compressibility (of water, bar^-1)\\n\\n; bond parameters\\ncontinuation    = yes                   ; restart from NVT\\nconstraints     = h-bonds                       ; h-bond lengths constrained\\nconstraint_algorithm = LINCS    ; constraint method\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.mdp_nvt","title":"mdp_nvt  <code>module-attribute</code>","text":"<pre><code>mdp_nvt = '\\n; run control\\nintegrator      = md\\ndt              = 0.002                 ; 2 fs\\nnsteps          = 50000         ; steps, = 100 ps\\n\\n; Ooutput control\\nnstxout     = 500                       ; steps per position save\\nnstlog      = 500                       ; steps per log entry\\nnstenergy   = 50                        ; steps per energy file entry\\n\\n; cutoffs\\ncutoff-scheme   = Verlet\\nnstlist                 = 10            ; neighbor list update frequency\\nns_type                 = grid          ; neighbor list method (simple, grid)\\npbc                     = xyz           ; periodic boundary conditions\\n\\ncoulombtype             = PME           ; method for electrostatics\\nrcoulomb                = 1.2           ; Short-range electrostatic cutoff\\nrvdw                    = 1.2           ; van der Waals cutoff\\nDispCorr                = EnerPres      ; long-distance contributions to E, P\\n\\n; temperature control\\ntcoupl          = v-rescale ; velocity rescaling thermostat\\ntc_grps         = system        ; coupled to entire system\\ntau_t           = 1.0           ; time constant\\nref_t           = 300           ; temperature (K)\\n\\n; pressure control\\npcoupl          = no                    ; no pressure control in NVT\\n\\n; velocity generation\\ngen_vel         = yes                   ; generate velocities from Maxwell distribution\\ngen_temp        = 300                   ; temperature for Maxwell distribution\\n\\n; bond parameters\\ncontinuation    = no                    ; first dynamics run\\nconstraints     = h-bonds                       ; h-bond lengths constrained\\nconstraint_algorithm = LINCS    ; constraint method\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.mdp_pro","title":"mdp_pro  <code>module-attribute</code>","text":"<pre><code>mdp_pro = '\\n; Run control\\nintegrator               = md\\ntinit                    = 0\\ndt                       = 0.002\\nnsteps                   = 2500000    ; 10 ns\\n\\n; Output control\\nnstxout                  = 5000\\nnstlog                   = 5000\\nnstenergy                = 500\\n\\n; cutoffs\\ncutoff-scheme            = verlet\\nnstlist                  = 20\\nns_type                  = grid\\npbc                      = xyz\\n\\ncoulombtype              = PME\\nrcoulomb                 = 1.2\\nvdwtype                  = cutoff\\nrvdw                     = 1.2\\nDispCorr                = EnerPres\\n\\n; Temperature coupling\\ntcoupl                   = v-rescale\\ntc_grps                  = system\\ntau_t                    = 1.0\\nref_t                    = 300\\n\\n; Pressure coupling\\nPcoupl                   = berendsen\\ntau_p                    = 10.\\ncompressibility          = 4.5e-05\\nref_p                    = 1.0\\n\\n; bond parameters\\ncontinuation    = yes                   ; restart from NPT\\nconstraints     = h-bonds                       ; h-bond lengths constrained\\nconstraint_algorithm = LINCS    ; constraint method\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal","title":"DielectricConstantCal","text":"<pre><code>DielectricConstantCal(label: str, molecular_data: Atoms, charge: int, mult: int, mem='64GB', np=64)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/core.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    molecular_data: Atoms,\n    charge: int,\n    mult: int,\n    mem=\"64GB\",\n    np=64,\n):\n    self.label = label\n    self.molecular_data = molecular_data\n    self.charge = charge\n    self.mult = mult\n    self.mem = mem\n    self.np = np\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal.charge","title":"charge  <code>instance-attribute</code>","text":"<pre><code>charge = charge\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label = label\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal.mem","title":"mem  <code>instance-attribute</code>","text":"<pre><code>mem = mem\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal.molecular_data","title":"molecular_data  <code>instance-attribute</code>","text":"<pre><code>molecular_data = molecular_data\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal.mult","title":"mult  <code>instance-attribute</code>","text":"<pre><code>mult = mult\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal.np","title":"np  <code>instance-attribute</code>","text":"<pre><code>np = np\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal.get_dielect_constant","title":"get_dielect_constant","text":"<pre><code>get_dielect_constant()\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/core.py</code> <pre><code>def get_dielect_constant(self):\n    opt_method = \"b3lyp\"\n    opt_basis = \"6-31G*\"\n    gas_basis = \"def2tzvp\"\n    solvent = \"Acetone\"\n    work_path = os.getcwd()\n\n    # *  opt at the b3lyp/6-31G* level\n    opt_atoms = Gaussiancal(\n        method=opt_method, basis=opt_basis, mem=self.mem, nprocshared=self.np\n    ).run(\n        self.molecular_data,\n        self.charge,\n        self.mult,\n        cal_type=\"em=GD3BJ opt\",\n        label=f\"{self.label}-opt\",\n    )\n    # gas_sp\n    Gaussiancal(\n        method=opt_method, basis=gas_basis, mem=self.mem, nprocshared=self.np\n    ).run(\n        opt_atoms,\n        self.charge,\n        self.mult,\n        cal_type=\"em=GD3BJ\",\n        label=f\"{self.label}-gas\",\n        chk=f\"./{self.label}-gas.chk\",\n    )\n    # sol_sp\n    sol_atoms = Gaussiancal(\n        method=opt_method, basis=gas_basis, mem=self.mem, nprocshared=self.np\n    ).run(\n        opt_atoms,\n        self.charge,\n        self.mult,\n        cal_type=\"em=GD3BJ freq\",\n        label=f\"{self.label}-sol\",\n        scrf=f\"SMD, solvent={solvent}\",\n        chk=f\"./{self.label}-sol.chk\",\n    )\n    with open(get_software_json_path(), \"r\") as f:\n        sobtoppath = json.load(f)[\"sobtop_path\"]\n    self.resp2_chg(f\"./{self.label}-gas.chk\", f\"./{self.label}-sol.chk\")\n    with open(get_software_json_path(), \"r\") as f:\n        obabelpath = json.load(f)[\"obabel_path\"]\n    write(f\"./{self.label}-tmp.xyz\", sol_atoms)\n    subprocess.run(\n        f\"{obabelpath} -ixyz ./{self.label}-tmp.xyz -omol2 -O ./{self.label}.mol2\",\n        shell=True,\n    )\n    subprocess.run(\n        f\"cp ./{self.label}-gas.fchk ./{self.label}-sol.fchk ./{self.label}.chg ./{self.label}.mol2 {sobtoppath}\",\n        shell=True,\n    )\n    os.chdir(sobtoppath)\n    sobtopexe = \"./sobtop\"\n    process = subprocess.Popen(\n        sobtopexe,\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    process.stdin.write(f\"./{self.label}.mol2\\n\")\n    process.stdin.write(\n        f\"7\\n10\\n{self.label}.chg\\n0\\n2\\n\\n1\\n2\\n7\\n{self.label}-sol.fchk\\n\\n\\n0\\n\"\n    )\n    out, err = process.communicate()\n    subprocess.run(\n        f\"cp ./{self.label}.gro ./{self.label}.top ./{self.label}.itp {work_path}\",\n        shell=True,\n    )\n\n\n    os.chdir(work_path)\n    with open(get_software_json_path(), \"r\") as f:\n        gromacpath = json.load(f)[\"gromacs_path\"]\n    subprocess.run(\n        f\"{gromacpath} insert-molecules -ci {self.label}.gro -nmol 1200 -box 5 5 5 -o {self.label}-box.gro\",\n        shell=True,\n    )\n    box_num = int(\n        int(open(f\"./{self.label}-box.gro\", \"r\").readlines()[1].rstrip().split()[0])\n        / len(self.molecular_data)\n    )\n    top_file = open(f\"./{self.label}.top\", \"r\").readlines()\n    top_file_result = \"\"\n    for i in top_file:\n        if self.label in i.rstrip().split() and len(i.rstrip().split()) &gt; 1:\n            top_file_result = top_file_result + f\"{self.label}\\t{box_num}\\n\"\n        else:\n            top_file_result = top_file_result + i\n    open(f\"./{self.label}.top\", \"w\").write(top_file_result)\n    open(\"./min.mdp\", \"w\").write(mdp_min)\n    open(\"./nvt.mdp\", \"w\").write(mdp_nvt)\n    open(\"./npt.mdp\", \"w\").write(mdp_npt)\n    open(\"./pro.mdp\", \"w\").write(mdp_pro)\n    subprocess.run(\n        f\"mkdir min; cp {self.label}.top {self.label}.itp min.mdp {self.label}-box.gro min ; cd min ; {gromacpath} grompp -f min.mdp  -c {self.label}-box.gro  -p {self.label}.top -o min.tpr; {gromacpath} mdrun -nt {self.np} -deffnm min; cd ..\",\n        shell=True,\n    )\n    subprocess.run(\n        f\"mkdir nvt; cp {self.label}.top {self.label}.itp nvt.mdp nvt ; cd nvt ; cp ../min/min.gro . ; {gromacpath} grompp -f nvt.mdp  -c min.gro  -p {self.label}.top -o nvt.tpr; {gromacpath} mdrun -nt {self.np} -deffnm nvt; cd ..\",\n        shell=True,\n    )\n    subprocess.run(\n        f\"mkdir npt; cp {self.label}.top {self.label}.itp npt.mdp npt ;cd npt ; cp ../nvt/nvt.gro . ; {gromacpath} grompp -f npt.mdp  -c nvt.gro  -p {self.label}.top -o npt.tpr -maxwarn 1; {gromacpath} mdrun -nt {self.np} -deffnm npt; cd ..\",\n        shell=True,\n    )\n    subprocess.run(\n        f\"mkdir pro; cp {self.label}.top {self.label}.itp pro.mdp pro ;cd pro ; cp ../npt/npt.gro . ; {gromacpath} grompp -f pro.mdp  -c npt.gro  -p {self.label}.top -o pro.tpr -maxwarn 1; {gromacpath} mdrun -nt {self.np} -deffnm pro; cd ..\",\n        shell=True,\n    )\n    subprocess.run(f\"cp pro/pro.trr pro/pro.tpr .\", shell=True)\n    process = subprocess.Popen(\n        f\"{gromacpath} current -f pro.trr -s pro.tpr\",\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n        shell=True,\n    )\n    process.stdin.write(f\"0\\n\")\n    out, err = process.communicate()\n    open(f\"./{self.label}-constant.out\", \"w\").write(out + \"\\n\" + err)\n    result = open(f\"./{self.label}-constant.out\", \"r\").readlines()\n    for i in range(0, len(result)):\n        if \"Absolute\" in result[i].rstrip().split():\n            constant = result[i + 1].rstrip().split(\"=\")[1]\n            break\n    return float(constant)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/core.html#himatcal.recipes.electrolyte.sol_stru.core.DielectricConstantCal.resp2_chg","title":"resp2_chg","text":"<pre><code>resp2_chg(gas_chk, sol_chk)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/core.py</code> <pre><code>def resp2_chg(self, gas_chk, sol_chk):\n    with open(get_software_json_path(), \"r\") as f:\n        formchkpath = json.load(f)[\"formchk_path\"]\n    subprocess.run(f\"{formchkpath} {self.label}-gas.chk\", shell=True)\n    subprocess.run(f\"{formchkpath} {self.label}-sol.chk\", shell=True)\n    with open(get_software_json_path(), \"r\") as f:\n        multiwfnpath = f\"{json.load(f)['multiwfn_path']}\"\n    process = subprocess.Popen(\n        multiwfnpath,\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    process.stdin.write(f\"{self.label}-gas.fchk\\n\")\n    process.stdin.write(\"7\\n18\\n1\\ny\\n0\\n0\\nq\\n\")\n    out, err = process.communicate()\n    process = subprocess.Popen(\n        multiwfnpath,\n        stdin=subprocess.PIPE,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    process.stdin.write(f\"{self.label}-sol.fchk\\n\")\n    process.stdin.write(\"7\\n18\\n1\\ny\\n0\\n0\\nq\\n\")\n    out, err = process.communicate()\n    gas_chg = open(f\"{self.label}-gas.chg\", \"r\").readlines()\n    sol_chg = open(f\"{self.label}-sol.chg\", \"r\").readlines()\n    result = \"\"\n    for gas_chg_line, sol_chg_line in zip(gas_chg, sol_chg):\n        gas_chg = float(gas_chg_line.rstrip().split()[4])\n        sol_chg = float(sol_chg_line.rstrip().split()[4])\n        element = gas_chg_line.rstrip().split()[0]\n        x_corr = gas_chg_line.rstrip().split()[1]\n        y_corr = gas_chg_line.rstrip().split()[2]\n        z_corr = gas_chg_line.rstrip().split()[3]\n        chg = (gas_chg + sol_chg) / 2\n        result = result + f\"{element}\\t{x_corr}\\t{y_corr}\\t{z_corr}\\t{chg}\\n\"\n    open(f\"./{self.label}.chg\", \"w\").write(result)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/genFF.html","title":"genFF","text":"<p>generate the GAFF force field with/without the RESP2 charge, better use the chk file form desired level of theory</p>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/genFF.html#himatcal.recipes.electrolyte.sol_stru.genFF.genChk","title":"genChk","text":"<pre><code>genChk(atoms: Atoms, chg: int = 0, mult: int = 1, label='mol')\n</code></pre> <p>generate the check file with the b3lyp/def2tzvp level of theory</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/genFF.py</code> <pre><code>def genChk(atoms: Atoms, chg: int = 0, mult: int = 1, label=\"mol\"):\n    \"\"\"generate the check file with the b3lyp/def2tzvp level of theory\"\"\"\n    # * relax the structure at the b3lyp/6-31G* level\n    result = relax_job(\n        atoms,\n        charge=chg,\n        spin_multiplicity=mult,\n        xc=\"b3lyp\",\n        basis=\"6-31G*\",\n        label=f\"{label}-relax\",\n    )\n    relaxed_atoms = result[\"atoms\"]\n    # * run the single point calculation at the b3lyp/def2tzvp level default\n    static_job_result = static_job(\n        relaxed_atoms,\n        charge=chg,\n        spin_multiplicity=mult,\n        xc=\"b3lyp\",\n        basis=\"def2tzvp\",\n        freq=True,\n        label=f\"{label}-static\",\n    )\n\n    # * get the check file\n    chkfile_path = (\n        Path(static_job_result[\"dir_name\"]) / static_job_result[\"parameters\"][\"chk\"]\n    )\n    gzfile_path = chkfile_path.with_suffix(\".chk.gz\")\n\n    if not chkfile_path.exists() and gzfile_path.exists():\n        subprocess.run([\"gunzip\", str(gzfile_path)], check=True)\n\n    if not chkfile_path.exists():\n        raise FileNotFoundError(f\"Neither {chkfile_path} nor {gzfile_path} exists.\")\n\n    return chkfile_path\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/genFF.html#himatcal.recipes.electrolyte.sol_stru.genFF.genFF","title":"genFF","text":"<pre><code>genFF(atoms: Atoms, chg: int = 0, mult: int = 1, label='mol')\n</code></pre> <p>generate the GAFF force field with the RESP2 charge</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/genFF.py</code> <pre><code>def genFF(atoms: Atoms, chg: int = 0, mult: int = 1, label=\"mol\"):\n    \"\"\"generate the GAFF force field with the RESP2 charge\"\"\"\n    chkfile_path = genChk(atoms, chg, mult, label)\n    fchkfile_path = formchk(chkfile_path)\n    sobtop_genFF(str(fchkfile_path))\n    logging.info(f\"GAFF force field generated for {atoms.get_chemical_formula()}\")\n    # copy the gro,pdb,top and itp files to the current directory\n    for suffix in [\"gro\", \"pdb\", \"top\", \"itp\"]:\n        source = chkfile_path.with_suffix(f\".{suffix}\")\n        target = Path(f\"{label}.{suffix}\")\n        source.replace(target)\n    return {\n        \"atoms\": atoms,\n        \"chkfile_path\": str(chkfile_path),\n        \"grofile_path\": str(chkfile_path.with_suffix(\".gro\")),\n        \"topfile_path\": str(chkfile_path.with_suffix(\".top\")),\n        \"itpfile_path\": str(chkfile_path.with_suffix(\".itp\")),\n    }\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/genFF.html#himatcal.recipes.electrolyte.sol_stru.genFF.genFF_noRESP2","title":"genFF_noRESP2","text":"<pre><code>genFF_noRESP2(atoms: Atoms, label='mol')\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/genFF.py</code> <pre><code>def genFF_noRESP2(atoms: Atoms, label=\"mol\"):\n    obabelpath = SETTINGS.OBABEL_PATH\n    sobtop_path = SETTINGS.SOBTOP_PATH\n    pdbfile_path = Path(f\"{label}.pdb\")\n    topofile_path = Path(f\"{label}.top\")\n    itpfile_path = Path(f\"{label}.itp\")\n    mol2file_path = Path(f\"{label}.mol2\")\n    grofile_path = Path(f\"{label}.gro\")\n\n    atoms.write(\"tmp.pdb\")\n    # * convert the pdb file to mol2 file using obabel\n    subprocess.run(\n        [\n            obabelpath,\n            \"-ipdb\",\n            str(pdbfile_path),\n            \"-omol2\",\n            \"-O\",\n            str(mol2file_path),\n        ],\n        check=True,\n    )\n    # * generate the GAFF force field with the RESP2 charge using sobtop\n    sobtop_command = f\"{mol2file_path}\\n2\\n{grofile_path}\\n1\\n2\\n4{topofile_path}\\n{itpfile_path}\\n0\\n\"\n    subprocess.run([sobtop_path], input=sobtop_command, text=True, check=True)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/genFF.html#himatcal.recipes.electrolyte.sol_stru.genFF.sobtop_genFF","title":"sobtop_genFF","text":"<pre><code>sobtop_genFF(fchk_file: str, chg_file: str | None = None)\n</code></pre> <p>Generate a force field using the Sobtop method from a formatted check file.</p> <p>This function processes a formatted check file by converting it to various molecular formats and generating a GAFF force field with RESP2 charges. It utilizes external tools such as Multiwfn and Open Babel to perform the necessary conversions and calculations.</p> <p>Args:     fchk_file (str): The path to the formatted check file to be processed.     chg_file (str | None): The path to the charge file; if None, a charge file will be generated from the formatted check file.</p> <p>Returns:     None</p> <p>Raises:     subprocess.CalledProcessError: If any of the subprocess commands fail.</p> <p>Examples:     sobtop_genFF(\"path/to/file.fchk\")</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/genFF.py</code> <pre><code>def sobtop_genFF(fchk_file: str, chg_file: str | None = None):\n    \"\"\"\n    Generate a force field using the Sobtop method from a formatted check file.\n\n    This function processes a formatted check file by converting it to various molecular formats and generating a GAFF force field with RESP2 charges. It utilizes external tools such as Multiwfn and Open Babel to perform the necessary conversions and calculations.\n\n    Args:\n        fchk_file (str): The path to the formatted check file to be processed.\n        chg_file (str | None): The path to the charge file; if None, a charge file will be generated from the formatted check file.\n\n    Returns:\n        None\n\n    Raises:\n        subprocess.CalledProcessError: If any of the subprocess commands fail.\n\n    Examples:\n        sobtop_genFF(\"path/to/file.fchk\")\n    \"\"\"\n\n    sobtop_path = SETTINGS.SOBTOP_PATH\n    sobtop_parent_path = Path(sobtop_path).parent\n    multiwfn_path = SETTINGS.MULTIWFN_PATH\n    obabelpath = SETTINGS.OBABEL_PATH\n    pdbfile_path = Path(fchk_file).with_suffix(\".pdb\")\n    mol2file_path = Path(fchk_file).with_suffix(\".mol2\")\n    grofile_path = Path(fchk_file).with_suffix(\".gro\")\n    topofile_path = Path(fchk_file).with_suffix(\".top\")\n    itpfile_path = Path(fchk_file).with_suffix(\".itp\")\n    with cd(str(sobtop_parent_path)):\n        # * convert the fchk file to pdb file using Multiwfn\n        subprocess.run(\n            [multiwfn_path],\n            input=f\"{fchk_file}\\n100\\n2\\n1\\n{pdbfile_path}\\n0\\nq\\n\",\n            text=True,\n            check=True,\n        )\n\n        # * convert the pdb file to mol2 file using obabel\n        subprocess.run(\n            [\n                obabelpath,\n                \"-ipdb\",\n                str(pdbfile_path),\n                \"-omol2\",\n                \"-O\",\n                str(mol2file_path),\n            ],\n            check=True,\n        )\n\n        # * generate the GAFF force field with the RESP2 charge using sobtop\n        chg_file = str(gen_resp2_chg(fchk_file)) if chg_file is None else str(chg_file)\n        sobtop_command = f\"{mol2file_path}\\n7\\n10\\n{chg_file}\\n0\\n2\\n{grofile_path}\\n1\\n2\\n7\\n{fchk_file}\\n{topofile_path}\\n{itpfile_path}\\n0\\n\"\n        subprocess.run([sobtop_path], input=sobtop_command, text=True, check=True)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html","title":"md","text":""},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.mdp_min","title":"mdp_min  <code>module-attribute</code>","text":"<pre><code>mdp_min = '\\ntitle                      = minimization\\n; run control\\nintegrator                 = steep      ; steepest descents minimization\\nemtol                      = 100        ; stop when max force &lt; 100.0 kJ/mol/nm\\nemstep                     = 0.01       ; energy step size\\nnsteps                     = 50000     ; max number of steps\\n; output control\\nnstxout                    = 1000       ; steps per position save\\nnstlog                     = 1000       ; steps per log entry\\nnstenergy                  = 1000       ; steps per energy file entry\\n; cutoffs\\ncutoff-scheme              = Verlet     ; Buffered neighbor searching\\nnstlist                    = 10         ; neighbor list update frequency\\nns_type                    = grid       ; neighbor list method (simple, grid)\\npbc                        = xyz        ; periodic boundary conditions\\ncoulombtype                = PME        ; method for electrostatics\\nrcoulomb                   = 1.2        ; Short-range electrostatic cutoff\\nrvdw                       = 1.2        ; van der Waals cutoff\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.mdp_npt1","title":"mdp_npt1  <code>module-attribute</code>","text":"<pre><code>mdp_npt1 = 'title                     = 0.1ns npt berendsen\\n; run control\\nintegrator                = md\\ndt                        = 0.001            ; 1 fs\\nnsteps                    = 10000        ; steps, 0.1ns\\n; Ooutput control\\nnstxout                   = 0\\nnstvout                   = 0\\nnstfout                   = 0\\nnstlog                    = 5000\\nnstenergy                 = 1000\\nnstxout-compressed        = 1000\\n;Vel\\ngen_vel                   = no              ; generate velocities\\n;gen_temp                  = 300\\n;gen_seed                  = -1\\n; cutoffs\\ncutoff-scheme             = Verlet\\npbc                       = xyz         ; periodic boundary conditions\\ncoulombtype               = PME        ; method for electrostatics\\nrcoulomb                  = 1.0        ; Short-range electrostatic cutoff\\nrvdw                      = 1.0        ; van der Waals cutoff\\nDispCorr                  = EnerPres    ; long-distance contributions to E, P\\n; temperature control\\ntcoupl                    = v-rescale ; velocity rescaling thermostat\\ntc_grps                   = system    ; coupled to entire system\\ntau_t                     = 0.2        ; time constant\\nref_t                     = 298.15        ; temperature (K)\\n; pressure control\\npcoupl                    = C-rescale ; barostat type: Parrinello-Rahman, berendsen,\\npcoupltype                = isotropic\\ntau_p                     = 4            ; time constant\\nref_p                     = 1.0            ; pressure (bar)\\ncompressibility           = 5e-5        ; pressure bath compressibility (of water, bar^-1)\\n; bond parameters\\ncontinuation              = yes            ; restart from NVT\\n; constraints               = hbonds            ; h-bond lengths constrained\\n; constraint_algorithm      = LINCS    ; constraint method\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.mdp_npt2","title":"mdp_npt2  <code>module-attribute</code>","text":"<pre><code>mdp_npt2 = '\\ntitle                     = 1ns npt berendsen 1.8T annealing 0.25ns 500K 0.25ns 298K\\n; run control\\nintegrator                = md\\ndt                        = 0.001          ; 1 fs\\nnsteps                    = 1000000        ; steps, 1 ns\\n; Ooutput control\\nnstxout                   = 0\\nnstvout                   = 0\\nnstfout                   = 0\\nnstlog                    = 5000\\nnstenergy                 = 1000\\nnstxout-compressed        = 1000\\n;Vel\\ngen_vel                   = no             ; generate velocities\\n;gen_temp                  = 300\\n;gen_seed                  = -1\\n; cutoffs\\ncutoff-scheme             = Verlet\\npbc                       = xyz            ; periodic boundary conditions\\ncoulombtype               = PME            ; method for electrostatics\\nrcoulomb                  = 1.0            ; Short-range electrostatic cutoff\\nrvdw                      = 1.0            ; van der Waals cutoff\\nDispCorr                  = EnerPres       ; long-distance contributions to E, P\\n; temperature control\\ntcoupl                    = v-rescale      ; velocity rescaling thermostat\\ntc_grps                   = system         ; coupled to entire system\\ntau_t                     = 0.2            ; time constant\\nref_t                     = 298.15            ; temperature (K)\\n; pressure control\\npcoupl                    = Parrinello-Rahman ; barostat type: Parrinello-Rahman, berendsen,\\npcoupltype                = isotropic\\ntau_p                     = 4               ; time constant\\nref_p                     = 1.0             ; pressure (bar)\\ncompressibility           = 5e-5            ; pressure bath compressibility (of water, bar^-1)\\n; bond parameters\\ncontinuation              = yes             ; restart from NVT\\n; constraints               = hbonds        ; h-bond lengths constrained\\n; constraint_algorithm      = LINCS         ; constraint method\\n\\n; annealing\\nannealing                 = single          ; single or double\\nannealing_npoints         = 4               ; number of points\\nannealing_time            = 0 250 500 750       ; time points\\nannealing_temp            = 298.15 500 500 298.15  ; temperature points\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.mdp_npt3","title":"mdp_npt3  <code>module-attribute</code>","text":"<pre><code>mdp_npt3 = '\\ntitle                     = 1ns npt Parrinello-Rahman\\n; run control\\nintegrator                = md\\ndt                        = 0.001            ; 1 fs\\nnsteps                    = 1000000        ; steps, 1ns\\n; Ooutput control\\nnstxout                   = 0\\nnstvout                   = 0\\nnstfout                   = 0\\nnstlog                    = 5000\\nnstenergy                 = 1000\\nnstxout-compressed        = 1000\\n;Vel\\ngen_vel                   = no\\n;gen_temp                 = 300\\n;gen_seed                 = -1\\n; cutoffs\\ncutoff-scheme             = Verlet\\npbc                       = xyz         ; periodic boundary conditions\\ncoulombtype               = PME        ; method for electrostatics\\nrcoulomb                  = 1.0        ; Short-range electrostatic cutoff\\nrvdw                      = 1.0        ; van der Waals cutoff\\nDispCorr                  = EnerPres    ; long-distance contributions to E, P\\n; temperature control\\ntcoupl                    = v-rescale ; velocity rescaling thermostat\\ntc_grps                   = system    ; coupled to entire system\\ntau_t                     = 0.2        ; time constant\\nref_t                     = 298.15        ; temperature (K)\\n; pressure control\\npcoupl                    = Parrinello-Rahman ; barostat type: Parrinello-Rahman, berendsen,\\npcoupltype                = isotropic\\ntau_p                     = 4            ; time constant\\nref_p                     = 1.0            ; pressure (bar)\\ncompressibility           = 5e-5        ; pressure bath compressibility (of water, bar^-1)\\n; bond parameters\\ncontinuation              = yes            ; restart from NVT\\n;constraints              = hbonds            ; h-bond lengths constrained\\n;constraint_algorithm     = LINCS    ; constraint method\\n\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.mdp_nvt1","title":"mdp_nvt1  <code>module-attribute</code>","text":"<pre><code>mdp_nvt1 = 'title                     = 0.01 ns NVT\\n; Start time and timestep in ps\\nintegrator                = md\\nnsteps                    = 10000   ; 10 ps\\ndt                        = 0.001   ; set timestep to 1fs\\nnstxout\\t                  = 0\\nnstvout\\t                  = 0\\nnstenergy                 = 5000\\nnstlog                    = 5000\\ncontinuation              = no      ; first dynamics run\\nconstraint_algorithm      = Lincs   ; holonomic constraints\\nconstraints               = none    ; no constraints\\nlincs_iter                = 1\\nlincs_order               = 4\\n; cutoffs\\ncutoff-scheme             = Verlet\\nns_type                   = grid\\nnstlist                   = 10\\nrcoulomb                  = 1\\nrvdw                      = 1\\ncoulombtype               = PME\\npme_order                 = 4\\nfourierspacing            = 0.16\\n; OPTIONS FOR WEAK COUPLING ALGORITHMS\\n; Temperature coupling\\nTcoupl                    = V-rescale\\nnsttcouple                = -1\\nnh-chain-length           = 1\\n; Groups to couple separately\\ntc-grps                   = System\\n; Time constant (ps) and reference temperature (K)\\ntau_t                     = 1\\nref_t                     = 298.15\\n; Pressure coupling\\nPcoupl                    = no\\nPcoupltype                = isotropic\\n; Time constant (ps), compressibility (1/bar) and reference P (bar)\\ntau_p                     = 0.5\\ncompressibility           = 5e-5\\nref_p                     = 1.\\nrefcoord_scaling          = com\\npbc                       = xyz\\nDispcorr                  = Enerpres\\ngen_vel                   = no\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.slurm_title","title":"slurm_title  <code>module-attribute</code>","text":"<pre><code>slurm_title = '#!/bin/bash\\n#SBATCH -J gmx   ##\u4f5c\u4e1a\u540d\\n#SBATCH -p normal   ##\u961f\u5217\\n#SBATCH -n 4  ##\u6bcf\u8282\u70b9\u8fdb\u7a0b\u6570\\n\\nsource /usr/local/gromacs/bin/GMXRC.bash\\n'\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.build_box","title":"build_box","text":"<pre><code>build_box(data, compound_dict, mol_path)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/md.py</code> <pre><code>def build_box(data, compound_dict, mol_path):\n    from himatcal.recipes.electrolyte.sol_stru.build_box import ElectrolyteBuilder\n\n    density = data[\"density\"]\n    box = data[\"box\"]\n    capital = True\n\n    builder = ElectrolyteBuilder(mol_path=mol_path)\n    builder.build_box(\n        box_electrolyte_composition=compound_dict,\n        density=density,\n        box=box,\n        save_path=\"init.pdb\",\n        capital=capital,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.gmx_min","title":"gmx_min","text":"<pre><code>gmx_min(pdb_file: str, submit_job=False, **calc_kwards) -&gt; None\n</code></pre> <p>Run Gromacs minimization</p> Source code in <code>himatcal/recipes/electrolyte/sol_stru/md.py</code> <pre><code>def gmx_min(pdb_file: str, submit_job=False, **calc_kwards) -&gt; None:\n    \"\"\"\n    Run Gromacs minimization\n    \"\"\"\n    # Define file paths\n    mdp_path = Path(\"min.mdp\")\n    slurm_path = Path(\"min.slurm\")\n    pdb_path = Path(\"init.pdb\")\n\n    # Write the mdp file\n    mdp_path.write_text(mdp_min)\n\n    # Write the slurm file\n    slurm_path.write_text(slurm_title + slurm_min())\n\n    # Write the pdb file\n    pdb_path.write_text(pdb_file)\n\n    # * check the topo file\n    if not Path(\"topol.top\").exists():\n        raise FileNotFoundError(\n            \"topol.top file not found, please run gmx_write_topo() first\"\n        )\n\n    # Run the slurm job\n    if submit_job:\n        subprocess.run([\"sbatch\", str(slurm_path)], check=True, text=True)\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.gmx_solvation_md","title":"gmx_solvation_md","text":"<pre><code>gmx_solvation_md(yaml_file, submit_job=False)\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/md.py</code> <pre><code>def gmx_solvation_md(yaml_file, submit_job=False):\n    with Path.open(Path(yaml_file)) as f:\n        data = yaml.safe_load(f)\n        compound_dict = data[\"compound_dict\"]\n        mdp_files = data[\"mdp_files\"]\n        build_pdb = data[\"build_pdb\"]\n        mol_path = data[\"pdb_folder\"]\n        itp_folder = data[\"itp_folder\"]\n\n    # * write the pdb file\n    if build_pdb:\n        build_box(data, compound_dict, mol_path)\n    else:\n        pdb_file = data[\"pdb_file\"]\n        # * copy  pdb_file to init.pdb\n        Path(pdb_file).rename(\"init.pdb\")\n\n    # * write the topol.top file\n    gmx_write_topo(compound_dict, itp_folder)\n\n    # * write the mdp files from the list\n    for mdp_file in mdp_files:\n        mdp_path = Path(f\"{mdp_file}.mdp\")\n        if mdp_file == \"min\":\n            mdp_path.write_text(mdp_min)\n        elif mdp_file == \"nvt1\":\n            mdp_path.write_text(mdp_nvt1)\n        elif mdp_file == \"npt1\":\n            mdp_path.write_text(mdp_npt1)\n        elif mdp_file == \"npt2\":\n            mdp_path.write_text(mdp_npt2)\n        elif mdp_file == \"npt3\":\n            mdp_path.write_text(mdp_npt3)\n        else:\n            raise ValueError(f\"mdp file {mdp_file} not found\")\n\n    # * write the slurm file for each step in the list\n    slurm_path = Path(\"md.slurm\")\n    slurm_content = slurm_title\n    if \"min\" in mdp_files:\n        slurm_content = slurm_content + slurm_min()\n    for i in range(len(mdp_files) - 1):\n        slurm_content = slurm_content + slurm_md(mdp_files[i], mdp_files[i + 1])\n    slurm_path.write_text(slurm_content)\n\n    # Run the slurm job\n    if submit_job:\n        result = subprocess.run(\n            [\"sbatch\", str(slurm_path)], check=True, text=True, capture_output=True\n        )\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.gmx_write_topo","title":"gmx_write_topo","text":"<pre><code>gmx_write_topo(compound_dict, itp_folder: str = None) -&gt; None\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/md.py</code> <pre><code>def gmx_write_topo(compound_dict, itp_folder: str = None) -&gt; None:\n    with Path(\"topol.top\").open(\"w\") as f:\n        f.write(\"[ defaults ]\\n\")\n        f.write(\"  ;nbfunc  comb-rule  gen-pairs  fudgeLJ  fudgeQQ\\n\")\n        f.write(\"    1        3          yes        0.5      0.5\\n\")\n        f.write(f'#include \"{itp_folder}/head.itp\"\\n')\n        for compound in compound_dict:\n            f.write(f'#include \"{itp_folder}/{compound}.itp\"\\n')\n        f.write(\"\\n\\n[ system ]\")\n        f.write(\"\\n; Name\\n\")\n        for compound in compound_dict:\n            f.write(f\"{compound}-\")\n        f.write(\"\\n[ molecules ]\\n\")\n        f.write(\"; Compound        #mols\\n\")\n        for compound in compound_dict:\n            f.write(f\"{compound}           {compound_dict[compound]['mol']}\\n\")\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.slurm_md","title":"slurm_md","text":"<pre><code>slurm_md(pre_step: str = 'min', current_step: str = 'nvt1') -&gt; str\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/md.py</code> <pre><code>def slurm_md(pre_step: str = \"min\", current_step: str = \"nvt1\") -&gt; str:\n    return f\"\"\"# gromacs {current_step}\n## generate the tpr file for gromacs\ngmx grompp -f {current_step}.mdp -c {pre_step}.gro -o {current_step}.tpr\n## run gromacs\nmpirun -np 2 gmx mdrun -nt 4 -ntomp 2 -v -deffnm {current_step}\n\n\"\"\"\n</code></pre>"},{"location":"reference/himatcal/recipes/electrolyte/sol_stru/md.html#himatcal.recipes.electrolyte.sol_stru.md.slurm_min","title":"slurm_min","text":"<pre><code>slurm_min(pre_step: str = 'init.pdb', current_step: str = 'min') -&gt; str\n</code></pre> Source code in <code>himatcal/recipes/electrolyte/sol_stru/md.py</code> <pre><code>def slurm_min(pre_step: str = \"init.pdb\", current_step: str = \"min\") -&gt; str:\n    return f\"\"\"# gromacs minimization\n## generate the tpr file for gromacs\ngmx editconf -f {pre_step} -o conf.gro\ngmx grompp -f {current_step}.mdp -o {current_step}.tpr\n## run gromacs\nmpirun -np 2 gmx mdrun -nt 4 -ntomp 2 -deffnm min\n\n\"\"\"\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/_base.html","title":"_base","text":"<p>Base jobs for Gaussian.</p>"},{"location":"reference/himatcal/recipes/gaussian/_base.html#himatcal.recipes.gaussian._base.run_and_summarize","title":"run_and_summarize","text":"<pre><code>run_and_summarize(atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1, label: str = 'Gaussian', calc_defaults: dict[str, Any] | None = None, calc_swaps: dict[str, Any] | None = None, additional_fields: dict[str, Any] | None = None, copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None) -&gt; RunSchema\n</code></pre> <p>Base job function for carrying out Gaussian recipes.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>label</code>               (<code>str</code>, default:                   <code>'Gaussian'</code> )           \u2013            <p>Label for the calculation</p> </li> <li> <code>calc_defaults</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Default parameters for the calculator.</p> </li> <li> <code>calc_swaps</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the Gaussian calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.gaussian.Gaussian calculator.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to supply to the summarizer.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code> RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>himatcal/recipes/gaussian/_base.py</code> <pre><code>def run_and_summarize(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    label: str = \"Gaussian\",\n    calc_defaults: dict[str, Any] | None = None,\n    calc_swaps: dict[str, Any] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Base job function for carrying out Gaussian recipes.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    label\n        Label for the calculation\n    calc_defaults\n        Default parameters for the calculator.\n    calc_swaps\n        Dictionary of custom kwargs for the Gaussian calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.gaussian.Gaussian][] calculator.\n    additional_fields\n        Additional fields to supply to the summarizer.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n     -------\n     RunSchema\n         Dictionary of results\n    \"\"\"\n    settings = get_settings()\n    GAUSSIAN_CMD = f\"{settings.GAUSSIAN_CMD} &lt; {label}.com &gt; {label}.log\"\n    calc_flags = recursive_dict_merge(calc_defaults, calc_swaps)\n\n    calc = Gaussian(command=GAUSSIAN_CMD, label=label, **calc_flags)\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc(\n        geom_file=f\"{label}.log\"\n    )\n\n    return Summarize(\n        charge_and_multiplicity=(charge, spin_multiplicity),\n        additional_fields=additional_fields,\n    ).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/core.html","title":"core","text":""},{"location":"reference/himatcal/recipes/gaussian/core.html#himatcal.recipes.gaussian.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms: Atoms, charge: int, spin_multiplicity: int, label: str = 'relax', xc: str = 'wb97xd', basis: str = 'def2tzvp', freq: bool = False, copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, **calc_kwargs) -&gt; RunSchema\n</code></pre> <p>Run a Gaussian relaxation calculation.</p> <p>Args:     atoms: Atoms - The atoms for the calculation.     charge: int - The charge of the system.     spin_multiplicity: int - The spin multiplicity of the system.     label: str - (Optional) The label for the calculation (default is \"relax\").     xc: str - (Optional) The exchange-correlation functional to use (default is \"wb97xd\").     basis: str - (Optional) The basis set to use (default is \"def2tzvp\").     freq: bool - (Optional) Whether to perform frequency calculations (default is False).     copy_files: Union[SourceDirectory, dict[SourceDirectory, Filenames], None] - (Optional) Files to copy after the calculation.     **calc_kwargs - Additional keyword arguments for the calculation.</p> <p>Returns:     RunSchema - The summarized result of the Gaussian relaxation calculation.</p> Source code in <code>himatcal/recipes/gaussian/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    charge: int,\n    spin_multiplicity: int,\n    label: str = \"relax\",\n    xc: str = \"wb97xd\",\n    basis: str = \"def2tzvp\",\n    freq: bool = False,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Run a Gaussian relaxation calculation.\n\n    Args:\n        atoms: Atoms - The atoms for the calculation.\n        charge: int - The charge of the system.\n        spin_multiplicity: int - The spin multiplicity of the system.\n        label: str - (Optional) The label for the calculation (default is \"relax\").\n        xc: str - (Optional) The exchange-correlation functional to use (default is \"wb97xd\").\n        basis: str - (Optional) The basis set to use (default is \"def2tzvp\").\n        freq: bool - (Optional) Whether to perform frequency calculations (default is False).\n        copy_files: Union[SourceDirectory, dict[SourceDirectory, Filenames], None] - (Optional) Files to copy after the calculation.\n        **calc_kwargs - Additional keyword arguments for the calculation.\n\n    Returns:\n        RunSchema - The summarized result of the Gaussian relaxation calculation.\n    \"\"\"\n\n    calc_defaults = {\n        \"mem\": \"64GB\",\n        \"chk\": \"Gaussian.chk\",\n        \"nprocshared\": psutil.cpu_count(logical=False),\n        \"xc\": xc,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"mult\": spin_multiplicity,\n        \"opt\": \"\",\n        \"pop\": \"CM5\",\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"nosymmetry\": \"\",\n        \"ioplist\": [\"2/9=2000\"], # ASE issue #660\n    }\n    if freq:\n        calc_defaults[\"freq\"] = \"\"\n\n    return run_and_summarize(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        label=label,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"Gaussian Relax\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/core.html#himatcal.recipes.gaussian.core.static_job","title":"static_job","text":"<pre><code>static_job(atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1, label: str = 'static', xc: str = 'wb97xd', basis: str = 'def2tzvp', freq: bool = True, copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, **calc_kwargs) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>charge</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Charge of the system.</p> </li> <li> <code>spin_multiplicity</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Multiplicity of the system.</p> </li> <li> <code>xc</code>               (<code>str</code>, default:                   <code>'wb97xd'</code> )           \u2013            <p>Exchange-correlation functional</p> </li> <li> <code>basis</code>               (<code>str</code>, default:                   <code>'def2tzvp'</code> )           \u2013            <p>Basis set</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Gaussian calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the ase.calculators.gaussian.Gaussian calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>himatcal/recipes/gaussian/core.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    label: str = \"static\",\n    xc: str = \"wb97xd\",\n    basis: str = \"def2tzvp\",\n    freq: bool = True,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    charge\n        Charge of the system.\n    spin_multiplicity\n        Multiplicity of the system.\n    xc\n        Exchange-correlation functional\n    basis\n        Basis set\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Gaussian calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [ase.calculators.gaussian.Gaussian][] calculator.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n    calc_defaults = {\n        \"mem\": \"64GB\",\n        \"chk\": \"Gaussian.chk\",\n        \"nprocshared\": psutil.cpu_count(logical=True),\n        \"xc\": xc,\n        \"basis\": basis,\n        \"charge\": charge,\n        \"mult\": spin_multiplicity,\n        # \"force\": \"\",\n        \"scf\": [\"maxcycle=250\", \"xqc\"],\n        \"integral\": \"ultrafine\",\n        \"nosymmetry\": \"\",\n        \"pop\": \"CM5\",\n        \"gfinput\": \"\",\n        \"ioplist\": [\"6/7=3\", \"2/9=2000\"],  # see ASE issue #660\n    }\n    if freq:\n        calc_defaults[\"freq\"] = \"\"\n\n    return run_and_summarize(\n        atoms,\n        charge=charge,\n        spin_multiplicity=spin_multiplicity,\n        label=label,\n        calc_defaults=calc_defaults,\n        calc_swaps=calc_kwargs,\n        additional_fields={\"name\": \"Gaussian Static\"},\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html","title":"flow","text":"<p>recipes for gaussian calculation</p>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.Logger","title":"Logger  <code>module-attribute</code>","text":"<pre><code>Logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy","title":"calc_free_energy","text":"<pre><code>calc_free_energy(atoms, charge=0, mult=1, label='Gaussian', relax=False, solvent='acetone', relax_stage1_params=None)\n</code></pre> Source code in <code>himatcal/recipes/gaussian/flow.py</code> <pre><code>def __init__(\n    self,\n    atoms,\n    charge=0,\n    mult=1,\n    label=\"Gaussian\",\n    relax=False,\n    solvent=\"acetone\",\n    relax_stage1_params=None,\n):\n    self.atoms = atoms\n    self.charge = charge\n    self.mult = mult\n    self.label = label\n    self.relax = relax\n    self.solvent = solvent\n\n    if relax_stage1_params:\n        self.relax_stage1_params = relax_stage1_params\n    else:\n        # * 1. relax at 6-31G(d) level\n        self.relax_stage1_params = {\n            \"xc\": \"B3LYP\",\n            \"basis\": \"6-31G(d)\",\n            \"label\": f\"{self.label}\",\n        }\n        if self.solvent:\n            self.relax_stage1_params[\"scrf\"] = f\"pcm, solvent={self.solvent}\"\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms = atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.charge","title":"charge  <code>instance-attribute</code>","text":"<pre><code>charge = charge\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label = label\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.mult","title":"mult  <code>instance-attribute</code>","text":"<pre><code>mult = mult\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.relax","title":"relax  <code>instance-attribute</code>","text":"<pre><code>relax = relax\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.relax_stage1_params","title":"relax_stage1_params  <code>instance-attribute</code>","text":"<pre><code>relax_stage1_params = relax_stage1_params\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.solvent","title":"solvent  <code>instance-attribute</code>","text":"<pre><code>solvent = solvent\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy._extracted_from_extract_free_energy","title":"_extracted_from_extract_free_energy","text":"<pre><code>_extracted_from_extract_free_energy(log_path)\n</code></pre> Source code in <code>himatcal/recipes/gaussian/flow.py</code> <pre><code>def _extracted_from_extract_free_energy(self, log_path):\n    import gzip\n\n    import cclib\n\n    if gzip_log := list(log_path.glob(\"*.log.gz\")):\n        unzip_file = gzip.decompress(Path.open(gzip_log[0], \"rb\").read())\n        logfile = gzip_log[0].with_suffix(\"\")\n        with Path.open(logfile, \"w\") as f:\n            f.write(unzip_file.decode())\n    log_files = list(log_path.glob(\"*.log\"))\n    data = cclib.io.ccread(log_path / log_files[0])\n    free_energy = data.freeenergy\n    with Path.open(log_path / \"free_energy.txt\", \"w\") as f:\n        f.write(f\"{free_energy}\")\n    return free_energy\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.extract_free_energy","title":"extract_free_energy","text":"<pre><code>extract_free_energy()\n</code></pre> Source code in <code>himatcal/recipes/gaussian/flow.py</code> <pre><code>def extract_free_energy(self):\n    if not hasattr(self, \"result\"):\n        raise AttributeError(\"Please run the calculation first!\")\n\n    log_path = Path(self.result[\"dir_name\"])\n    with contextlib.suppress(FileNotFoundError):\n        return self._extracted_from_extract_free_energy(log_path)\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.relax_stage1","title":"relax_stage1","text":"<pre><code>relax_stage1()\n</code></pre> Source code in <code>himatcal/recipes/gaussian/flow.py</code> <pre><code>def relax_stage1(self):\n    result = relax_job(\n        self.atoms,\n        charge=self.charge,\n        spin_multiplicity=self.mult,\n        **self.relax_stage1_params,\n    )\n    self.atoms = result[\"atoms\"]\n    return self.atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.relax_stage2","title":"relax_stage2","text":"<pre><code>relax_stage2()\n</code></pre> Source code in <code>himatcal/recipes/gaussian/flow.py</code> <pre><code>def relax_stage2(self):\n    # * 2. relax at 6-311+g(d) level\n    calc_params = {\n        \"xc\": \"B3LYP\",\n        \"basis\": \"6-311+g(d) em=GD3BJ\",\n        \"label\": f\"{self.label}\",\n    }\n    if self.solvent:\n        calc_params[\"scrf\"] = f\"pcm, solvent={self.solvent}\"\n    result = relax_job(\n        self.atoms,\n        charge=self.charge,\n        spin_multiplicity=self.mult,\n        freq=True,\n        **calc_params,\n    )\n    self.atoms = result[\"atoms\"]\n    return self.atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.run","title":"run","text":"<pre><code>run()\n</code></pre> Source code in <code>himatcal/recipes/gaussian/flow.py</code> <pre><code>def run(self):\n    if self.relax:\n        # * 1. relax at 6-31G(d) level\n        self.relax_stage1()\n        # * 2. relax at 6-311+g(d) level\n        self.relax_stage2()\n        # * write relaxed atoms to file\n        self.write_relaxed()\n    # * 3. Single point calculation and get the free energy.\n    result = self.single_point()\n    self.result = result\n    return result\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.single_point","title":"single_point","text":"<pre><code>single_point()\n</code></pre> Source code in <code>himatcal/recipes/gaussian/flow.py</code> <pre><code>def single_point(self):\n    calc_params = {\n        \"xc\": \"B3LYP\",\n        \"basis\": \"6-311+g(d) em=GD3BJ\",\n        \"scrf\": \"pcm, solvent=acetone\",\n        \"label\": f\"{self.label}\",\n    }\n    if self.solvent:\n        calc_params[\"scrf\"] = f\"pcm, solvent={self.solvent}\"\n    return static_job(\n        self.atoms, charge=self.charge, spin_multiplicity=self.mult, **calc_params\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gaussian/flow.html#himatcal.recipes.gaussian.flow.calc_free_energy.write_relaxed","title":"write_relaxed","text":"<pre><code>write_relaxed()\n</code></pre> Source code in <code>himatcal/recipes/gaussian/flow.py</code> <pre><code>def write_relaxed(self):\n    from ase.io import write\n\n    from himatcal.utils.os import write_chg_mult_label\n\n    relaxed_filename = write_chg_mult_label(\n        f\"{self.label}_relaxed\", self.charge, self.mult\n    )\n    write(f\"{relaxed_filename}.xyz\", self.atoms)\n    return self.atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html","title":"DE_GSM","text":""},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM","title":"ASE_DE_GSM","text":"<pre><code>ASE_DE_GSM(reactant: Atoms | str | Any = None, product: Atoms | str | Any = None, calculator: Calculator | Any = None, multiplicity: int = 1, fixed_reactant: bool | Any = False, fixed_product: bool | Any = False, coordinate_type: Literal['TRIC', 'DLC', 'HDLC'] | Any = 'TRIC', optimizer_method: Literal['eigenvector_follow', 'lbfgs'] | Any = 'eigenvector_follow', num_of_nodes: int | Any = 11, line_search: Literal['NoLineSearch', 'backtrack'] | Any = 'NoLineSearch', conv_Ediff: float | Any = 100.0, conv_gmax: float | Any = 100.0, DMAX: float | Any = 0.1, ID: int = 0, r_type: Literal[0, 1, 2] | Any = 1, max_gsm_iterations: int = 20, max_opt_steps: int = 3)\n</code></pre> Source code in <code>himatcal/recipes/gsm/DE_GSM.py</code> <pre><code>def __init__(\n    self,\n    reactant: Atoms | str | Any = None,\n    product: Atoms | str | Any = None,\n    calculator: Calculator | Any = None,\n    multiplicity: int = 1,\n    fixed_reactant: bool | Any = False,\n    fixed_product: bool | Any = False,\n    coordinate_type: Literal[\"TRIC\", \"DLC\", \"HDLC\"] | Any = \"TRIC\",\n    optimizer_method: Literal[\"eigenvector_follow\", \"lbfgs\"]\n    | Any = \"eigenvector_follow\",\n    num_of_nodes: int | Any = 11,\n    line_search: Literal[\"NoLineSearch\", \"backtrack\"] | Any = \"NoLineSearch\",\n    conv_Ediff: float | Any = 100.0,\n    conv_gmax: float | Any = 100.0,\n    DMAX: float | Any = 0.1,\n    ID: int = 0,\n    r_type: Literal[0, 1, 2] | Any = 1,\n    max_gsm_iterations: int = 20,\n    max_opt_steps: int = 3,\n):\n    self.reactant = reactant\n    self.product = product\n    self.calculator = calculator\n    self.multiplicity = multiplicity\n    self.fixed_reactant = fixed_reactant\n    self.fixed_product = fixed_product\n    self.coordinate_type = coordinate_type\n    self.optimizer_method = optimizer_method\n    self.num_of_nodes = num_of_nodes\n    self.line_search = line_search\n    self.conv_Ediff = conv_Ediff\n    self.conv_gmax = conv_gmax\n    self.DMAX = DMAX\n    self.ID = ID\n    self.r_type = r_type\n    self.max_gsm_iterations = max_gsm_iterations\n    self.max_opt_steps = max_opt_steps\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.DMAX","title":"DMAX  <code>instance-attribute</code>","text":"<pre><code>DMAX = DMAX\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.ID","title":"ID  <code>instance-attribute</code>","text":"<pre><code>ID = ID\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.calculator","title":"calculator  <code>instance-attribute</code>","text":"<pre><code>calculator = calculator\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.conv_Ediff","title":"conv_Ediff  <code>instance-attribute</code>","text":"<pre><code>conv_Ediff = conv_Ediff\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.conv_gmax","title":"conv_gmax  <code>instance-attribute</code>","text":"<pre><code>conv_gmax = conv_gmax\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.coordinate_type","title":"coordinate_type  <code>instance-attribute</code>","text":"<pre><code>coordinate_type = coordinate_type\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.fixed_product","title":"fixed_product  <code>instance-attribute</code>","text":"<pre><code>fixed_product = fixed_product\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.fixed_reactant","title":"fixed_reactant  <code>instance-attribute</code>","text":"<pre><code>fixed_reactant = fixed_reactant\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.line_search","title":"line_search  <code>instance-attribute</code>","text":"<pre><code>line_search = line_search\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.max_gsm_iterations","title":"max_gsm_iterations  <code>instance-attribute</code>","text":"<pre><code>max_gsm_iterations = max_gsm_iterations\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.max_opt_steps","title":"max_opt_steps  <code>instance-attribute</code>","text":"<pre><code>max_opt_steps = max_opt_steps\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.multiplicity","title":"multiplicity  <code>instance-attribute</code>","text":"<pre><code>multiplicity = multiplicity\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.num_of_nodes","title":"num_of_nodes  <code>instance-attribute</code>","text":"<pre><code>num_of_nodes = num_of_nodes\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.optimizer_method","title":"optimizer_method  <code>instance-attribute</code>","text":"<pre><code>optimizer_method = optimizer_method\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.product","title":"product  <code>instance-attribute</code>","text":"<pre><code>product = product\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.r_type","title":"r_type  <code>instance-attribute</code>","text":"<pre><code>r_type = r_type\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.reactant","title":"reactant  <code>instance-attribute</code>","text":"<pre><code>reactant = reactant\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.check_atoms","title":"check_atoms","text":"<pre><code>check_atoms(values)\n</code></pre> Source code in <code>himatcal/recipes/gsm/DE_GSM.py</code> <pre><code>@field_validator(\"reactant\", \"product\")\ndef check_atoms(cls, values):\n    reactant, product = values\n    if isinstance(reactant, str):\n        values[\"reactant\"] = read(reactant)\n    if isinstance(product, str):\n        values[\"product\"] = read(product)\n    return values\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.run","title":"run","text":"<pre><code>run()\n</code></pre> Source code in <code>himatcal/recipes/gsm/DE_GSM.py</code> <pre><code>def run(self):\n    # * 0. convert atoms to geom\n    self.reactant_gemos = atoms2geom(self.reactant)\n    self.product_gemos = atoms2geom(self.product)\n\n    # * 1. build the LoT\n    logging.info(\"Building the LoT\")\n    self.lot = ASELoT.from_options(self.calculator, geom=self.reactant_gemos[2])\n\n    # * 2. build the PES\n    logging.info(\"Building the PES\")\n    self.pes = PES.from_options(\n        lot=self.lot, ad_idx=0, multiplicity=self.multiplicity\n    )\n\n    # * 3. build the topology\n    logging.info(\"Building the topologies\")\n    self.reactant_topo = Topology.build_topology(\n        xyz=self.reactant_gemos[1], atoms=self.reactant_gemos[0]\n    )\n    self.product_topo = Topology.build_topology(\n        xyz=self.product_gemos[1], atoms=self.product_gemos[0]\n    )\n    self.union_bonds()\n\n    # * 4. build the primitice internal coordinates\n    logging.info(\"Building Primitive Internal Coordinates\")\n    self.reactant_prim = PrimitiveInternalCoordinates.from_options(\n        xyz=self.reactant_gemos[1],\n        atoms=self.reactant_gemos[0],\n        topology=self.reactant_topo,\n        connect=self.coordinate_type == \"DLC\",\n        addtr=self.coordinate_type == \"TRIC\",\n        addcart=self.coordinate_type == \"HDLC\",\n    )\n    self.product_prim = PrimitiveInternalCoordinates.from_options(\n        xyz=self.product_gemos[1],\n        atoms=self.product_gemos[0],\n        topology=self.product_topo,\n        connect=self.coordinate_type == \"DLC\",\n        addtr=self.coordinate_type == \"TRIC\",\n        addcart=self.coordinate_type == \"HDLC\",\n    )\n    # * 4.1. add product coords to reactant coords\n    self.reactant_prim.add_union_primitives(self.product_prim)\n\n    # * 5. build the delocalized internal coordinates\n    logging.info(\"Building Delocalized Internal Coordinates\")\n    self.deloc_coords_reactant = DelocalizedInternalCoordinates.from_options(\n        xyz=self.reactant_gemos[1],\n        atoms=self.reactant_gemos[0],\n        connect=self.coordinate_type == \"DLC\",\n        addtr=self.coordinate_type == \"TRIC\",\n        addcart=self.coordinate_type == \"HDLC\",\n        primitives=self.reactant_prim,\n    )\n\n    # * 6. build the molecule\n    logging.info(\"Building Molecule\")\n    self.molecule_reactant = Molecule.from_options(\n        geom=self.reactant_gemos[2],\n        PES=self.pes,\n        coord_obj=self.deloc_coords_reactant,\n        Form_Hessian=self.optimizer_method == \"eigenvector_follow\",\n    )\n    self.molecule_product = Molecule.copy_from_options(\n        self.molecule_reactant,\n        xyz=self.product_gemos[1],\n        new_node_id=self.num_of_nodes - 1,\n        copy_wavefunction=False,\n    )\n\n    # * 7. create the optimizer\n    logging.info(\"Creating optimizer\")\n    opt_options = {\n        \"print_level\": 1,\n        \"Linesearch\": self.line_search,\n        \"update_hess_in_bg\": False,\n        \"conv_Ediff\": self.conv_Ediff,\n        \"conv_gmax\": self.conv_gmax,\n        \"DMAX\": self.DMAX,\n        \"opt_climb\": self.r_type in [1, 2],\n    }\n    if self.optimizer_method == \"eigenvector_follow\":\n        self.optimizer = eigenvector_follow.from_options(**opt_options)\n    elif self.optimizer_method == \"lbfgs\":\n        self.optimizer = lbfgs.from_options(**opt_options)\n    else:\n        raise NotImplementedError\n\n    # * 7.1 optimize reactant and product if needed\n    if not self.fixed_reactant:\n        path = str(Path.cwd() / \"scratch\" / f\"{self.ID:03}\" / \"0\")\n        self.optimizer.optimize(\n            molecule=self.molecule_reactant,\n            refE=self.molecule_reactant.energy,\n            opt_steps=100,\n            path=path,\n        )\n    if not self.fixed_product:\n        path = str(\n            Path.cwd() / \"scratch\" / f\"{self.ID:03}\" / str(self.num_of_nodes - 1)\n        )\n        self.optimizer.optimize(\n            molecule=self.molecule_product,\n            refE=self.molecule_product.energy,\n            opt_steps=100,\n            path=path,\n        )\n\n    # * 8. build the GSM\n    logging.info(\"Building the GSM object\")\n    self.gsm = DE_GSM.from_options(\n        reactant=self.molecule_reactant,\n        product=self.molecule_product,\n        nnodes=self.num_of_nodes,\n        CONV_TOL=0.0005,\n        CONV_gmax=self.conv_gmax,\n        CONV_Ediff=self.conv_Ediff,\n        ADD_NODE_TOL=0.1,\n        growth_direction=0,\n        optimizer=self.optimizer,\n        ID=self.ID,\n        print_level=1,\n        mp_cores=1,\n        interp_method=\"DLC\",\n        xyz_writer=XYZ_WRITERS[\"multixyz\"],\n    )\n\n    # * 9. run the GSM\n    logging.info(\"Main GSM Calculation\")\n    self.gsm.go_gsm(\n        max_iters=self.max_gsm_iterations,\n        opt_steps=self.max_opt_steps,\n        rtype=self.r_type,\n    )\n\n    # * 10. write the results into an extended xyz file\n    string_ase, ts_ase = gsm2atoms(self.gsm)\n    write(f\"opt_converged_{self.gsm.ID:03d}_ase.xyz\", string_ase)\n    write(f\"TSnode_{self.gsm.ID}.xyz\", ts_ase)\n\n    # * 11. post processing\n    logging.info(\"Post processing\")\n    post_processing(self.gsm, have_TS=True)\n\n    # * 12. cleanup\n    logging.info(\"Cleaning up\")\n    cleanup_scratch(self.gsm.ID)\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/DE_GSM.html#himatcal.recipes.gsm.DE_GSM.ASE_DE_GSM.union_bonds","title":"union_bonds","text":"<pre><code>union_bonds()\n</code></pre> Source code in <code>himatcal/recipes/gsm/DE_GSM.py</code> <pre><code>def union_bonds(self):\n    for bond in self.product_topo.edges():\n        if (\n            bond in self.reactant_topo.edges()\n            or (bond[1], bond[0]) in self.reactant_topo.edges()\n        ):\n            continue\n        logging.info(f\" Adding bond {bond} to reactant topology\")\n        if bond[0] &gt; bond[1]:\n            self.reactant_topo.add_edge(bond[0], bond[1])\n        else:\n            self.reactant_topo.add_edge(bond[1], bond[0])\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html","title":"SE_GSM","text":""},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM","title":"ASE_SE_GSM","text":"<pre><code>ASE_SE_GSM(atoms, driving_coords, multiplicity=1, calculator=None, cleanup_scratch=False)\n</code></pre> <p>This constructor sets up the parameters necessary for the class, including the atom to be used, the driving coordinates for simulations, and an optional calculator for performing calculations. It also allows for the option to clean up temporary files created during the process.</p> <p>Args:     atom: The atom to be used in the calculations.     driving_coords: A list of driving coordinates, formatted as [[\"BREAK\", 2, 3]].     calculator: An optional calculator instance; if not provided, a default XTB calculator is used.     cleanup_scratch: A boolean indicating whether to clean up scratch files after computations.</p> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def __init__(\n    self,\n    atoms,\n    driving_coords,\n    multiplicity=1,\n    calculator=None,\n    cleanup_scratch=False,\n):\n    \"\"\"\n    Initializes the class with the specified atom and driving coordinates.\n\n    This constructor sets up the parameters necessary for the class, including the atom to be used, the driving coordinates for simulations, and an optional calculator for performing calculations. It also allows for the option to clean up temporary files created during the process.\n\n    Args:\n        atom: The atom to be used in the calculations.\n        driving_coords: A list of driving coordinates, formatted as [[\"BREAK\", 2, 3]].\n        calculator: An optional calculator instance; if not provided, a default XTB calculator is used.\n        cleanup_scratch: A boolean indicating whether to clean up scratch files after computations.\n\n    \"\"\"\n\n    self.atoms = atoms\n    self.driving_coords = driving_coords  # List: driving_coords = [[\"BREAK\", 2, 3]]\n    self.multiplicity = multiplicity\n    if calculator is None:\n        from xtb_ase import XTB\n\n        calculator = XTB()\n    self.calculator = calculator\n    self.cleanup_scratch = cleanup_scratch\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms = atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.calculator","title":"calculator  <code>instance-attribute</code>","text":"<pre><code>calculator = calculator\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.cleanup_scratch","title":"cleanup_scratch  <code>instance-attribute</code>","text":"<pre><code>cleanup_scratch = cleanup_scratch\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.driving_coords","title":"driving_coords  <code>instance-attribute</code>","text":"<pre><code>driving_coords = driving_coords\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.multiplicity","title":"multiplicity  <code>instance-attribute</code>","text":"<pre><code>multiplicity = multiplicity\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.build_delocalized_coords","title":"build_delocalized_coords","text":"<pre><code>build_delocalized_coords()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def build_delocalized_coords(self):\n    nifty.printcool(\"Building Delocalized Internal Coordinates\")\n    self.coord_obj1 = DelocalizedInternalCoordinates.from_options(\n        xyz=self.xyz,\n        atoms=self.atom,\n        addtr=True,  # Add TRIC\n        primitives=self.p1,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.build_lot","title":"build_lot","text":"<pre><code>build_lot()\n</code></pre> <p>build ase lot from calculator</p> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def build_lot(self):\n    \"\"\"\n    build ase lot from calculator\n    \"\"\"\n    nifty.printcool(\" Building the LOT\")\n    self.lot = ASELoT.from_options(self.calculator, geom=self.geom)\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.build_molecule","title":"build_molecule","text":"<pre><code>build_molecule()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def build_molecule(self):\n    nifty.printcool(\"Building Molecule\")\n    self.reactant = Molecule.from_options(\n        geom=self.geom,\n        PES=self.pes,\n        coord_obj=self.coord_obj1,\n        Form_Hessian=True,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.build_pes","title":"build_pes","text":"<pre><code>build_pes()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def build_pes(self):\n    nifty.printcool(\" Building the PES\")\n    self.pes = PES.from_options(\n        lot=self.lot,\n        ad_idx=0,  # Adiabatic index (default: 0)\n        multiplicity=self.multiplicity,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.build_primitives","title":"build_primitives","text":"<pre><code>build_primitives()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def build_primitives(self):\n    nifty.printcool(\"Building Primitive Internal Coordinates\")\n    self.p1 = PrimitiveInternalCoordinates.from_options(\n        xyz=self.xyz,\n        atoms=self.atom,\n        addtr=True,  # Add TRIC\n        topology=self.top,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.build_topology","title":"build_topology","text":"<pre><code>build_topology()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def build_topology(self):\n    # * build the topology\n    self.top = Topology.build_topology(\n        self.xyz,\n        self.atom,\n    )\n    # * add the driving coordinates to the topology\n    driving_coord_prims = []\n    for dc in self.driving_coords:\n        prim = get_driving_coord_prim(dc)\n        if prim is not None:\n            driving_coord_prims.append(prim)\n\n    for prim in driving_coord_prims:\n        if type(prim) is Distance:\n            bond = (prim.atoms[0], prim.atoms[1])\n            if (\n                bond not in self.top.edges\n                and (bond[1], bond[0]) not in self.top.edges()\n            ):\n                logging.info(f\" Adding bond {bond} to top1\")\n                self.top.add_edge(bond[0], bond[1])\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.clean_scratch","title":"clean_scratch","text":"<pre><code>clean_scratch()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def clean_scratch(self):\n    if self.cleanup_scratch:\n        cmd = f\"rm scratch/growth_iters_{self.gsm.ID:03d}_*.xyz\"\n        os.system(cmd)\n        cmd = f\"rm scratch/opt_iters_{self.gsm.ID:03d}_*.xyz\"\n        os.system(cmd)\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.create_optimizer","title":"create_optimizer","text":"<pre><code>create_optimizer()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def create_optimizer(self):\n    nifty.printcool(\"Creating optimizer\")\n    self.optimizer = eigenvector_follow.from_options(\n        Linesearch=\"backtrack\",\n        OPTTHRESH=0.0005,\n        DMAX=0.5,\n        abs_max_step=0.5,\n        conv_Ediff=0.1,\n        opt_climb=True,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.optimize_reactant","title":"optimize_reactant","text":"<pre><code>optimize_reactant()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def optimize_reactant(self):\n    nifty.printcool(f\"initial energy is {self.reactant.energy:5.4f} kcal/mol\")\n    nifty.printcool(\"REACTANT GEOMETRY NOT FIXED!!! OPTIMIZING\")\n    self.optimizer.optimize(\n        molecule=self.reactant,\n        refE=self.reactant.energy,\n        opt_steps=50,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.run","title":"run","text":"<pre><code>run()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def run(self):\n    self.atom, self.xyz, self.geom = atoms2geom(self.atoms)\n    self.build_lot()\n    self.build_pes()\n    self.build_topology()\n    self.build_primitives()\n    self.build_delocalized_coords()\n    self.build_molecule()\n    self.create_optimizer()\n    self.optimize_reactant()\n    self.run_gsm()\n    post_processing(self.gsm, analyze_ICs=False, have_TS=True)\n\n    # * 10. write the results into an extended xyz file\n    string_ase, ts_ase = gsm2atoms(self.gsm)\n    write(f\"opt_converged_{self.gsm.ID:03d}_ase.xyz\", string_ase)\n    write(f\"TSnode_{self.gsm.ID}.xyz\", ts_ase)\n\n    self.clean_scratch()\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/SE_GSM.html#himatcal.recipes.gsm.SE_GSM.ASE_SE_GSM.run_gsm","title":"run_gsm","text":"<pre><code>run_gsm()\n</code></pre> Source code in <code>himatcal/recipes/gsm/SE_GSM.py</code> <pre><code>def run_gsm(self):\n    self.gsm = SE_GSM.from_options(\n        reactant=self.reactant,\n        nnodes=30,\n        optimizer=self.optimizer,\n        xyz_writer=manage_xyz.write_std_multixyz,\n        driving_coords=self.driving_coords,\n        DQMAG_MAX=1.5,  # * default value is 0.8, Maximum step size in single-ended mode\n        DQMAG_MIN=0.2,  # * default value is 0.8, Maximum step size in single-ended mode\n        ADD_NODE_TOL=0.1,  # * default value is 0.1, for GSM, Convergence tolerance for adding new node\n        CONV_TOL=0.0005,  # * Convergence tolerance for optimizing nodes\n    )\n    self.gsm.go_gsm(max_iters=50, opt_steps=10, rtype=2)\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/core.html","title":"core","text":"<p>core functions for GSM</p>"},{"location":"reference/himatcal/recipes/gsm/core.html#himatcal.recipes.gsm.core.atoms2geom","title":"atoms2geom","text":"<pre><code>atoms2geom(atoms: Atoms)\n</code></pre> <p>Converts an Atoms object into a geometric representation suitable for further processing. This function extracts atomic symbols and positions, returning them in a structured format.</p> <p>The function takes an Atoms object as input and retrieves the atomic positions and symbols. It then constructs a list of atomic data and a geometric representation, which includes the symbols and their corresponding coordinates.</p> <p>Args:     atoms (Atoms): The Atoms object containing atomic positions and symbols.</p> <p>Returns:     tuple: A tuple containing:         - List of atom objects corresponding to the atomic symbols.         - Numpy array of atomic positions.         - List of geometric representations combining symbols and positions.</p> <p>Examples:     To convert an Atoms object to its geometric representation, call:     &gt;&gt;&gt; atom_list, positions, geometry = atoms2geom(atoms)</p> Source code in <code>himatcal/recipes/gsm/core.py</code> <pre><code>def atoms2geom(atoms: Atoms):\n    \"\"\"\n    Converts an Atoms object into a geometric representation suitable for further processing. This function extracts atomic symbols and positions, returning them in a structured format.\n\n    The function takes an Atoms object as input and retrieves the atomic positions and symbols. It then constructs a list of atomic data and a geometric representation, which includes the symbols and their corresponding coordinates.\n\n    Args:\n        atoms (Atoms): The Atoms object containing atomic positions and symbols.\n\n    Returns:\n        tuple: A tuple containing:\n            - List of atom objects corresponding to the atomic symbols.\n            - Numpy array of atomic positions.\n            - List of geometric representations combining symbols and positions.\n\n    Examples:\n        To convert an Atoms object to its geometric representation, call:\n        &gt;&gt;&gt; atom_list, positions, geometry = atoms2geom(atoms)\n    \"\"\"\n\n    xyz = atoms.positions\n    geom = np.column_stack([atoms.symbols, xyz]).tolist()\n    ELEMENT_TABLE = elements.ElementData()\n    atom = [ELEMENT_TABLE.from_symbol(atom) for atom in atoms.symbols]\n    return atom, xyz, geom\n</code></pre>"},{"location":"reference/himatcal/recipes/gsm/core.html#himatcal.recipes.gsm.core.gsm2atoms","title":"gsm2atoms","text":"<pre><code>gsm2atoms(gsm)\n</code></pre> <p>convert GSM DE_GSM object to ASE Atoms objects</p> Source code in <code>himatcal/recipes/gsm/core.py</code> <pre><code>def gsm2atoms(gsm):\n    \"\"\"\n    convert GSM DE_GSM object to ASE Atoms objects\n    \"\"\"\n    # string\n    frames = []\n    for energy, geom in zip(gsm.energies, gsm.geometries):\n        at = Atoms(symbols=[x[0] for x in geom], positions=[x[1:4] for x in geom])\n        at.info[\"energy\"] = energy\n        frames.append(at)\n\n    # TS\n    ts_geom = gsm.nodes[gsm.TSnode].geometry\n    ts_atoms = Atoms(symbols=[x[0] for x in ts_geom], positions=[x[1:4] for x in ts_geom])\n\n    return frames, ts_atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/core.html","title":"core","text":""},{"location":"reference/himatcal/recipes/materials/core.html#himatcal.recipes.materials.core.ase_to_pymatgen","title":"ase_to_pymatgen  <code>staticmethod</code>","text":"<pre><code>ase_to_pymatgen(atoms)\n</code></pre> <p>Converts an ASE Atoms object to a pymatgen Structure.</p> <p>Args:     atoms: ASE Atoms object to convert.</p> <p>Returns:     pymatgen Structure object representing the same atomic configuration.</p> Source code in <code>himatcal/recipes/materials/core.py</code> <pre><code>@staticmethod\ndef ase_to_pymatgen(atoms):\n    \"\"\"\n    Converts an ASE Atoms object to a pymatgen Structure.\n\n    Args:\n        atoms: ASE Atoms object to convert.\n\n    Returns:\n        pymatgen Structure object representing the same atomic configuration.\n    \"\"\"\n\n    return Structure(\n        coords_are_cartesian=True,\n        coords=atoms.positions,\n        species=atoms.symbols,\n        lattice=atoms.cell,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/core.html#himatcal.recipes.materials.core.pymatgen_to_ase","title":"pymatgen_to_ase  <code>staticmethod</code>","text":"<pre><code>pymatgen_to_ase(structure)\n</code></pre> Source code in <code>himatcal/recipes/materials/core.py</code> <pre><code>@staticmethod\ndef pymatgen_to_ase(structure):\n    lattice = structure.lattice\n    \"\"\"\n    Converts a pymatgen Structure to an ASE Atoms object.\n\n    Args:\n        structure: pymatgen Structure object to convert.\n\n    Returns:\n        ASE Atoms object representing the same structure.\n    \"\"\"\n\n    return Atoms(\n        scaled_positions=structure.frac_coords,\n        numbers=structure.atomic_numbers,\n        pbc=True,\n        cell=Cell.fromcellpar(\n            [\n                lattice.a,\n                lattice.b,\n                lattice.c,\n                lattice.alpha,\n                lattice.beta,\n                lattice.gamma,\n            ]\n        ),\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html","title":"diffubarrier","text":""},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.Logger","title":"Logger  <code>module-attribute</code>","text":"<pre><code>Logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal","title":"DiffusionBarrierCal","text":"<pre><code>DiffusionBarrierCal(atoms: Atoms, label: str, ion_type: str = 'Li', neb_point_number: int = 5, nebor_cutoff: float = 4, parallel: int = 4)\n</code></pre> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    label: str,\n    ion_type: str = \"Li\",\n    neb_point_number: int = 5,\n    nebor_cutoff: float = 4,\n    parallel: int = 4,\n):\n    self.label = label\n    self.atoms = atoms\n    self.ion_type = ion_type\n    self.neb_point_number = neb_point_number\n    self.nebor_cutoff = nebor_cutoff\n    self.parallel = parallel\n    self._CWD = Path.cwd()\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal._CWD","title":"_CWD  <code>instance-attribute</code>","text":"<pre><code>_CWD = cwd()\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms = atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.ion_type","title":"ion_type  <code>instance-attribute</code>","text":"<pre><code>ion_type = ion_type\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label = label\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.neb_point_number","title":"neb_point_number  <code>instance-attribute</code>","text":"<pre><code>neb_point_number = neb_point_number\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.nebor_cutoff","title":"nebor_cutoff  <code>instance-attribute</code>","text":"<pre><code>nebor_cutoff = nebor_cutoff\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.parallel","title":"parallel  <code>instance-attribute</code>","text":"<pre><code>parallel = parallel\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.cal_diffusion_barrier","title":"cal_diffusion_barrier","text":"<pre><code>cal_diffusion_barrier(neb_path_floder: Path)\n</code></pre> <p>Calculate the diffusion barrier in the neb path floder</p> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def cal_diffusion_barrier(self, neb_path_floder: Path):\n    \"\"\"\n    Calculate the diffusion barrier in the neb path floder\n    \"\"\"\n    # * if Ea.txt is in cal_dir, pass\n    if Path(f\"{neb_path_floder}/Ea.txt\").exists():\n        logging.info(f\"{neb_path_floder}/Ea.txt exists.\")\n        return\n\n    # * read neb path data from the folder\n    neb_data = []\n    for i in range(self.neb_point_number + 2):\n        tmp_data = read(f\"{neb_path_floder}/0{i}.vasp\")\n        neb_data.append(tmp_data)\n    neb_data[0] = self.relax(atoms=neb_data[0])\n    neb_data[-1] = self.relax(atoms=neb_data[-1])\n\n    # * neb calculation\n    ## * 1. assign calculator to neb data\n    images = []\n    pot = matgl.load_model(\"M3GNet-MP-2021.2.8-PES\")\n    calc = M3GNetCalculator(potential=pot, stress_weight=1 / 160.21766208)\n\n    for i in neb_data:\n        i.calc = calc\n        images.append(i)\n\n    ## * 2. run neb calculation\n    neb = NEB(images, climb=True, allow_shared_calculator=True)\n    qn = FIRE(neb, trajectory=f\"{neb_path_floder}/neb.traj\")\n    try:\n        logging.info(f\"calculating image {neb_path_floder}\")\n        qn.run(fmax=0.15)\n    except Exception:\n        logging.error(f\"Error: neb calculation of image {neb_path_floder} failed.\")\n\n    ## * 3. get the neb barrier\n    traj = read(f\"{neb_path_floder}/neb.traj@-{self.neb_point_number+2}:\")\n    result = []\n    for j in traj:\n        j.calc = calc\n        result.append(j)\n    logging.info(f\"image {neb_path_floder} calculated.\")\n\n    nebtools = NEBTools(result)\n    Ef, dE = nebtools.get_barrier()\n\n    ## * 4. write the Ea to Ea.txt\n    Path.open(Path(f\"{neb_path_floder}/Ea.txt\"), \"w\").write(f\"{Ef-dE}\")\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.extract_results","title":"extract_results","text":"<pre><code>extract_results(neb_path_floders: list)\n</code></pre> <p>extract the Ea from the Ea.txt in the neb path floders</p> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def extract_results(self, neb_path_floders: list):\n    \"\"\"\n    extract the Ea from the Ea.txt in the neb path floders\n    \"\"\"\n    with Path.open(Path(f\"{self._CWD}/Ea_result.txt\"), \"w\") as f:\n        E_sum = []\n        for i in neb_path_floders:\n            try:\n                logging.info(f\"Extracting 'Ea' from {i}\")\n                tmp_Ea = float(\n                    Path.open(Path(f\"{i}/Ea.txt\"), \"r\")\n                    .readlines()[0]\n                    .rstrip()\n                    .split()[0]\n                )\n                logging.info(f\"{i} Ea: {tmp_Ea}\")\n                f.write(f\"{i}: {tmp_Ea}\\n\")\n                E_sum.append(tmp_Ea)\n            except FileNotFoundError:\n                f.write(f\"{i}: Error: File not found\\n\")\n            except ValueError:\n                f.write(f\"{i}: Error: Invalid value\\n\")\n        Ea = sum(E_sum) / len(E_sum)\n        f.write(f\"Ea: {Ea:.3f}\")\n    return Ea\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.generate_neb_path","title":"generate_neb_path","text":"<pre><code>generate_neb_path()\n</code></pre> <p>Generate the neb path using the OgStrucure and return the path of the neb path floders.</p> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def generate_neb_path(self):\n    \"\"\"\n    Generate the neb path using the OgStrucure and return the path of the neb path floders.\n    \"\"\"\n    self.structure = self.relax(atoms=self.atoms, relax_cell=True)\n    write(\"relaxed_atoms.vasp\", self.structure)\n    OgStructure(structure=self.structure).generate_neb(\n        moving_atom_species=self.ion_type,\n        num_images=self.neb_point_number,\n        r=self.nebor_cutoff,\n    )\n    return [item for item in self._CWD.iterdir() if item.is_dir()]\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.get_diffusion_barrier","title":"get_diffusion_barrier","text":"<pre><code>get_diffusion_barrier()\n</code></pre> <p>Get the diffusion barrier of the atoms.</p> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def get_diffusion_barrier(self):\n    \"\"\"\n    Get the diffusion barrier of the atoms.\n    \"\"\"\n    # * 1. generate neb path\n    neb_path_floders = self.generate_neb_path()\n    logging.info(f\"neb_path_floders: {neb_path_floders}\")\n\n    # * 2. calculate diffusion barrier\n    # for folder in neb_path_floders:\n    #     logging.info(f\"cal_diffusion_barrier {folder}\")\n    #     try:\n    #         self.cal_diffusion_barrier(folder)\n    #     except Exception:\n    #         logging.error(f\"Error: cal_diffusion_barrier {folder} failed.\")\n    pool = Pool(nodes=min(self.parallel, len(neb_path_floders)))\n    pool.map(self.cal_diffusion_barrier, neb_path_floders)\n    logging.info(\"cal_diffusion_barrier done\")\n\n    # * 3. extract results Ea\n    return self.extract_results(neb_path_floders)\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.DiffusionBarrierCal.relax","title":"relax","text":"<pre><code>relax(atoms, relax_cell=False)\n</code></pre> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def relax(self, atoms, relax_cell=False):\n    pot = matgl.load_model(\"M3GNet-MP-2021.2.8-PES\")\n    relaxer = Relaxer(potential=pot, relax_cell=relax_cell)\n    relax_results = relaxer.relax(atoms, verbose=True, fmax=0.1)\n    return pymatgen_to_ase(relax_results[\"final_structure\"])\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure","title":"OgStructure","text":"<pre><code>OgStructure(structure: Atoms | Structure | str = None)\n</code></pre> <p>model from OgStructure, using to generate the NEB Path in the Crystal.</p> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def __init__(\n    self,\n    structure: Atoms | Structure | str = None,\n) -&gt; None:\n    if structure is None:\n        return\n\n    if isinstance(structure, str):\n        parser = CifParser.from_str(structure)\n        structure = parser.get_structures()[0]\n    elif isinstance(structure, Atoms):\n        self.structure = ase_to_pymatgen(structure)\n    elif isinstance(structure, Structure):\n        self.structure = structure\n\n    self.structure.sort()\n    self.pot = matgl.load_model(\"M3GNet-MP-2021.2.8-PES\")\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure.pot","title":"pot  <code>instance-attribute</code>","text":"<pre><code>pot = load_model('M3GNet-MP-2021.2.8-PES')\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure.structure","title":"structure  <code>instance-attribute</code>","text":"<pre><code>structure = ase_to_pymatgen(structure)\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure._get_site_for_neighbor_site","title":"_get_site_for_neighbor_site","text":"<pre><code>_get_site_for_neighbor_site(neighbor)\n</code></pre> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def _get_site_for_neighbor_site(self, neighbor):\n    for i_site in range(len(self.structure)):\n        if self.equivalent_sites(i_site, neighbor):\n            return i_site\n    logging.error(f\"og:No equivalent: {neighbor}\")\n    return None\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure.center","title":"center","text":"<pre><code>center(about_atom=None, about_point=None)\n</code></pre> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def center(self, about_atom=None, about_point=None):\n    if about_atom is not None:\n        about_point = self.structure.frac_coords[about_atom]\n    elif about_point is None:\n        about_point = [0, 0, 0]\n    sys = pymatgen_to_ase(self.structure)\n    sys.center(about=about_point)\n    self.structure = ase_to_pymatgen(sys)\n    return self\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure.epsilon","title":"epsilon","text":"<pre><code>epsilon(a, b)\n</code></pre> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def epsilon(self, a, b):\n    return abs(a - b) &lt; 1e-6\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure.equivalent_sites","title":"equivalent_sites","text":"<pre><code>equivalent_sites(i, site)\n</code></pre> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def equivalent_sites(self, i, site):\n    return bool(\n        self.epsilon(self.structure.frac_coords[i][0] % 1, site.frac_coords[0] % 1)\n        and self.epsilon(\n            self.structure.frac_coords[i][1] % 1, site.frac_coords[1] % 1\n        )\n        and self.epsilon(\n            self.structure.frac_coords[i][2] % 1, site.frac_coords[2] % 1\n        )\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure.generate_neb","title":"generate_neb","text":"<pre><code>generate_neb(moving_atom_species, num_images=5, r=4) -&gt; None\n</code></pre> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def generate_neb(\n    self,\n    moving_atom_species,\n    num_images=5,\n    r=4,\n) -&gt; None:\n    structure = self.structure\n    self.neb_paths = []\n\n    def get_moving_atom_neighbors(site):\n        return [\n            neighbor\n            for neighbor in structure.get_neighbors(site=site, r=r)\n            if neighbor.specie.symbol == moving_atom_species\n        ]\n\n    def modify_structure(new_structure, i_site, i_neighbor_site):\n        ogs = OgStructure(new_structure)\n        new_structure = ogs.center(i_site, [0.5, 0.5, 0.5]).structure\n\n        initial_structure = new_structure.copy()\n        final_structure = new_structure.copy()\n        initial_structure.remove_sites([i_site, i_neighbor_site])\n        initial_structure.append(\n            species=new_structure[i_site].species,\n            coords=new_structure[i_site].frac_coords,\n        )\n        initial = pymatgen_to_ase(initial_structure)\n        final_structure.remove_sites([i_site, i_neighbor_site])\n        final_structure.append(\n            species=new_structure[i_neighbor_site].species,\n            coords=new_structure[i_neighbor_site].frac_coords,\n        )\n        final = pymatgen_to_ase(final_structure)\n        return initial, final\n\n    def handle_neb_path(i_site, i_neighbor_site):\n        new_structure = structure.copy()\n        self.neb_paths.append([i_site, i_neighbor_site])\n        neb_folder = f\"neb_path_{i_neighbor_site}_{i_site}\"\n\n        initial, final = modify_structure(new_structure, i_site, i_neighbor_site)\n\n        self.images = (\n            [initial] + [initial.copy() for _ in range(num_images)] + [final]\n        )\n        self.neb = NEB(self.images)\n        Path(neb_folder).mkdir(exist_ok=True)\n        self.neb.interpolate(mic=True)\n        for i, img in enumerate(self.images):\n            image = OgStructure(img).relax()\n            image_str = image.structure.to(fmt=\"poscar\")\n            with Path.open(Path(f\"{neb_folder}/{str(i).zfill(2)}.vasp\"), \"w\") as f:\n                f.write(image_str)\n\n    for i_site in range(len(structure)):\n        if structure[i_site].specie.symbol == moving_atom_species:\n            neighbors = get_moving_atom_neighbors(structure[i_site])\n            logging.info(f\"og:Full neighbors: {neighbors}\")\n            logging.info(\n                f\"og:Checking site, {i_site} Surrounded by {len(neighbors)}\"\n            )\n            for neighbor in neighbors:\n                i_neighbor_site = self._get_site_for_neighbor_site(neighbor)\n                logging.info(f\"og:Checking neighbor site {i_neighbor_site}\")\n                if i_neighbor_site is None:\n                    logging.error(\"og:Really? Wrong site in neighbor list!\")\n                if [i_site, i_neighbor_site] in self.neb_paths or [\n                    i_neighbor_site,\n                    i_site,\n                ] in self.neb_paths:\n                    continue\n                handle_neb_path(i_site, i_neighbor_site)\n</code></pre>"},{"location":"reference/himatcal/recipes/materials/diffubarrier.html#himatcal.recipes.materials.diffubarrier.OgStructure.relax","title":"relax","text":"<pre><code>relax()\n</code></pre> Source code in <code>himatcal/recipes/materials/diffubarrier.py</code> <pre><code>def relax(self):\n    relaxer = Relaxer(potential=self.pot, relax_cell=False)\n    relax_results = relaxer.relax(self.structure, verbose=True, fmax=0.1)\n    self.structure = relax_results[\"final_structure\"]\n    self.total_energy = relax_results[\"trajectory\"].energies[-1]\n    return self\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html","title":"core","text":""},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner","title":"MCD_runner","text":"<pre><code>MCD_runner(atoms: Atoms, chg: int = 0, mult: int = 1, driving_coords: list | None = None, qcsoft: str = 'gaussian', command: str = 'g16', calc_kwargs: str = '#N B3LYP/6-311+g* em=GD3BJ scf(xqc) scrf(iefpcm, solvent=acetone)', num_relaxation: int = 5, step_size: float = 0.05, working_directory='', output_directory='', use_hessian: bool = False, hessian_update: str = 'exact', unit: str = 'Hartree')\n</code></pre> Source code in <code>himatcal/recipes/mcd/core.py</code> <pre><code>def __init__(\n    self,\n    atoms: Atoms,\n    chg: int = 0,\n    mult: int = 1,\n    driving_coords: list | None = None,  # atoms' index, target bondlength, step, [[1, 8, 2.1, 5]]\n    qcsoft: str = \"gaussian\",\n    command: str = \"g16\",\n    calc_kwargs: str = \"#N B3LYP/6-311+g* em=GD3BJ scf(xqc) scrf(iefpcm, solvent=acetone)\",\n    num_relaxation: int = 5,\n    step_size: float = 0.05,\n    working_directory=\"\",\n    output_directory=\"\",\n    use_hessian: bool = False,\n    hessian_update: str = \"exact\",\n    unit: str = \"Hartree\",\n):\n    self.atoms = atoms\n    self.chg = chg\n    self.mult = mult\n    self.driving_coords = driving_coords\n    self.qcsoft = qcsoft\n    self.command = command\n    self.calc_kwargs = calc_kwargs\n    self.num_relaxation = num_relaxation\n    self.use_hessian = use_hessian\n    self.hessian_update = hessian_update\n    self.step_size = step_size\n    if output_directory == \"\":\n        output_directory = str(Path.cwd())\n    if working_directory == \"\":\n        working_directory = output_directory\n    self.working_directory = working_directory\n    self.output_directory = output_directory\n    self.unit = unit\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.atoms","title":"atoms  <code>instance-attribute</code>","text":"<pre><code>atoms = atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.calc_kwargs","title":"calc_kwargs  <code>instance-attribute</code>","text":"<pre><code>calc_kwargs = calc_kwargs\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.chg","title":"chg  <code>instance-attribute</code>","text":"<pre><code>chg = chg\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command = command\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.driving_coords","title":"driving_coords  <code>instance-attribute</code>","text":"<pre><code>driving_coords = driving_coords\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.hessian_update","title":"hessian_update  <code>instance-attribute</code>","text":"<pre><code>hessian_update = hessian_update\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.mult","title":"mult  <code>instance-attribute</code>","text":"<pre><code>mult = mult\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.num_relaxation","title":"num_relaxation  <code>instance-attribute</code>","text":"<pre><code>num_relaxation = num_relaxation\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.output_directory","title":"output_directory  <code>instance-attribute</code>","text":"<pre><code>output_directory = output_directory\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.qcsoft","title":"qcsoft  <code>instance-attribute</code>","text":"<pre><code>qcsoft = qcsoft\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.step_size","title":"step_size  <code>instance-attribute</code>","text":"<pre><code>step_size = step_size\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.unit","title":"unit  <code>instance-attribute</code>","text":"<pre><code>unit = unit\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.use_hessian","title":"use_hessian  <code>instance-attribute</code>","text":"<pre><code>use_hessian = use_hessian\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.working_directory","title":"working_directory  <code>instance-attribute</code>","text":"<pre><code>working_directory = working_directory\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.dirving_constraints","title":"dirving_constraints","text":"<pre><code>dirving_constraints()\n</code></pre> Source code in <code>himatcal/recipes/mcd/core.py</code> <pre><code>def dirving_constraints(self):\n    constraints = {}\n    num_steps = {}\n    for DC in self.driving_coords:\n        constraint = (DC[0] - 1, DC[1] - 1)\n        constraints[constraint] = DC[2]\n        num_steps[constraint] = DC[3]\n    return constraints, num_steps\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.get_calculator","title":"get_calculator","text":"<pre><code>get_calculator()\n</code></pre> Source code in <code>himatcal/recipes/mcd/core.py</code> <pre><code>def get_calculator(self):\n    if self.qcsoft == \"gaussian\":\n        from himatcal.calculator.gaussian_mcd import Gaussian\n\n        calculator = Gaussian(self.command)\n    elif self.qcsoft == \"orca\":\n        from himatcal.calculator.orca_mcd import Orca\n\n        calculator = Orca(self.command)\n    else:\n        print(\n            f\"Wrong calculator (={self.qcsoft}) is given! Check the option file !!!\"\n        )\n        calculator = None\n        return calculator\n    calculator.content = self.calc_kwargs\n    # basis_file = os.path.join(args.input_directory,'basis') # For Effective Core Potential\n    # if os.path.exists(basis_file):\n    #     calculator.load_basis(basis_file)\n    return calculator\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.read_reactant","title":"read_reactant","text":"<pre><code>read_reactant()\n</code></pre> Source code in <code>himatcal/recipes/mcd/core.py</code> <pre><code>def read_reactant(self):\n    atom_list = []\n    for a in self.atoms:\n        atom = chem.Atom(a.symbol)\n        atom.x = a.x\n        atom.y = a.y\n        atom.z = a.z\n        atom_list.append(atom)\n    reactant = chem.Molecule()\n    reactant.atom_list = atom_list\n    reactant.chg = self.chg\n    reactant.multiplicity = self.mult\n    return reactant\n</code></pre>"},{"location":"reference/himatcal/recipes/mcd/core.html#himatcal.recipes.mcd.core.MCD_runner.run_MCD","title":"run_MCD","text":"<pre><code>run_MCD()\n</code></pre> Source code in <code>himatcal/recipes/mcd/core.py</code> <pre><code>def run_MCD(self):\n    reactant = self.read_reactant()\n    calculator = self.get_calculator()\n    constraints, num_steps = self.dirving_constraints()\n    scanner = mcd.MCD(num_relaxation=self.num_relaxation, calculator=calculator)\n    scanner.use_hessian = self.use_hessian\n    scanner.hessian_update = self.hessian_update\n    scanner.step_size = self.step_size\n    scanner.log_directory = self.output_directory\n    scanner.change_working_directory(self.working_directory)\n    pathway = scanner.scan(\n        reactant,\n        constraints,\n        num_steps,\n        chg=self.chg,\n        multiplicity=self.mult,\n    )\n    return pathway\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/core.html","title":"core","text":""},{"location":"reference/himatcal/recipes/mol/core.html#himatcal.recipes.mol.core.CASNumber","title":"CASNumber","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/himatcal/recipes/mol/core.html#himatcal.recipes.mol.core.CASNumber.cas_number","title":"cas_number  <code>instance-attribute</code>","text":"<pre><code>cas_number: str\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/core.html#himatcal.recipes.mol.core.CASNumber.validate_cas_number","title":"validate_cas_number","text":"<pre><code>validate_cas_number(value)\n</code></pre> Source code in <code>himatcal/recipes/mol/core.py</code> <pre><code>@field_validator(\"cas_number\")\ndef validate_cas_number(cls, value):\n    pattern = re.compile(r\"^\\d{2,6}-\\d{2}-\\d{1}$\")\n    if not re.match(pattern, value):\n        raise ValueError(\n            \"Invalid CAS number format. It should be 2-6 digits followed by a hyphen, then 2 digits, and another hyphen followed by 1 digit.\"\n        )\n    return value\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/core.html#himatcal.recipes.mol.core.cas2xyz","title":"cas2xyz","text":"<pre><code>cas2xyz(CAS_ID, relax_atoms=True)\n</code></pre> <p>Converts a CAS ID into an XYZ file format representation of the corresponding molecule.</p> <p>This function retrieves molecular data from the Common Chemistry API using the provided CAS ID, constructs a molecular structure, and optionally relaxes the atomic positions before saving the structure to an XYZ file.</p> <p>Args:     CAS_ID (str): The Chemical Abstracts Service identifier for the desired molecule.     relax_atoms (bool): A flag indicating whether to relax the atomic positions before saving. Defaults to True.</p> <p>Returns:     None</p> <p>Raises:     ValueError: If the CAS ID is invalid or if the API call fails.</p> <p>Examples:     cas2xyz(\"50-00-0\")  # Converts the CAS ID for formaldehyde to an XYZ file.</p> Source code in <code>himatcal/recipes/mol/core.py</code> <pre><code>def cas2xyz(CAS_ID, relax_atoms=True):\n    \"\"\"\n    Converts a CAS ID into an XYZ file format representation of the corresponding molecule.\n\n    This function retrieves molecular data from the Common Chemistry API using the provided CAS ID, constructs a molecular structure, and optionally relaxes the atomic positions before saving the structure to an XYZ file.\n\n    Args:\n        CAS_ID (str): The Chemical Abstracts Service identifier for the desired molecule.\n        relax_atoms (bool): A flag indicating whether to relax the atomic positions before saving. Defaults to True.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If the CAS ID is invalid or if the API call fails.\n\n    Examples:\n        cas2xyz(\"50-00-0\")  # Converts the CAS ID for formaldehyde to an XYZ file.\n    \"\"\"\n    sources = [\n        f\"https://commonchemistry.cas.org/api/detail?cas_rn={CAS_ID}\",\n        f\"https://www.chemicalbook.com/CAS/mol/{CAS_ID}.mol\",\n        f\"https://www.chemicalbook.com/CAS/20210305/MOL/{CAS_ID}.mol\",\n        f\"https://www.chemicalbook.com/CAS/20210111/MOL/{CAS_ID}.mol\",\n        f\"https://www.chemicalbook.com/CAS/20180601/MOL/{CAS_ID}.mol\",\n        f\"https://www.chemicalbook.com/CAS/20150408/MOL/{CAS_ID}.mol\",\n        f\"https://www.chemicalbook.com/CAS/20200515/MOL/{CAS_ID}.mol\",\n        f\"https://www.chemicalbook.com/CAS/20211123/MOL/{CAS_ID}.mol\",\n        f\"https://www.chemicalbook.com/CAS/20200331/MOL/{CAS_ID}.mol\",\n    ]\n\n    mol = None\n    for source in sources:\n        try:\n            if \"commonchemistry\" in source:\n                result_dict = json.loads(consumeApi(source))\n                mol = Chem.MolFromInchi(result_dict[\"inchi\"])\n            else:\n                request = urllib.request.Request(\n                    source, headers={\"User-Agent\": \"Mozilla/5.0\"}\n                )\n                response = urllib.request.urlopen(request)\n                if response.status == 200:\n                    mol_file_content = response.read().decode(\"utf-8\")\n                    mol = Chem.MolFromMolBlock(mol_file_content, removeHs=False)\n            if mol:\n                break\n        except Exception:\n            # print(f\"Failed to retrieve data from {source}: {e}\")\n            continue\n\n    if not mol:\n        try:\n            mol = get_molecular_structure(CAS_ID)\n        except Exception as e:\n            raise ValueError(\n                f\"Could not retrieve molecular data for CAS ID {CAS_ID}\"\n            ) from e\n\n    mol = Chem.AddHs(mol, addCoords=True)\n    AllChem.EmbedMultipleConfs(mol, numConfs=10)\n    if relax_atoms:\n        atoms = rdkit2ase(mol)\n        atoms_relaxed = crest_relax(atoms)\n        write(f\"{CAS_ID}.xyz\", atoms_relaxed)\n    else:\n        Chem.MolToXYZFile(mol, f\"{CAS_ID}.xyz\")\n    with Path.open(Path(f\"{CAS_ID}.xyz\")) as file:\n        return file.read()\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/core.html#himatcal.recipes.mol.core.cas_to_smiles","title":"cas_to_smiles","text":"<pre><code>cas_to_smiles(cas_number: str, source: Literal['pubchem', 'cirpy'] = 'cirpy')\n</code></pre> <p>convert cas to smiles using nci api</p> Source code in <code>himatcal/recipes/mol/core.py</code> <pre><code>def cas_to_smiles(cas_number: str, source: Literal[\"pubchem\", \"cirpy\"] = \"cirpy\"):\n    \"\"\"\n    convert cas to smiles using nci api\n    \"\"\"\n    # * validize the cas_number\n    cas_number = CASNumber(cas_number=cas_number).cas_number\n\n    if source == \"cirpy\":\n        url = f\"https://cactus.nci.nih.gov/chemical/structure/{cas_number}/smiles\"\n\n        try:\n            response = requests.get(url)\n            response.raise_for_status()\n            smiles = response.text.strip()\n            return smiles or None\n\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching data for CAS {cas_number}: {e}\")\n            return None\n    elif source == \"pubchem\":\n        url = f\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/{cas_number}/property/IsomericSMILES/JSON\"\n\n        try:\n            response = requests.get(url)\n            response.raise_for_status()\n            data = response.json()\n\n            return data[\"PropertyTable\"][\"Properties\"][0][\"IsomericSMILES\"]\n        except requests.exceptions.RequestException as e:\n            return f\"Error fetching data: {e}\"\n        except (KeyError, IndexError):\n            return \"CAS number not found or SMILES not available\"\n    else:\n        return None\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/core.html#himatcal.recipes.mol.core.consumeApi","title":"consumeApi","text":"<pre><code>consumeApi(urlPath)\n</code></pre> Source code in <code>himatcal/recipes/mol/core.py</code> <pre><code>def consumeApi(urlPath):\n    dataResponse = requests.get(urlPath)\n    return None if (dataResponse.status_code != 200) else dataResponse.text\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/core.html#himatcal.recipes.mol.core.get_molecular_structure","title":"get_molecular_structure","text":"<pre><code>get_molecular_structure(molecular_cas: str, write_mol: bool = True, chemspider_api: str = CHEMSPIDER_API_KEY)\n</code></pre> <p>Get molecular structure from CAS number, using chemspipy from RSC ChemSpider.</p> <p>This function retrieves the molecular structure corresponding to the provided CAS number from ChemSpider, processes it, and optionally writes it to a file in XYZ format.</p> <p>Args:     molecular_cas (str): The CAS number of the molecule.     write_mol (str | None): The file name to write the molecular structure to in XYZ format. Defaults to None.     chemspider_api (str): The ChemSpider API key. Defaults to the value in SETTINGS.CHEMSPIDER_API_KEY.</p> <p>Returns:     None</p> Source code in <code>himatcal/recipes/mol/core.py</code> <pre><code>def get_molecular_structure(\n    molecular_cas: str,\n    write_mol: bool = True,\n    chemspider_api: str = SETTINGS.CHEMSPIDER_API_KEY,\n):\n    \"\"\"\n    Get molecular structure from CAS number, using chemspipy from RSC ChemSpider.\n\n    This function retrieves the molecular structure corresponding to the provided CAS number from ChemSpider, processes it, and optionally writes it to a file in XYZ format.\n\n    Args:\n        molecular_cas (str): The CAS number of the molecule.\n        write_mol (str | None): The file name to write the molecular structure to in XYZ format. Defaults to None.\n        chemspider_api (str): The ChemSpider API key. Defaults to the value in SETTINGS.CHEMSPIDER_API_KEY.\n\n    Returns:\n        None\n    \"\"\"\n\n    cs = ChemSpider(chemspider_api)\n    c1 = cs.search(molecular_cas)[0]\n    try:\n        mol_file = StringIO(c1.mol_3d)\n        mol = Chem.MolFromMolBlock(mol_file.getvalue(), removeHs=False)\n        mol = Chem.AddHs(mol, addCoords=True)\n        if write_mol:\n            Chem.MolToXYZFile(mol, f\"{molecular_cas}.xyz\")\n        return mol\n    except Exception as e:\n        return f\"Unexpected error: {e}\"\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/core.html#himatcal.recipes.mol.core.relax_mol","title":"relax_mol","text":"<pre><code>relax_mol(mol: Atoms, chg: int = 0, mult: int = 1, method: str = 'crest', **kwargs)\n</code></pre> <p>Relax the molecular structure using the specified method.</p> <p>This function relaxes the atomic positions of the provided molecular structure using the specified method.</p> <p>Args:     mol (Atoms): The molecular structure to relax.     method (str): The relaxation method to use. Defaults to 'crest'.     **kwargs: Additional keyword arguments for the relaxation method.</p> <p>Returns:     Atoms: The relaxed molecular structure.</p> <p>Raises:     ValueError: If the relaxation method is not supported.</p> <p>Examples:     relax_mol(mol, method='crest')  # Relaxes the molecular structure using the CREST method.</p> Source code in <code>himatcal/recipes/mol/core.py</code> <pre><code>def relax_mol(mol: Atoms, chg: int = 0, mult: int = 1, method: str = \"crest\", **kwargs):\n    \"\"\"\n    Relax the molecular structure using the specified method.\n\n    This function relaxes the atomic positions of the provided molecular structure using the specified method.\n\n    Args:\n        mol (Atoms): The molecular structure to relax.\n        method (str): The relaxation method to use. Defaults to 'crest'.\n        **kwargs: Additional keyword arguments for the relaxation method.\n\n    Returns:\n        Atoms: The relaxed molecular structure.\n\n    Raises:\n        ValueError: If the relaxation method is not supported.\n\n    Examples:\n        relax_mol(mol, method='crest')  # Relaxes the molecular structure using the CREST method.\n    \"\"\"\n    if method == \"crest\":\n        return crest_relax(mol, chg=chg, mult=mult, **kwargs)\n    else:\n        raise ValueError(f\"Relaxation method '{method}' is not supported\")\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html","title":"pubgrep","text":"<p>This module contains code for interacting with the power user interface of the PubChem database and different related functions.</p> <p>https://github.com/grimme-lab/PubGrep/blob/main/pubgrep/pubgrep.py</p>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound","title":"Compound","text":"<pre><code>Compound(name: str, cid: str, wdir: Path, xtb_path: Path, hlgap_thr: float, verbosity: int)\n</code></pre> <p>This class handles everything related to a compound.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    cid: str,\n    wdir: Path,\n    xtb_path: Path,\n    hlgap_thr: float,\n    verbosity: int,\n):\n    \"\"\"\n    This function is used to initialize the compound object.\n    \"\"\"\n    self.name = name\n    self.cid = cid\n    self.wdir = wdir\n    self.xtb_path: Path = xtb_path\n    self.hlgap_thr: float = hlgap_thr\n    self.verbosity = verbosity\n    self.struc: Path | None = None\n    self.chrg: int | None = None\n    self.hlgap: float | None = None\n    self.logp: float | None = None\n    self.numatoms: int | None = None\n\n    # &gt; Create the directory for the compound\n    self.wdir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.chrg","title":"chrg  <code>instance-attribute</code>","text":"<pre><code>chrg: int | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.cid","title":"cid  <code>instance-attribute</code>","text":"<pre><code>cid = cid\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.hlgap","title":"hlgap  <code>instance-attribute</code>","text":"<pre><code>hlgap: float | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.hlgap_thr","title":"hlgap_thr  <code>instance-attribute</code>","text":"<pre><code>hlgap_thr: float = hlgap_thr\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.logp","title":"logp  <code>instance-attribute</code>","text":"<pre><code>logp: float | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.numatoms","title":"numatoms  <code>instance-attribute</code>","text":"<pre><code>numatoms: int | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.struc","title":"struc  <code>instance-attribute</code>","text":"<pre><code>struc: Path | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.verbosity","title":"verbosity  <code>instance-attribute</code>","text":"<pre><code>verbosity = verbosity\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.wdir","title":"wdir  <code>instance-attribute</code>","text":"<pre><code>wdir = wdir\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.xtb_path","title":"xtb_path  <code>instance-attribute</code>","text":"<pre><code>xtb_path: Path = xtb_path\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def __str__(self):\n    comp_string = f\"{self.cid}\" + f\"\\t{self.name}\"\n    if self.struc:\n        comp_string += f\"\\t{self.struc.resolve()}\"\n    if self.numatoms is not None:\n        comp_string += f\"\\t{self.numatoms}\"\n    if self.logp is not None:\n        comp_string += f\"\\t{self.logp}\"\n    if self.chrg is not None:\n        comp_string += f\"\\t{self.chrg}\"\n    if self.hlgap is not None:\n        comp_string += f\"\\t{self.hlgap:.3f}\"\n\n    return comp_string\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.convert_structure","title":"convert_structure","text":"<pre><code>convert_structure(suffix: str)\n</code></pre> <p>Conversion of a structure format into another. Compile the mctc-convert from https://github.com/grimme-lab/mctc-lib and add it to the PATH.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def convert_structure(self, suffix: str):\n    \"\"\"\n    Conversion of a structure format into another.\n    Compile the mctc-convert from https://github.com/grimme-lab/mctc-lib and add it to the PATH.\n    \"\"\"\n    if self.struc:\n        sp.run(\n            [\n                \"mctc-convert\",\n                self.struc.name,\n                self.struc.with_suffix(suffix).name,\n                \"--normalize\",\n            ],\n            check=True,\n            stdout=sp.PIPE,\n            stderr=sp.PIPE,\n            cwd=self.struc.parent,\n        )\n        self.struc = self.struc.with_suffix(suffix)\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.opt_structure","title":"opt_structure","text":"<pre><code>opt_structure()\n</code></pre> <p>This function is used to optimize the structure of the compound.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def opt_structure(self):\n    \"\"\"\n    This function is used to optimize the structure of the compound.\n    \"\"\"\n    xtb_out, _, returncode = run_xtb(\n        xtb_path=self.xtb_path,\n        calc_dir=self.wdir,\n        args=[\n            self.struc.name,\n            \"--opt\",\n            \"--gfn\",\n            \"2\",\n            \"--ceasefiles\",\n        ],\n    )\n\n    # delete unnecessary files\n    files_to_delete = [\n        \".xtboptok\",\n    ]\n    for fdel in files_to_delete:\n        if Path(f\"{self.wdir}/{fdel}\").exists():\n            Path(f\"{self.wdir}/{fdel}\").unlink()\n    # define old and new file names\n    xtb_opt_file = Path(f\"{self.wdir}/xtbopt{self.struc.suffix}\")\n    strucfile_opt = Path(f\"{self.wdir}/{self.struc.stem}_opt{self.struc.suffix}\")\n\n    # check if the optimization was successful\n    if returncode != 0 or not xtb_opt_file.exists():\n        raise XtbFailure(\"xTB optimization failed.\")\n    self.hlgap = get_hlgap_from_xtb_output(xtb_out, self.verbosity)\n    if self.hlgap &lt; self.hlgap_thr:\n        raise ValueError(\n            f\"HOMO-LUMO gap too small ({self.hlgap} (is) vs. {self.hlgap_thr} (threshold) eV)\"\n        )\n\n    # rename the optimized structure\n    xtb_opt_file.rename(strucfile_opt)\n    self.struc = strucfile_opt\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.print_csv_header","title":"print_csv_header","text":"<pre><code>print_csv_header()\n</code></pre> <p>This function is used to print the header of the csv file.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def print_csv_header(self):\n    \"\"\"\n    This function is used to print the header of the csv file.\n    \"\"\"\n    header_string = \"CID\\tName\"\n    if self.struc:\n        header_string += \"\\tStructure Path\"\n    if self.numatoms is not None:\n        header_string += \"\\tNumber of Atoms\"\n    if self.logp is not None:\n        header_string += \"\\tLogP\"\n    if self.chrg is not None:\n        header_string += \"\\tTotal Charge\"\n    if self.hlgap is not None:\n        header_string += \"\\tHOMO-LUMO gap\"\n    return header_string\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.retrieve_3d_sdf","title":"retrieve_3d_sdf","text":"<pre><code>retrieve_3d_sdf()\n</code></pre> <p>This function is used to retrieve the 3D conformer data from the PubChem database.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def retrieve_3d_sdf(self):\n    \"\"\"\n    This function is used to retrieve the 3D conformer data from the PubChem database.\n    \"\"\"\n    response = requests.get(\n        f\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{self.cid}/sdf?record_type=3d\",\n        timeout=10,\n    )\n    if \"PUGREST.NotFound\" in response.text:\n        self.twodthreed()\n    else:\n        with open(self.wdir / f\"{self.cid}.sdf\", \"w\", encoding=\"utf-8\") as file:\n            file.write(response.text)\n\n    if self.hlgap is None or self.chrg is None:\n        xtb_out, _, _ = run_xtb(\n            xtb_path=self.xtb_path,\n            calc_dir=self.wdir,\n            args=[f\"{self.cid}.sdf\", \"--gfn\", \"2\", \"--sp\", \"--ceasefiles\"],\n        )\n        if self.numatoms is None:\n            pass\n        if self.hlgap is None:\n            self.hlgap = get_hlgap_from_xtb_output(xtb_out, self.verbosity)\n        if self.chrg is None:\n            self.chrg = get_charge_from_xtb_output(xtb_out, self.verbosity)\n        with open(Path(f\"{self.wdir}/.CHRG\"), \"w\", encoding=\"UTF-8\") as f:\n            f.write(str(self.chrg) + \"\\n\")\n\n    if self.hlgap &lt; self.hlgap_thr:\n        raise ValueError(\n            f\"HOMO-LUMO gap too small ({self.hlgap} (is) vs. {self.hlgap_thr} (threshold) eV)\"\n        )\n\n    self.struc = self.wdir / f\"{self.cid}.sdf\"\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.retrieve_logp","title":"retrieve_logp","text":"<pre><code>retrieve_logp()\n</code></pre> <p>This function is used to retrieve the LogP value from the PubChem database.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def retrieve_logp(self):\n    \"\"\"\n    This function is used to retrieve the LogP value from the PubChem database.\n    \"\"\"\n    response = requests.get(\n        f\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{self.cid}/property/XlogP/txt\",  # pylint: disable=line-too-long\n        timeout=10,\n    )\n    logp = response.text.strip()\n    if \"PUGREST.BadRequest\" in logp or logp == \"\":\n        raise ValueError(f\"LogP not found for {self.cid}.\")\n    float(logp)\n    self.logp = logp\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>This function is used to convert the compound object to a dictionary.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    This function is used to convert the compound object to a dictionary.\n    \"\"\"\n    comp_dict = {\n        \"CID\": self.cid,\n        \"Name\": self.name,\n        \"Structure Path\": self.struc.resolve() if self.struc else None,\n        \"Number of Atoms\": self.numatoms,\n        \"LogP\": self.logp,\n        \"Total Charge\": self.chrg,\n        \"HOMO-LUMO gap\": self.hlgap,\n    }\n    return comp_dict\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.Compound.twodthreed","title":"twodthreed","text":"<pre><code>twodthreed()\n</code></pre> <p>This function is used to convert the 2D structure to 3D structure.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def twodthreed(self):\n    \"\"\"\n    This function is used to convert the 2D structure to 3D structure.\n    \"\"\"\n    if self.verbosity &gt; 2:\n        print(\n            f\"No 3D Conformer Data found for CID {self.cid}. \"\n            + \"Retrieving 2D Conformer Data instead.\"\n        )\n    response = requests.get(\n        f\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{self.cid}/sdf\",\n        timeout=10,\n    )\n    with open(f\"{self.wdir}/{self.cid}_2d.sdf\", \"w\", encoding=\"utf-8\") as file:\n        file.write(response.text)\n\n    # Convert 2D to 3D\n    try:\n        xtb_args = [\n            f\"{self.cid}_2d.sdf\",\n            \"--gfn\",\n            \"2\",\n            \"--sp\",\n            \"--ceasefiles\",\n        ]\n        xtb_out, _, exitcode = run_xtb(\n            xtb_path=self.xtb_path, calc_dir=self.wdir, args=xtb_args\n        )\n        if exitcode == 0 and \"converted geometry written to\" in xtb_out:\n            if self.verbosity &gt; 1:\n                print(\"3D conversion successful.\")\n            Path(f\"{self.wdir}/gfnff_convert.sdf\").rename(\n                f\"{self.wdir}/{self.cid}.sdf\"\n            )\n        else:\n            raise XtbFailure(\n                f\"Error in 2D to 3D structure conversion for CID {self.cid}.\"\n            )\n        self.hlgap = get_hlgap_from_xtb_output(xtb_out, self.verbosity)\n        self.chrg = get_charge_from_xtb_output(\n            xtb_out=xtb_out, verbosity=self.verbosity\n        )\n        with open(Path(f\"{self.wdir}/.CHRG\"), \"w\", encoding=\"UTF-8\") as f:\n            f.write(str(self.chrg) + \"\\n\")\n    finally:\n        files_to_delete = [\n            \".sccnotconverged\",\n            \"convert.log\",\n            \"mdrestart\",\n            \"xtb.trj\",\n            \"xtbmdok\",\n        ]\n        for fdel in files_to_delete:\n            if Path(f\"{self.wdir}/{fdel}\").exists():\n                Path(f\"{self.wdir}/{fdel}\").unlink()\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.XtbFailure","title":"XtbFailure","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the xTB calculation does not provide the expected output.</p>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.cli","title":"cli","text":"<pre><code>cli()\n</code></pre> <p>This function is used to parse the command line arguments.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def cli():\n    \"\"\"\n    This function is used to parse the command line arguments.\n    \"\"\"\n    try:\n        args = get_args()\n        verbosity = args.verbosity\n        compounds = args.compounds\n        input_format = args.input\n        output_format = args.output\n        optimization = args.opt\n        skip = args.skip\n        basedir = args.basedir\n        hlgap_thr = args.hlgap_thr\n\n        whichxtb = shutil.which(\"xtb\")\n        if not whichxtb:\n            raise ValueError(\n                \"'xtb' seems not to be in the $PATH. Check if xtb is installed in your environment/on your system.\"\n            )\n        xtb_path = Path(whichxtb).resolve()\n\n        pubgrep(\n            xtb_path=xtb_path,\n            basedir=basedir,\n            compounds=compounds,\n            input_format=input_format,\n            output_format=output_format,\n            optimization=optimization,\n            hlgap_thr=hlgap_thr,\n            skip=skip,\n            verbosity=verbosity,\n        )\n        return 0\n    except (ValueError, XtbFailure) as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n        return 1\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.get_args","title":"get_args","text":"<pre><code>get_args() -&gt; Namespace\n</code></pre> <p>This function is used to parse the command line arguments.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def get_args() -&gt; argparse.Namespace:\n    \"\"\"\n    This function is used to parse the command line arguments.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=header()\n        + \"\\nThis program searches CIDs from the PubChem Database based on a list of compounds.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        \"compounds\",\n        help=\"List of compounds to search for.\",\n        nargs=\"+\",\n        type=str,\n        default=None,\n        action=\"store\",\n    )\n    parser.add_argument(\n        \"--input\",\n        default=\"name\",\n        choices=[\"name\", \"cid\", \"smiles\", \"cas\", \"inchi\"],\n        help=\"Input format\",\n    )\n    parser.add_argument(\n        \"--output\", default=\"sdf\", choices=[\"sdf\", \"logP\", \"list\"], help=\"Output format\"\n    )\n    parser.add_argument(\n        \"--skip\", action=\"store_true\", help=\"Skip PubChem server testing\"\n    )\n    parser.add_argument(\n        \"--verbosity\",\n        type=int,\n        default=0,\n        choices=[0, 1, 2, 3],\n        help=\"Verbosity level\",\n        required=False,\n    )\n    parser.add_argument(\n        \"--opt\",\n        action=\"store_true\",\n        help=\"Optimize the structure of the compound\",\n        required=False,\n        default=False,\n    )\n    parser.add_argument(\n        \"--basedir\",\n        type=Path,\n        default=\"pubchem_compounds\",\n        help=\"Base directory for the compound data\",\n        required=False,\n    )\n    parser.add_argument(\n        \"--hlgap_thr\",\n        type=float,\n        default=0.5,\n        help=\"Threshold for the HOMO-LUMO gap\",\n        required=False,\n    )\n    return parser.parse_args()\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.get_charge_from_xtb_output","title":"get_charge_from_xtb_output","text":"<pre><code>get_charge_from_xtb_output(xtb_out: str, verbosity: int) -&gt; int\n</code></pre> <p>This function is used to extract the total charge from the xtb output.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def get_charge_from_xtb_output(xtb_out: str, verbosity: int) -&gt; int:\n    \"\"\"\n    This function is used to extract the total charge from the xtb output.\n    \"\"\"\n    # load fourth entry of a line with \":: total charge\" of xtb.out into a variable\n    chrg = None\n    for line in xtb_out.split(\"\\n\"):\n        if \":: total charge\" in line:\n            chrg = round(float(line.split()[3]))\n            break\n    if chrg is None:\n        raise ValueError(\"Total charge could not be determined.\")\n    if verbosity &gt; 3:\n        print(\" \" * 3 + f\"Total charge: {chrg:6d}\")\n    return chrg\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.get_hlgap_from_xtb_output","title":"get_hlgap_from_xtb_output","text":"<pre><code>get_hlgap_from_xtb_output(output: str, verbosity: int) -&gt; float\n</code></pre> <p>This function is used to check if the HOMO-LUMO gap of an xtb output is large enough.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def get_hlgap_from_xtb_output(output: str, verbosity: int) -&gt; float:\n    \"\"\"\n    This function is used to check if the HOMO-LUMO gap of an xtb output is large enough.\n    \"\"\"\n    hlgap = None\n    for line in output.split(\"\\n\"):\n        if \"HOMO-LUMO GAP\" in line:\n            hlgap = float(line.split()[3])\n            break\n    if hlgap is None:\n        raise ValueError(\"HOMO-LUMO gap not determined.\")\n    if verbosity &gt; 3:\n        print(\" \" * 3 + f\"HOMO-LUMO gap: {hlgap:5f}\")\n    return hlgap\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.get_numatoms_from_xyz","title":"get_numatoms_from_xyz","text":"<pre><code>get_numatoms_from_xyz(xyz: str, verbosity: int) -&gt; int\n</code></pre> <p>This function is used to extract the total charge from the xtb output.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def get_numatoms_from_xyz(xyz: str, verbosity: int) -&gt; int:\n    \"\"\"\n    This function is used to extract the total charge from the xtb output.\n    \"\"\"\n    nat = None\n    # get number of atoms from first line of XYZ file\n    nat = int(xyz.split(\"\\n\")[0])\n    if verbosity &gt; 3:\n        print(\" \" * 3 + f\"Total number of atoms: {nat}\")\n    return nat\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.header","title":"header","text":"<pre><code>header() -&gt; str\n</code></pre> <p>This function is used to print the header of the program.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def header() -&gt; str:\n    \"\"\"\n    This function is used to print the header of the program.\n    \"\"\"\n    headerstr = (\n        \"---------------------------------------------------------------------\\n\"\n        f\"                          PubGrep {__version__}\\n\"\n        \"- This Program tries to search CIDs from the Pubchem Database based -\\n\"\n        \"- on a list of compounds given as Input. Afterwards it creates sdf  -\\n\"\n        \"-   Files for each Compound given in an appropriate subdirectory.   -\\n\"\n        \"-     If you are using this program extensively (like, a lot!)      -\\n\"\n        \"-   for your Research, please consider citing 10.1039/D3RA01705B    -\\n\"\n        \"-                          MS, MM, 2021-2024                        -\\n\"\n        \"---------------------------------------------------------------------\\n\\n\"\n    )\n    return headerstr\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.process_compound","title":"process_compound","text":"<pre><code>process_compound(comp: Compound, optimization: bool = False, verbosity: int = 0) -&gt; tuple[Compound, int]\n</code></pre> <p>This function is used to process the compound. It acts as a wrapper for the multiprocessing pool.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def process_compound(\n    comp: Compound, optimization: bool = False, verbosity: int = 0\n) -&gt; tuple[Compound, int]:\n    \"\"\"\n    This function is used to process the compound.\n    It acts as a wrapper for the multiprocessing pool.\n    \"\"\"\n    # &gt; Wait a random time to avoid overloading the server\n    time.sleep(random.uniform(0.0, 2.5))\n\n    # &gt; Retrieve the 3D structure\n    try:\n        if verbosity &gt; 3:\n            print(f\"Retrieving 3D structure for {comp.cid}.\")\n        comp.retrieve_3d_sdf()\n    except (XtbFailure, ValueError) as e:\n        if verbosity &gt; 1:\n            print(f\"Error in retrieving 3D structure for {comp.cid}. {e}\")\n        return comp, 1\n\n    # &gt; Convert the structure to the desired format\n    comp.convert_structure(\".xyz\")\n\n    # &gt; Get the number of atoms\n    with open(comp.struc, \"r\", encoding=\"utf-8\") as file:  # type: ignore\n        xyz = file.read()\n    comp.numatoms = get_numatoms_from_xyz(xyz, verbosity)\n\n    # &gt; Optimize the structure\n    if optimization:\n        try:\n            if verbosity &gt; 3:\n                print(f\"Optimizing structure for {comp.cid}.\")\n            comp.opt_structure()\n        except (XtbFailure, ValueError) as e:\n            if verbosity &gt; 1:\n                print(f\"Error in optimizing structure for {comp.cid}. {e}\")\n            return comp, 1\n\n    return comp, 0\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.pubgrep","title":"pubgrep","text":"<pre><code>pubgrep(xtb_path: Path, basedir: Path, compounds: list[str] | Path | str, input_format: str, output_format: str, optimization: bool, hlgap_thr: float, skip: bool, verbosity: int) -&gt; list[Compound]\n</code></pre> <p>This function is used to search the compounds in the PubChem database.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def pubgrep(\n    xtb_path: Path,\n    basedir: Path,\n    compounds: list[str] | Path | str,\n    input_format: str,\n    output_format: str,\n    optimization: bool,\n    hlgap_thr: float,\n    skip: bool,\n    verbosity: int,\n) -&gt; list[Compound]:\n    \"\"\"\n    This function is used to search the compounds in the PubChem database.\n    \"\"\"\n\n    if skip:\n        test_pubchem_server(verbosity)\n\n    # if len of compounds is 1, take it as a single compound\n    if isinstance(compounds, list):\n        if len(compounds) == 1:\n            compounds = compounds[0]\n\n    compound_list = []\n    if isinstance(compounds, list):\n        for compound in compounds:\n            compound_list.append(compound)\n    elif isinstance(compounds, Path) or Path(compounds).is_file():  # type: ignore\n        with open(compounds, \"r\", encoding=\"utf-8\") as file:  # type: ignore\n            compound_list = [line.strip() for line in file.readlines()]\n    elif isinstance(compounds, str):\n        compound_list.append(compounds)\n    else:\n        raise ValueError(\"Invalid input for compounds.\")\n\n    if len(compound_list) == 0:\n        raise ValueError(\"No compounds found in the input file.\")\n\n    found_compounds: list[Compound] = []\n    not_found_compounds: list[str] = []\n\n    for compound in compound_list:\n        result = search_compound(compound, input_format)\n        if input_format != \"cid\":\n            cid = result\n            name = compound\n        else:\n            cid = compound\n            name = result\n        if verbosity &gt; 3:\n            print(f\"Found CID {cid} for {name}.\")\n        if \"PUGREST.NotFound\" in result or \"PUGREST.BadRequest\" in result:\n            not_found_compounds.append(compound)\n        else:\n            comp = Compound(\n                name=name,\n                cid=cid,\n                wdir=Path(basedir / f\"{cid}\"),\n                xtb_path=xtb_path,\n                hlgap_thr=hlgap_thr,\n                verbosity=verbosity,\n            )\n            found_compounds.append(comp)\n            if verbosity &gt; 1:\n                print(comp)\n\n    failed_compounds = []\n    successful_compounds = []\n\n    if output_format == \"list\":\n        with open(\"found_compounds.csv\", \"w\", encoding=\"utf-8\") as file:\n            for comp in found_compounds:\n                print(comp, file=file)\n    elif output_format == \"sdf\":\n        wrap_process_compound = partial(\n            process_compound, optimization=optimization, verbosity=verbosity\n        )\n        if verbosity &gt; 3:\n            print(f\"Using {mp.cpu_count()} cores for processing.\")\n        with mp.Pool(processes=mp.cpu_count()) as pool:\n            for result in tqdm(\n                pool.imap(wrap_process_compound, found_compounds),\n                total=len(found_compounds),\n            ):\n                returncomp, status = result\n                if status == 0:\n                    successful_compounds.append(returncomp)\n                if status != 0:\n                    failed_compounds.append(returncomp)\n\n    elif output_format in [\"logp\", \"logP\"]:\n        for comp in found_compounds:\n            try:\n                if verbosity &gt; 3:\n                    print(f\"Retrieving LogP for {comp.cid}.\")\n                comp.retrieve_logp()\n            except ValueError as e:\n                if verbosity &gt; 1:\n                    print(f\"Error in retrieving LogP for {comp.cid}. {e}\")\n                failed_compounds.append(comp)\n                continue\n            successful_compounds.append(comp)\n    else:\n        raise ValueError(\"Invalid output format.\")\n\n    if successful_compounds:\n        successful_compounds.sort(key=lambda x: int(x.cid))\n        with open(\"compounds.csv\", \"w\", encoding=\"utf-8\") as file:\n            print(successful_compounds[0].print_csv_header(), file=file)\n            for comp in successful_compounds:\n                print(comp, file=file)\n    else:\n        raise ValueError(\"No compounds could be processed.\")\n\n    if not_found_compounds:\n        with open(\"not_found.compound\", \"w\", encoding=\"utf-8\") as file:\n            for compound in not_found_compounds:\n                file.write(f\"{compound}\\n\")\n\n    return successful_compounds\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.rawurlencode","title":"rawurlencode","text":"<pre><code>rawurlencode(string)\n</code></pre> <p>This function is used to encode the string to be used in the URL.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def rawurlencode(string):\n    \"\"\"\n    This function is used to encode the string to be used in the URL.\n    \"\"\"\n    return quote(string, safe=\"-_.~a-zA-Z0-9\")\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.run_xtb","title":"run_xtb","text":"<pre><code>run_xtb(xtb_path: Path, calc_dir: Path, args: list) -&gt; tuple\n</code></pre> <p>This function is used to run the xtb command.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def run_xtb(xtb_path: Path, calc_dir: Path, args: list) -&gt; tuple:\n    \"\"\"\n    This function is used to run the xtb command.\n    \"\"\"\n    singlecore = [\"-P\", \"1\"]\n    args = singlecore + args\n    try:\n        xtb_out = sp.run(\n            [xtb_path, *args],\n            check=True,\n            stdout=sp.PIPE,\n            stderr=sp.PIPE,\n            cwd=calc_dir,\n            timeout=180,\n        )\n        stdout = xtb_out.stdout.decode()\n        with open(calc_dir / \"xtb.out\", \"w\", encoding=\"utf-8\") as file:\n            file.write(stdout)\n        stderr = xtb_out.stderr.decode()\n        with open(calc_dir / \"xtb.err\", \"w\", encoding=\"utf-8\") as file:\n            file.write(stderr)\n        returncode = xtb_out.returncode\n    except sp.CalledProcessError as e:\n        with open(calc_dir / \"xtb.out\", \"w\", encoding=\"utf-8\") as file:\n            file.write(e.stdout.decode())\n        with open(calc_dir / \"xtb.err\", \"w\", encoding=\"utf-8\") as file:\n            print(\n                f\"Command '{e.cmd}' returned non-zero exit status {e.returncode}.\",\n                file=file,\n            )\n            file.write(e.stderr.decode())\n        stdout = e.stdout.decode()\n        stderr = e.stderr.decode()\n        returncode = e.returncode\n\n    return stdout, stderr, returncode\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.search_compound","title":"search_compound","text":"<pre><code>search_compound(compound, input_format)\n</code></pre> <p>This function is used to search the compound in the PubChem database.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def search_compound(compound, input_format):\n    \"\"\"\n    This function is used to search the compound in the PubChem database.\n    \"\"\"\n    base_url = \"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/\"\n    search_url = \"\"\n    if input_format == \"inchi\":\n        # Prepare the data payload\n        data = {\"inchi\": compound}\n        search_url = f\"{base_url}inchi/{rawurlencode(compound)}/cids/TXT\"\n    elif input_format == \"name\":\n        search_url = f\"{base_url}name/{rawurlencode(compound)}/cids/TXT\"\n    elif input_format == \"cid\":\n        search_url = f\"{base_url}cid/{compound}/property/IUPACname/TXT\"\n    elif input_format in [\"smile\", \"smiles\"]:\n        search_url = f\"{base_url}smiles/{rawurlencode(compound)}/cids/TXT\"\n    elif input_format in [\"cas\", \"regid\"]:\n        search_url = f\"{base_url}xref/RegistryID/{rawurlencode(compound)}/cids/TXT\"\n    else:\n        raise ValueError(\"Invalid input format.\")\n\n    if input_format != \"inchi\":\n        response = requests.get(search_url, timeout=10)\n    else:\n        response = requests.post(search_url, data=data, timeout=10)\n    return response.text.strip()\n</code></pre>"},{"location":"reference/himatcal/recipes/mol/pubgrep.html#himatcal.recipes.mol.pubgrep.test_pubchem_server","title":"test_pubchem_server","text":"<pre><code>test_pubchem_server(verbosity)\n</code></pre> <p>This function is used to test the connection to the PubChem server.</p> Source code in <code>himatcal/recipes/mol/pubgrep.py</code> <pre><code>def test_pubchem_server(verbosity):\n    \"\"\"\n    This function is used to test the connection to the PubChem server.\n    \"\"\"\n    response = requests.get(\n        \"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/1/cids/TXT\", timeout=10\n    )\n    if response.status_code == 200 and response.text.strip() == \"1\":\n        if verbosity &gt; 3:\n            print(\"PubChem Server is working fine.\")\n    else:\n        raise ConnectionError(\n            \"No connection could be established. Check if you have access to the internet.\"\n        )\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html","title":"ts","text":"<p>Transition state recipes for the NewtonNet code.</p>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.has_newtonnet","title":"has_newtonnet  <code>module-attribute</code>","text":"<pre><code>has_newtonnet = bool(find_spec('newtonnet'))\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.has_sella","title":"has_sella  <code>module-attribute</code>","text":"<pre><code>has_sella = bool(find_spec('sella'))\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebSchema","title":"NebSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebSchema.geodesic_results","title":"geodesic_results  <code>instance-attribute</code>","text":"<pre><code>geodesic_results: list[Atoms]\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebSchema.neb_results","title":"neb_results  <code>instance-attribute</code>","text":"<pre><code>neb_results: dict\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebSchema.relax_product","title":"relax_product  <code>instance-attribute</code>","text":"<pre><code>relax_product: OptSchema\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebSchema.relax_reactant","title":"relax_reactant  <code>instance-attribute</code>","text":"<pre><code>relax_reactant: OptSchema\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebTsSchema","title":"NebTsSchema","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebTsSchema.geodesic_results","title":"geodesic_results  <code>instance-attribute</code>","text":"<pre><code>geodesic_results: list[Atoms]\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebTsSchema.neb_results","title":"neb_results  <code>instance-attribute</code>","text":"<pre><code>neb_results: dict\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebTsSchema.relax_product","title":"relax_product  <code>instance-attribute</code>","text":"<pre><code>relax_product: OptSchema\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebTsSchema.relax_reactant","title":"relax_reactant  <code>instance-attribute</code>","text":"<pre><code>relax_reactant: OptSchema\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.NebTsSchema.ts_results","title":"ts_results  <code>instance-attribute</code>","text":"<pre><code>ts_results: OptSchema\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts._get_hessian","title":"_get_hessian","text":"<pre><code>_get_hessian(atoms: Atoms) -&gt; NDArray\n</code></pre> <p>Calculate and retrieve the Hessian matrix for the given molecular configuration.</p> <p>This function takes an ASE Atoms object representing a molecular configuration and uses the NewtonNet machine learning calculator to calculate the Hessian matrix. The calculated Hessian matrix is then returned.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object representing the molecular configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray</code>           \u2013            <p>The calculated Hessian matrix, reshaped into a 2D array.</p> </li> </ul> Source code in <code>himatcal/recipes/newtonnet/ts.py</code> <pre><code>def _get_hessian(atoms: Atoms) -&gt; NDArray:\n    \"\"\"\n    Calculate and retrieve the Hessian matrix for the given molecular configuration.\n\n    This function takes an ASE Atoms object representing a molecular\n    configuration and uses the NewtonNet machine learning calculator to\n    calculate the Hessian matrix. The calculated Hessian matrix is then\n    returned.\n\n    Parameters\n    ----------\n    atoms\n        The ASE Atoms object representing the molecular configuration.\n\n    Returns\n    -------\n    NDArray\n        The calculated Hessian matrix, reshaped into a 2D array.\n    \"\"\"\n    settings = get_settings()\n    ml_calculator = NewtonNet(\n        model_path=settings.NEWTONNET_MODEL_PATH,\n        settings_path=settings.NEWTONNET_CONFIG_PATH,\n        hess_method=\"autograd\",\n    )\n    ml_calculator.calculate(atoms)\n\n    return ml_calculator.results[\"hessian\"].reshape((-1, 3 * len(atoms)))\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.geodesic_job","title":"geodesic_job","text":"<pre><code>geodesic_job(reactant_atoms: Atoms, product_atoms: Atoms, relax_job_kwargs: dict[str, Any] | None = None, calc_kwargs: dict[str, Any] | None = None, geodesic_interpolate_kwargs: dict[str, Any] | None = None) -&gt; dict\n</code></pre> <p>Perform a quasi-IRC job using the given reactant and product atoms objects.</p> <p>Parameters:</p> <ul> <li> <code>reactant_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the reactant structure.</p> </li> <li> <code>product_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the product structure.</p> </li> <li> <code>relax_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the relax_job function, by default None.</p> </li> <li> <code>calc_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the NewtonNet calculator, by default None.</p> </li> <li> <code>geodesic_interpolate_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the geodesic_interpolate function, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary containing the following keys:     - 'relax_reactant': Summary of the relaxed reactant structure.     - 'relax_product': Summary of the relaxed product structure.     - 'geodesic_results': The interpolated images between reactant and product.     - 'highest_e_atoms': ASE atoms object for the highest energy structure for the geodesic path</p> </li> </ul> Source code in <code>himatcal/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\ndef geodesic_job(\n    reactant_atoms: Atoms,\n    product_atoms: Atoms,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    calc_kwargs: dict[str, Any] | None = None,\n    geodesic_interpolate_kwargs: dict[str, Any] | None = None,\n) -&gt; dict:\n    \"\"\"\n    Perform a quasi-IRC job using the given reactant and product atoms objects.\n\n    Parameters\n    ----------\n    reactant_atoms\n        The Atoms object representing the reactant structure.\n    product_atoms\n        The Atoms object representing the product structure.\n    relax_job_kwargs\n        Keyword arguments to use for the relax_job function, by default None.\n    calc_kwargs\n        Keyword arguments for the NewtonNet calculator, by default None.\n    geodesic_interpolate_kwargs\n        Keyword arguments for the geodesic_interpolate function, by default None.\n\n    Returns\n    -------\n    dict\n        A dictionary containing the following keys:\n            - 'relax_reactant': Summary of the relaxed reactant structure.\n            - 'relax_product': Summary of the relaxed product structure.\n            - 'geodesic_results': The interpolated images between reactant and product.\n            - 'highest_e_atoms': ASE atoms object for the highest energy structure for the geodesic path\n    \"\"\"\n    relax_job_kwargs = relax_job_kwargs or {}\n    geodesic_interpolate_kwargs = geodesic_interpolate_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": None,\n    }\n\n    geodesic_defaults = {\"n_images\": 20}\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    calc_flags[\"hess_method\"] = None\n    geodesic_interpolate_flags = recursive_dict_merge(\n        geodesic_defaults, geodesic_interpolate_kwargs\n    )\n\n    # Define calculator\n    reactant_atoms.calc = NewtonNet(**calc_flags)\n    product_atoms.calc = NewtonNet(**calc_flags)\n\n    # Run IRC\n    relax_summary_r = strip_decorator(relax_job)(reactant_atoms, **relax_job_kwargs)\n    relax_summary_p = strip_decorator(relax_job)(product_atoms, **relax_job_kwargs)\n\n    images = _geodesic_interpolate_wrapper(\n        relax_summary_r[\"atoms\"].copy(),\n        relax_summary_p[\"atoms\"].copy(),\n        **geodesic_interpolate_flags,\n    )\n\n    potential_energies = []\n    for image in images:\n        image.calc = NewtonNet(**calc_flags)\n        potential_energies.append(image.get_potential_energy())\n\n    ts_index = np.argmax(potential_energies)\n    highest_e_atoms = images[ts_index]\n\n    return {\n        \"relax_reactant\": relax_summary_r,\n        \"relax_product\": relax_summary_p,\n        \"geodesic_results\": images,\n        \"highest_e_atoms\": highest_e_atoms,\n    }\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.geodesic_ts_job","title":"geodesic_ts_job","text":"<pre><code>geodesic_ts_job(reactant_atoms: Atoms, product_atoms: Atoms, relax_job_kwargs: dict[str, Any] | None = None, calc_kwargs: dict[str, Any] | None = None, geodesic_interpolate_kwargs: dict[str, Any] | None = None, ts_job_kwargs: dict[str, Any] | None = None) -&gt; NebTsSchema\n</code></pre> <p>Perform a quasi-IRC job using the given reactant and product atoms objects.</p> <p>Parameters:</p> <ul> <li> <code>reactant_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the reactant structure.</p> </li> <li> <code>product_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the product structure.</p> </li> <li> <code>relax_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the relax_job function, by default None.</p> </li> <li> <code>calc_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the NewtonNet calculator, by default None.</p> </li> <li> <code>geodesic_interpolate_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the geodesic_interpolate function, by default None.</p> </li> <li> <code>ts_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for ts optimizer, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NebTsSchema</code>           \u2013            <p>A dictionary containing the following keys:     - 'relax_reactant': Summary of the relaxed reactant structure.     - 'relax_product': Summary of the relaxed product structure.     - 'geodesic_results': The interpolated images between reactant and product.     - 'neb_results': Summary of the NEB optimization.     - 'ts_results': Summary of the transition state optimization.</p> </li> </ul> Source code in <code>himatcal/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\ndef geodesic_ts_job(\n    reactant_atoms: Atoms,\n    product_atoms: Atoms,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    calc_kwargs: dict[str, Any] | None = None,\n    geodesic_interpolate_kwargs: dict[str, Any] | None = None,\n    ts_job_kwargs: dict[str, Any] | None = None,\n) -&gt; NebTsSchema:\n    \"\"\"\n    Perform a quasi-IRC job using the given reactant and product atoms objects.\n\n    Parameters\n    ----------\n    reactant_atoms\n        The Atoms object representing the reactant structure.\n    product_atoms\n        The Atoms object representing the product structure.\n    relax_job_kwargs\n        Keyword arguments to use for the relax_job function, by default None.\n    calc_kwargs\n        Keyword arguments for the NewtonNet calculator, by default None.\n    geodesic_interpolate_kwargs\n        Keyword arguments for the geodesic_interpolate function, by default None.\n    ts_job_kwargs\n        Keyword arguments for ts optimizer, by default None.\n\n    Returns\n    -------\n    NebTsSchema\n        A dictionary containing the following keys:\n            - 'relax_reactant': Summary of the relaxed reactant structure.\n            - 'relax_product': Summary of the relaxed product structure.\n            - 'geodesic_results': The interpolated images between reactant and product.\n            - 'neb_results': Summary of the NEB optimization.\n            - 'ts_results': Summary of the transition state optimization.\n    \"\"\"\n    relax_job_kwargs = relax_job_kwargs or {}\n    ts_job_kwargs = ts_job_kwargs or {}\n    geodesic_interpolate_kwargs = geodesic_interpolate_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": None,\n    }\n\n    geodesic_defaults = {\"n_images\": 20}\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    calc_flags[\"hess_method\"] = None\n    geodesic_interpolate_flags = recursive_dict_merge(\n        geodesic_defaults, geodesic_interpolate_kwargs\n    )\n\n    # Define calculator\n    reactant_atoms.calc = NewtonNet(**calc_flags)\n    product_atoms.calc = NewtonNet(**calc_flags)\n\n    # Run IRC\n    relax_summary_r = strip_decorator(relax_job)(reactant_atoms, **relax_job_kwargs)\n    relax_summary_p = strip_decorator(relax_job)(product_atoms, **relax_job_kwargs)\n\n    images = _geodesic_interpolate_wrapper(\n        relax_summary_r[\"atoms\"].copy(),\n        relax_summary_p[\"atoms\"].copy(),\n        **geodesic_interpolate_flags,\n    )\n\n    potential_energies = []\n    for image in images:\n        image.calc = NewtonNet(**calc_flags)\n        potential_energies.append(image.get_potential_energy())\n\n    ts_index = np.argmax(potential_energies)\n    ts_atoms = images[ts_index]\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    output = strip_decorator(ts_job)(ts_atoms, **ts_job_kwargs, **calc_flags)\n    return {\n        \"relax_reactant\": relax_summary_r,\n        \"relax_product\": relax_summary_p,\n        \"geodesic_results\": images,\n        \"ts_results\": output,\n    }\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.irc_job","title":"irc_job","text":"<pre><code>irc_job(atoms: Atoms, direction: Literal['forward', 'reverse'] = 'forward', run_freq: bool = True, freq_job_kwargs: dict[str, Any] | None = None, opt_params: OptParams | None = None, **calc_kwargs) -&gt; NewtonNetIRCSchema\n</code></pre> <p>Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object representing the system.</p> </li> <li> <code>direction</code>               (<code>Literal['forward', 'reverse']</code>, default:                   <code>'forward'</code> )           \u2013            <p>The direction of the IRC calculation (\"forward\" or \"reverse\").</p> </li> <li> <code>run_freq</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run the frequency analysis.</p> </li> <li> <code>freq_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.freq_job</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>IRCSchema</code>           \u2013            <p>A dictionary containing the IRC summary and thermodynamic summary. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>himatcal/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef irc_job(\n    atoms: Atoms,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    freq_job_kwargs: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    **calc_kwargs,\n) -&gt; NewtonNetIRCSchema:\n    \"\"\"\n    Perform an intrinsic reaction coordinate (IRC) job using the given atoms object.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    direction\n        The direction of the IRC calculation (\"forward\" or \"reverse\").\n    run_freq\n        Whether to run the frequency analysis.\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.freq_job][]\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    **calc_kwargs\n        Custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    IRCSchema\n        A dictionary containing the IRC summary and thermodynamic summary.\n        See the type-hint for the data structure.\n    \"\"\"\n    freq_job_kwargs = freq_job_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\n        \"optimizer\": IRC,\n        \"optimizer_kwargs\": {\"dx\": 0.1, \"eta\": 1e-4, \"gamma\": 0.4, \"keep_going\": True},\n        \"run_kwargs\": {\"direction\": direction},\n    }\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    # Define calculator\n    calc = NewtonNet(**calc_flags)\n\n    # Run IRC\n    with change_settings({\"CHECK_CONVERGENCE\": False}):\n        dyn = Runner(atoms, calc).run_opt(**opt_flags)\n        opt_irc_summary = summarize_opt_run(\n            dyn, additional_fields={\"name\": f\"NewtonNet IRC: {direction}\"}\n        )\n\n    # Run frequency job\n    freq_summary = (\n        strip_decorator(freq_job)(opt_irc_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    opt_irc_summary[\"freq_job\"] = freq_summary\n\n    return opt_irc_summary\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.neb_job","title":"neb_job","text":"<pre><code>neb_job(reactant_atoms: Atoms, product_atoms: Atoms, relax_job_kwargs: dict[str, Any] | None = None, calc_kwargs: dict[str, Any] | None = None, geodesic_interpolate_kwargs: dict[str, Any] | None = None, run_neb_kwargs: dict[str, Any] | None = None) -&gt; NebSchema\n</code></pre> <p>Perform a nudged elastic band (NEB) calculation to find the minimum energy path (MEP) between the given reactant and product structures.</p> <p>Parameters:</p> <ul> <li> <code>reactant_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the reactant structure.</p> </li> <li> <code>product_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the product structure.</p> </li> <li> <code>relax_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use relax_job.</p> </li> <li> <code>calc_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom kwargs for the NewtonNet calculator.</p> </li> <li> <code>geodesic_interpolate_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the geodesic function.</p> </li> <li> <code>run_neb_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for quacc.runners.ase.run_neb function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NebSchema</code>           \u2013            <p>A dictionary containing the following keys:     - 'relax_reactant': Summary of the relaxed reactant structure.     - 'relax_product': Summary of the relaxed product structure.     - 'geodesic_results': The interpolated images between reactant and product.     - 'neb_results': Summary of the NEB optimization.</p> </li> </ul> Source code in <code>himatcal/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\ndef neb_job(\n    reactant_atoms: Atoms,\n    product_atoms: Atoms,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    calc_kwargs: dict[str, Any] | None = None,\n    geodesic_interpolate_kwargs: dict[str, Any] | None = None,\n    run_neb_kwargs: dict[str, Any] | None = None,\n) -&gt; NebSchema:\n    \"\"\"\n    Perform a nudged elastic band (NEB) calculation to find the minimum energy path (MEP) between the given reactant and product structures.\n\n    Parameters\n    ----------\n    reactant_atoms\n        The Atoms object representing the reactant structure.\n    product_atoms\n        The Atoms object representing the product structure.\n    relax_job_kwargs\n        Keyword arguments to use relax_job.\n    calc_kwargs\n        Custom kwargs for the NewtonNet calculator.\n    geodesic_interpolate_kwargs\n        Keyword arguments for the geodesic function.\n    run_neb_kwargs\n        Keyword arguments for quacc.runners.ase.run_neb function.\n\n    Returns\n    -------\n    NebSchema\n        A dictionary containing the following keys:\n            - 'relax_reactant': Summary of the relaxed reactant structure.\n            - 'relax_product': Summary of the relaxed product structure.\n            - 'geodesic_results': The interpolated images between reactant and product.\n            - 'neb_results': Summary of the NEB optimization.\n    \"\"\"\n    relax_job_kwargs = relax_job_kwargs or {}\n    run_neb_kwargs = run_neb_kwargs or {}\n    geodesic_interpolate_kwargs = geodesic_interpolate_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": None,\n    }\n\n    geodesic_defaults = {\"n_images\": 20}\n\n    run_neb_defaults = {\"neb_kwargs\": {\"method\": \"aseneb\", \"precon\": None}}\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    geodesic_interpolate_flags = recursive_dict_merge(\n        geodesic_defaults, geodesic_interpolate_kwargs\n    )\n    run_neb_flags = recursive_dict_merge(run_neb_defaults, run_neb_kwargs)\n\n    # Define calculator\n    reactant_atoms.calc = NewtonNet(**calc_flags)\n    product_atoms.calc = NewtonNet(**calc_flags)\n\n    # Run relax job\n    relax_summary_r = strip_decorator(relax_job)(reactant_atoms, **relax_job_kwargs)\n    relax_summary_p = strip_decorator(relax_job)(product_atoms, **relax_job_kwargs)\n\n    images = _geodesic_interpolate_wrapper(\n        relax_summary_r[\"atoms\"], relax_summary_p[\"atoms\"], **geodesic_interpolate_flags\n    )\n\n    for image in images:\n        image.calc = NewtonNet(**calc_flags)\n\n    dyn = run_neb(images, **run_neb_flags)\n\n    return {\n        \"relax_reactant\": relax_summary_r,\n        \"relax_product\": relax_summary_p,\n        \"geodesic_results\": images,\n        \"neb_results\": summarize_neb_run(\n            dyn,\n            additional_fields={\n                \"run_neb_flags\": run_neb_flags,\n                \"calc_flags\": calc_flags,\n                \"geodesic_interpolate_flags\": geodesic_interpolate_flags,\n            },\n        ),\n    }\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.neb_ts_job","title":"neb_ts_job","text":"<pre><code>neb_ts_job(reactant_atoms: Atoms, product_atoms: Atoms, relax_job_kwargs: dict[str, Any] | None = None, calc_kwargs: dict[str, Any] | None = None, geodesic_interpolate_kwargs: dict[str, Any] | None = None, neb_kwargs: dict[str, Any] | None = None, ts_job_kwargs: dict[str, Any] | None = None) -&gt; NebTsSchema\n</code></pre> <p>Perform a quasi-IRC job using the given reactant and product atoms objects.</p> <p>Parameters:</p> <ul> <li> <code>reactant_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the reactant structure.</p> </li> <li> <code>product_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object representing the product structure.</p> </li> <li> <code>relax_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the relax_job function, by default None.</p> </li> <li> <code>calc_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the NewtonNet calculator, by default None.</p> </li> <li> <code>geodesic_interpolate_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the geodesic_interpolate function, by default None.</p> </li> <li> <code>neb_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the NEB calculation, by default None.</p> </li> <li> <code>ts_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the TS optimizer, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NebTsSchema</code>           \u2013            <p>A dictionary containing the following keys:     - 'relax_reactant': Summary of the relaxed reactant structure.     - 'relax_product': Summary of the relaxed product structure.     - 'geodesic_results': The interpolated images between reactant and product.     - 'neb_results': Summary of the NEB optimization.     - 'ts_results': Summary of the transition state optimization.</p> </li> </ul> Source code in <code>himatcal/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\ndef neb_ts_job(\n    reactant_atoms: Atoms,\n    product_atoms: Atoms,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    calc_kwargs: dict[str, Any] | None = None,\n    geodesic_interpolate_kwargs: dict[str, Any] | None = None,\n    neb_kwargs: dict[str, Any] | None = None,\n    ts_job_kwargs: dict[str, Any] | None = None,\n) -&gt; NebTsSchema:\n    \"\"\"\n    Perform a quasi-IRC job using the given reactant and product atoms objects.\n\n    Parameters\n    ----------\n    reactant_atoms\n        The Atoms object representing the reactant structure.\n    product_atoms\n        The Atoms object representing the product structure.\n    relax_job_kwargs\n        Keyword arguments to use for the relax_job function, by default None.\n    calc_kwargs\n        Keyword arguments for the NewtonNet calculator, by default None.\n    geodesic_interpolate_kwargs\n        Keyword arguments for the geodesic_interpolate function, by default None.\n    neb_kwargs\n        Keyword arguments for the NEB calculation, by default None.\n    ts_job_kwargs\n        Keyword arguments for the TS optimizer, by default None.\n\n    Returns\n    -------\n    NebTsSchema\n        A dictionary containing the following keys:\n            - 'relax_reactant': Summary of the relaxed reactant structure.\n            - 'relax_product': Summary of the relaxed product structure.\n            - 'geodesic_results': The interpolated images between reactant and product.\n            - 'neb_results': Summary of the NEB optimization.\n            - 'ts_results': Summary of the transition state optimization.\n    \"\"\"\n    relax_job_kwargs = relax_job_kwargs or {}\n    neb_kwargs = neb_kwargs or {}\n    geodesic_interpolate_kwargs = geodesic_interpolate_kwargs or {}\n    calc_kwargs = calc_kwargs or {}\n    ts_job_kwargs = ts_job_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n        \"hess_method\": None,\n    }\n\n    geodesic_defaults = {\"n_images\": 20}\n\n    neb_defaults = {\"method\": \"aseneb\", \"precon\": None}\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    calc_flags[\"hess_method\"] = None\n    geodesic_interpolate_flags = recursive_dict_merge(\n        geodesic_defaults, geodesic_interpolate_kwargs\n    )\n    neb_flags = recursive_dict_merge(neb_defaults, neb_kwargs)\n\n    neb_results = strip_decorator(neb_job)(\n        reactant_atoms,\n        product_atoms,\n        calc_kwargs=calc_flags,\n        geodesic_interpolate_kwargs=geodesic_interpolate_flags,\n        neb_kwargs=neb_flags,\n        relax_job_kwargs=relax_job_kwargs,\n    )\n\n    traj = neb_results[\"neb_results\"][\"trajectory\"]\n    traj_results = neb_results[\"neb_results\"][\"trajectory_results\"]\n    n_images = len(neb_results[\"geodesic_results\"])\n\n    ts_index = np.argmax([i[\"energy\"] for i in traj_results[-(n_images - 1) : -1]]) + 1\n    ts_atoms = traj[-(n_images) + ts_index]\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n\n    output = strip_decorator(ts_job)(ts_atoms, **ts_job_kwargs, **calc_flags)\n    neb_results[\"ts_results\"] = output\n\n    return neb_results\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.quasi_irc_job","title":"quasi_irc_job","text":"<pre><code>quasi_irc_job(atoms: Atoms, direction: Literal['forward', 'reverse'] = 'forward', run_freq: bool = True, irc_job_kwargs: dict[str, Any] | None = None, relax_job_kwargs: dict[str, Any] | None = None, freq_job_kwargs: dict[str, Any] | None = None) -&gt; NewtonNetQuasiIRCSchema\n</code></pre> <p>Perform a quasi-IRC job using the given atoms object. The initial IRC job by default is run with <code>max_steps: 5</code>.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object representing the system</p> </li> <li> <code>direction</code>               (<code>Literal['forward', 'reverse']</code>, default:                   <code>'forward'</code> )           \u2013            <p>The direction of the IRC calculation</p> </li> <li> <code>run_freq</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run the frequency analysis</p> </li> <li> <code>irc_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.irc_job</p> </li> <li> <code>relax_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.core.relax_job</p> </li> <li> <code>freq_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.freq_job</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>QuasiIRCSchema</code>           \u2013            <p>A dictionary containing the IRC summary, optimization summary, and thermodynamic summary. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>himatcal/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef quasi_irc_job(\n    atoms: Atoms,\n    direction: Literal[\"forward\", \"reverse\"] = \"forward\",\n    run_freq: bool = True,\n    irc_job_kwargs: dict[str, Any] | None = None,\n    relax_job_kwargs: dict[str, Any] | None = None,\n    freq_job_kwargs: dict[str, Any] | None = None,\n) -&gt; NewtonNetQuasiIRCSchema:\n    \"\"\"\n    Perform a quasi-IRC job using the given atoms object. The initial IRC job by default\n    is run with `max_steps: 5`.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system\n    direction\n        The direction of the IRC calculation\n    run_freq\n        Whether to run the frequency analysis\n    irc_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.irc_job][]\n    relax_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.core.relax_job][]\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.freq_job][]\n\n    Returns\n    -------\n    QuasiIRCSchema\n        A dictionary containing the IRC summary, optimization summary, and\n        thermodynamic summary.\n        See the type-hint for the data structure.\n    \"\"\"\n    relax_job_kwargs = relax_job_kwargs or {}\n    freq_job_kwargs = freq_job_kwargs or {}\n\n    irc_job_defaults = {\"max_steps\": 5}\n    irc_job_kwargs = recursive_dict_merge(irc_job_defaults, irc_job_kwargs)\n\n    # Run IRC\n    irc_summary = strip_decorator(irc_job)(\n        atoms, direction=direction, run_freq=False, **irc_job_kwargs\n    )\n\n    # Run opt\n    relax_summary = strip_decorator(relax_job)(irc_summary[\"atoms\"], **relax_job_kwargs)\n\n    # Run frequency\n    freq_summary = (\n        strip_decorator(freq_job)(relax_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    relax_summary[\"freq_job\"] = freq_summary\n    relax_summary[\"irc_job\"] = irc_summary\n\n    return relax_summary\n</code></pre>"},{"location":"reference/himatcal/recipes/newtonnet/ts.html#himatcal.recipes.newtonnet.ts.ts_job","title":"ts_job","text":"<pre><code>ts_job(atoms: Atoms, use_custom_hessian: bool = False, run_freq: bool = True, freq_job_kwargs: dict[str, Any] | None = None, opt_params: OptParams | None = None, **calc_kwargs) -&gt; NewtonNetTSSchema\n</code></pre> <p>Perform a transition state (TS) job using the given atoms object.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The atoms object representing the system.</p> </li> <li> <code>use_custom_hessian</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a custom Hessian matrix.</p> </li> <li> <code>run_freq</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run the frequency job.</p> </li> <li> <code>freq_job_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments to use for the quacc.recipes.newtonnet.ts.freq_job</p> </li> <li> <code>opt_params</code>               (<code>OptParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of custom kwargs for the optimization process. For a list of available keys, refer to quacc.runners.ase.Runner.run_opt.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Dictionary of custom kwargs for the NewtonNet calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely. For a list of available keys, refer to the <code>newtonnet.utils.ase_interface.MLAseCalculator</code> calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TSSchema</code>           \u2013            <p>Dictionary of results. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>himatcal/recipes/newtonnet/ts.py</code> <pre><code>@job\n@requires(\n    has_newtonnet, \"NewtonNet must be installed. Refer to the quacc documentation.\"\n)\n@requires(has_sella, \"Sella must be installed. Refer to the quacc documentation.\")\ndef ts_job(\n    atoms: Atoms,\n    use_custom_hessian: bool = False,\n    run_freq: bool = True,\n    freq_job_kwargs: dict[str, Any] | None = None,\n    opt_params: OptParams | None = None,\n    **calc_kwargs,\n) -&gt; NewtonNetTSSchema:\n    \"\"\"\n    Perform a transition state (TS) job using the given atoms object.\n\n    Parameters\n    ----------\n    atoms\n        The atoms object representing the system.\n    use_custom_hessian\n        Whether to use a custom Hessian matrix.\n    run_freq\n        Whether to run the frequency job.\n    freq_job_kwargs\n        Keyword arguments to use for the [quacc.recipes.newtonnet.ts.freq_job][]\n    opt_params\n        Dictionary of custom kwargs for the optimization process. For a list\n        of available keys, refer to [quacc.runners.ase.Runner.run_opt][].\n    **calc_kwargs\n        Dictionary of custom kwargs for the NewtonNet calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the `newtonnet.utils.ase_interface.MLAseCalculator` calculator.\n\n    Returns\n    -------\n    TSSchema\n        Dictionary of results. See the type-hint for the data structure.\n    \"\"\"\n    freq_job_kwargs = freq_job_kwargs or {}\n    settings = get_settings()\n\n    calc_defaults = {\n        \"model_path\": settings.NEWTONNET_MODEL_PATH,\n        \"settings_path\": settings.NEWTONNET_CONFIG_PATH,\n    }\n    opt_defaults = {\n        \"optimizer\": Sella,\n        \"optimizer_kwargs\": (\n            {\"diag_every_n\": 0, \"order\": 1} if use_custom_hessian else {\"order\": 1}\n        ),\n    }\n\n    calc_flags = recursive_dict_merge(calc_defaults, calc_kwargs)\n    opt_flags = recursive_dict_merge(opt_defaults, opt_params)\n\n    if use_custom_hessian:\n        opt_flags[\"optimizer_kwargs\"][\"hessian_function\"] = _get_hessian\n\n    calc = NewtonNet(**calc_flags)\n\n    # Run the TS optimization\n    dyn = Runner(atoms, calc).run_opt(**opt_flags)\n    opt_ts_summary = summarize_opt_run(dyn, additional_fields={\"name\": \"NewtonNet TS\"})\n\n    # Run a frequency calculation\n    freq_summary = (\n        strip_decorator(freq_job)(opt_ts_summary[\"atoms\"], **freq_job_kwargs)\n        if run_freq\n        else None\n    )\n    opt_ts_summary[\"freq_job\"] = freq_summary\n\n    return opt_ts_summary\n</code></pre>"},{"location":"reference/himatcal/recipes/orca/core.html","title":"core","text":"<p>Core recipes for ORCA.</p>"},{"location":"reference/himatcal/recipes/orca/core.html#himatcal.recipes.orca.core.bare_job","title":"bare_job","text":"<pre><code>bare_job(atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1, xc: str = 'b97-3c', basis: str = 'def2-tzvp', orcasimpleinput: list[str] | None = None, orcablocks: list[str] | None = None, nprocs: int | Literal['max'] | None = 'max', copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, additional_fields: dict[str, Any] | None = None) -&gt; RunSchema\n</code></pre> Source code in <code>himatcal/recipes/orca/core.py</code> <pre><code>@job\ndef bare_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"b97-3c\",\n    basis: str = \"def2-tzvp\",\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    nprocs: int | Literal[\"max\"] | None = \"max\",\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema:\n    additional_fields = {\"name\": \"ORCA Static\"} | (additional_fields or {})\n    nprocs = psutil.cpu_count(logical=False) if nprocs in [\"max\", None] else nprocs\n    default_inputs = [xc, basis]\n    default_blocks = [f\"%pal nprocs {nprocs} end\"]\n\n    return run_and_summarize(\n        atoms,\n        charge,\n        spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        additional_fields=additional_fields,\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/orca/core.html#himatcal.recipes.orca.core.neb_job","title":"neb_job","text":"<pre><code>neb_job(atoms: Atoms, charge: int = 0, spin_multiplicity: int = 1, xc: str = 'wb97x-d3bj', basis: str = 'def2-tzvp', n_images: int = 6, preopt: bool = False, guessTS: bool = False, orcasimpleinput: list[str] | None = None, orcablocks: list[str] | None = None, nprocs: int | Literal['max'] | None = 'max', copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, additional_fields: dict[str, Any] | None = None) -&gt; RunSchema\n</code></pre> <p>product.xyz is necessary for NEB calculation, guessts.xyz is optional; Add a folder to copy_files to copy the product.xyz and guessts.xyz to the working directory.</p> Source code in <code>himatcal/recipes/orca/core.py</code> <pre><code>@job\ndef neb_job(\n    atoms: Atoms,\n    charge: int = 0,\n    spin_multiplicity: int = 1,\n    xc: str = \"wb97x-d3bj\",\n    basis: str = \"def2-tzvp\",\n    n_images: int = 6,\n    preopt: bool = False,\n    guessTS: bool = False,\n    orcasimpleinput: list[str] | None = None,\n    orcablocks: list[str] | None = None,\n    nprocs: int | Literal[\"max\"] | None = \"max\",\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    product.xyz is necessary for NEB calculation, guessts.xyz is optional; Add a folder to copy_files to copy the product.xyz and guessts.xyz to the working directory.\n    \"\"\"\n    additional_fields = {\"name\": \"ORCA Static\"} | (additional_fields or {})\n    nprocs = psutil.cpu_count(logical=False) if nprocs in [\"max\", None] else nprocs\n    default_inputs = [xc, basis, \"neb-ts\", \"freq\"]\n    neb_block = '%NEB NEB_END_XYZFILE \"product.xyz\"'\n    if guessTS:\n        neb_block += ' NEB_TS_XYZFILE \"guessts.xyz\"'\n    if preopt:\n        neb_block += \" PREOPT_ENDS TRUE\"\n    neb_block += f\" Nimages {n_images}\"\n    neb_block += \" END\"\n    default_blocks = [f\"%pal nprocs {nprocs} end\", neb_block]\n\n    return run_and_summarize(\n        atoms,\n        charge,\n        spin_multiplicity,\n        default_inputs=default_inputs,\n        default_blocks=default_blocks,\n        input_swaps=orcasimpleinput,\n        block_swaps=orcablocks,\n        additional_fields=additional_fields,\n        copy_files=copy_files,\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/quacc/_base.html","title":"_base","text":""},{"location":"reference/himatcal/recipes/quacc/_base.html#himatcal.recipes.quacc._base.clear_quacc_cache","title":"clear_quacc_cache","text":"<pre><code>clear_quacc_cache(path: Path | None = None) -&gt; None\n</code></pre> Source code in <code>himatcal/recipes/quacc/_base.py</code> <pre><code>def clear_quacc_cache(path: Path | None = None) -&gt; None:\n    if path is None:\n        path = Path.cwd()\n    \"\"\"Clear the QUACC cache directory.\n\n    This function clears the QUACC cache directory by removing all files and directories within it.\n    The cache directory is specified by the provided path.\n\n    Args:\n        path (Path, optional): The path to the QUACC cache directory. Defaults to the current working directory.\n\n    Examples:\n        clear_quacc_cache(Path(\"path/to/cache_dir\"))\n    \"\"\"\n    directory_patterns = [\"quacc-*\", \"tmp*\"]\n\n    for pattern in directory_patterns:\n        for dir_path in path.glob(pattern):\n            if dir_path.is_dir():\n                for file in dir_path.iterdir():\n                    if file.is_file():\n                        file.unlink()\n                dir_path.rmdir()\n            else:\n                dir_path.unlink()\n</code></pre>"},{"location":"reference/himatcal/recipes/quacc/_base.html#himatcal.recipes.quacc._base.load_quacc_result","title":"load_quacc_result","text":"<pre><code>load_quacc_result(file_path: str) -&gt; dict\n</code></pre> <p>Load and return the contents of a QUACC result file.</p> <p>This function reads a specified file and loads its contents into a dictionary format. It utilizes a loading function to handle the file reading process.</p> <p>Args:     file_path (str): The path to the QUACC result file to be loaded.</p> <p>Returns:     dict: The contents of the loaded QUACC result file.</p> <p>Examples:     result = load_quacc_result(\"path/to/result_file.json\")</p> Source code in <code>himatcal/recipes/quacc/_base.py</code> <pre><code>def load_quacc_result(file_path: str) -&gt; dict:\n    \"\"\"Load and return the contents of a QUACC result file.\n\n    This function reads a specified file and loads its contents into a dictionary format.\n    It utilizes a loading function to handle the file reading process.\n\n    Args:\n        file_path (str): The path to the QUACC result file to be loaded.\n\n    Returns:\n        dict: The contents of the loaded QUACC result file.\n\n    Examples:\n        result = load_quacc_result(\"path/to/result_file.json\")\n    \"\"\"\n    return loadfn(file_path)\n</code></pre>"},{"location":"reference/himatcal/recipes/quacc/core.html","title":"core","text":""},{"location":"reference/himatcal/recipes/quacc/core.html#himatcal.recipes.quacc.core.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms: Atoms, calc, relax_cell: bool = False, opt_params: OptParams | None = None, additional_fields: dict[str, Any] | None = None) -&gt; OptSchema\n</code></pre> <p>Perform a relaxation job on a given set of atoms using a specified calculator.</p> <p>This function executes an optimization process to relax the atomic structure, optionally allowing for cell relaxation. It merges default optimization parameters with any user-provided parameters and returns the results of the optimization.</p> <p>Args:     atoms (Atoms): The atomic structure to be relaxed.     calc: The calculator to be used for the relaxation process.     relax_cell (bool, optional): Whether to relax the cell dimensions. Defaults to False.     opt_params (OptParams | None, optional): Additional optimization parameters. Defaults to None.     additional_fields (dict[str, Any] | None, optional): Extra fields to include in the results. Defaults to None.</p> <p>Returns:     OptSchema: The results of the relaxation job, encapsulated in an optimization schema.</p> <p>Examples:     result = relax_job(atoms, calculator, relax_cell=True, opt_params={\"fmax\": 0.01})</p> Source code in <code>himatcal/recipes/quacc/core.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    calc,\n    relax_cell: bool = False,\n    opt_params: OptParams | None = None,\n    additional_fields: dict[str, Any] | None = None,\n) -&gt; OptSchema:\n    \"\"\"Perform a relaxation job on a given set of atoms using a specified calculator.\n\n    This function executes an optimization process to relax the atomic structure,\n    optionally allowing for cell relaxation. It merges default optimization parameters\n    with any user-provided parameters and returns the results of the optimization.\n\n    Args:\n        atoms (Atoms): The atomic structure to be relaxed.\n        calc: The calculator to be used for the relaxation process.\n        relax_cell (bool, optional): Whether to relax the cell dimensions. Defaults to False.\n        opt_params (OptParams | None, optional): Additional optimization parameters. Defaults to None.\n        additional_fields (dict[str, Any] | None, optional): Extra fields to include in the results. Defaults to None.\n\n    Returns:\n        OptSchema: The results of the relaxation job, encapsulated in an optimization schema.\n\n    Examples:\n        result = relax_job(atoms, calculator, relax_cell=True, opt_params={\"fmax\": 0.01})\n    \"\"\"\n\n    opt_defaults = {\"fmax\": 0.05, \"max_steps\": 1000}\n\n    # Ensure opt_params is converted to a dictionary if it's not already\n    opt_flags = recursive_dict_merge(\n        opt_defaults, dict(opt_params) if opt_params else {}\n    )\n\n    # Make sure that the 'run_opt' method returns an appropriate type for 'opt'\n    dyn = Runner(atoms, calc).run_opt(relax_cell=relax_cell, **opt_flags)\n\n    # Ensure dyn is of the correct type for Summarize.opt\n    return Summarize(\n        additional_fields={\"name\": \"MLP Relax\"} | (additional_fields or {})\n    ).opt(dyn)\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html","title":"_base","text":"<p>reaction calculations</p>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph","title":"MolGraph","text":"<pre><code>MolGraph(smiles: str | None = None, atoms: Atoms | None = None, energy: float | None = None, state: str = 'init', label: str = 'mol')\n</code></pre> <p>               Bases: <code>BaseModel</code></p> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def __init__(\n    self,\n    smiles: str | None = None,\n    atoms: Atoms | None = None,\n    energy: float | None = None,\n    state: str = \"init\",\n    label: str = \"mol\",\n):\n    super().__init__(\n        smiles=smiles, atoms=atoms, energy=energy, state=state, label=label\n    )\n    if self.smiles and self.atoms:\n        logging.info(\"Both smiles and atoms provided, using atoms.\")\n    elif self.smiles:\n        self.smiles2atoms()\n    elif self.atoms:\n        self.atoms2smiles()\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.atoms","title":"atoms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>atoms: Atoms | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.energy","title":"energy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy: float | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: str = 'mol'\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.smiles","title":"smiles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>smiles: str | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: str = 'init'\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.Config","title":"Config","text":""},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.Config.arbitrary_types_allowed","title":"arbitrary_types_allowed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arbitrary_types_allowed = True\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.atoms2smiles","title":"atoms2smiles","text":"<pre><code>atoms2smiles()\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def atoms2smiles(self):\n    if self.atoms and self.smiles is None:\n        from himatcal.utils.rdkit.core import atoms2smiles\n\n        self.smiles = atoms2smiles(self.atoms)\n    return self.smiles\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filename, smiles=None)\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>@classmethod\ndef from_file(cls, filename, smiles=None):\n    from monty.serialization import loadfn\n\n    data = loadfn(filename)\n    if not smiles:\n        return cls.from_json(data)\n    try:\n        moldata = next(item for item in data if item[\"smiles\"] == smiles)\n        return cls.from_json(moldata)\n    except StopIteration as e:\n        raise ValueError(\n            f\"No molecule with smiles '{smiles}' found in the file.\"\n        ) from e\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(data)\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>@classmethod\ndef from_json(cls, data):\n    from monty.json import MontyDecoder\n\n    return cls(**MontyDecoder().process_decoded(data))\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.show_atoms","title":"show_atoms","text":"<pre><code>show_atoms()\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def show_atoms(self):\n    from nglview import show_ase\n\n    return show_ase(self.atoms)\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.show_mol","title":"show_mol","text":"<pre><code>show_mol()\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def show_mol(self):\n    from rdkit import Chem\n    from rdkit.Chem import Draw\n\n    mol = Chem.MolFromSmiles(self.smiles)\n    return Draw.MolToImage(mol)\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.smiles2atoms","title":"smiles2atoms","text":"<pre><code>smiles2atoms()\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def smiles2atoms(self):\n    if self.smiles and self.atoms is None:\n        from himatcal.utils.rdkit.core import smiles2atoms\n\n        self.atoms = smiles2atoms(self.smiles)\n    return self.atoms\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.to_file","title":"to_file","text":"<pre><code>to_file(filename)\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def to_file(self, filename):\n    from monty.serialization import dumpfn\n\n    dumpfn(self.to_json(), filename)\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.MolGraph.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def to_json(self):\n    from monty.json import jsanitize\n\n    return jsanitize(self.model_dump(), enum_values=True, recursive_msonable=True)\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction","title":"Reaction","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.barrier","title":"barrier  <code>property</code>","text":"<pre><code>barrier\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.enthalpy","title":"enthalpy  <code>property</code>","text":"<pre><code>enthalpy\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.product","title":"product  <code>instance-attribute</code>","text":"<pre><code>product: MolGraph | list[MolGraph]\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.product_energy","title":"product_energy  <code>property</code>","text":"<pre><code>product_energy\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.product_smiles","title":"product_smiles  <code>property</code>","text":"<pre><code>product_smiles\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.reactant","title":"reactant  <code>instance-attribute</code>","text":"<pre><code>reactant: MolGraph | list[MolGraph]\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.reactant_energy","title":"reactant_energy  <code>property</code>","text":"<pre><code>reactant_energy\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.reactant_smiles","title":"reactant_smiles  <code>property</code>","text":"<pre><code>reactant_smiles\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.reaction_results","title":"reaction_results  <code>property</code>","text":"<pre><code>reaction_results\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.ts","title":"ts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ts: MolGraph | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.Reaction.reverse","title":"reverse","text":"<pre><code>reverse()\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def reverse(self):\n    return Reaction(reactant=self.product, product=self.reactant, ts=self.ts)\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults","title":"ReactionResults","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.dh","title":"dh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dh: float | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.ea","title":"ea  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ea: float | None = None\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.products","title":"products  <code>property</code>","text":"<pre><code>products\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.psmi","title":"psmi  <code>instance-attribute</code>","text":"<pre><code>psmi: str\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.reactants","title":"reactants  <code>property</code>","text":"<pre><code>reactants\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.rsmi","title":"rsmi  <code>instance-attribute</code>","text":"<pre><code>rsmi: str\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.rxn_smi","title":"rxn_smi  <code>property</code>","text":"<pre><code>rxn_smi\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def __str__(self):\n    return f\"{self.rsmi}&gt;&gt;{self.psmi}\"\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/_base.html#himatcal.recipes.reaction._base.ReactionResults.reverse","title":"reverse","text":"<pre><code>reverse()\n</code></pre> Source code in <code>himatcal/recipes/reaction/_base.py</code> <pre><code>def reverse(self):\n    return ReactionResults(\n        rsmi=self.psmi, psmi=self.rsmi, ea=self.ea - self.dh, dh=-self.dh\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/core.html","title":"core","text":""},{"location":"reference/himatcal/recipes/reaction/core.html#himatcal.recipes.reaction.core.orca_neb","title":"orca_neb","text":"<pre><code>orca_neb(reactant: MolGraph, product: MolGraph, chg: int, mult: int, ts: MolGraph | None = None, n_images: int = 5, preopt: bool = False, guessTS: bool = False)\n</code></pre> Source code in <code>himatcal/recipes/reaction/core.py</code> <pre><code>def orca_neb(\n    reactant: MolGraph,\n    product: MolGraph,\n    chg: int,\n    mult: int,\n    ts: MolGraph | None = None,\n    n_images: int = 5,\n    preopt: bool = False,\n    guessTS: bool = False,\n):\n    Product_dir = Path(\"Product\")\n    Product_dir.mkdir(exist_ok=True)\n    if product and product.atoms is not None:\n        product.atoms.write(Product_dir / \"product.xyz\")\n    if ts and ts.atoms is not None:\n        ts.atoms.write(Product_dir / \"guessts.xyz\")\n\n    return neb_job(\n        atoms=reactant.atoms,\n        charge=chg,\n        spin_multiplicity=mult,\n        xc=\"b97-3c\",\n        basis=\"def2-SVP\",\n        n_images=n_images,\n        preopt=preopt,\n        guessTS=guessTS,\n        copy_files=f\"{Product_dir.resolve()}\",\n    )\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/core.html#himatcal.recipes.reaction.core.plot_rxn_smiles","title":"plot_rxn_smiles","text":"<pre><code>plot_rxn_smiles(reaction_smi, useSmiles=True)\n</code></pre> Source code in <code>himatcal/recipes/reaction/core.py</code> <pre><code>def plot_rxn_smiles(reaction_smi, useSmiles=True):\n    from rdkit.Chem import Draw, rdChemReactions\n\n    reaction = rdChemReactions.ReactionFromSmarts(reaction_smi, useSmiles=useSmiles)\n    logging.info(f\"input reaction: {reaction_smi}\")\n    logging.info(\n        f\"Rdkit formmated reaction: {rdChemReactions.ReactionToSmiles(reaction)}\"\n    )\n    return Draw.ReactionToImage(reaction)\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/newtonnet.html","title":"newtonnet","text":"<p>https://github.com/kumaranu/ts-workflow-examples/tree/main</p>"},{"location":"reference/himatcal/recipes/reaction/newtonnet.html#himatcal.recipes.reaction.newtonnet.geodesic_ts_hess_irc_newtonnet","title":"geodesic_ts_hess_irc_newtonnet","text":"<pre><code>geodesic_ts_hess_irc_newtonnet(reactant: Atoms, product: Atoms, calc_kwargs1: dict[str, Any] | None = None, calc_kwargs2: dict[str, Any] | None = None, clean_up: bool = True) -&gt; list[dict[str, Any]]\n</code></pre> <p>Perform geodesic, transition state, and intrinsic reaction coordinate (IRC) calculations using NewtonNet.</p> <p>Parameters:</p> <ul> <li> <code>reactant</code>               (<code>Atoms</code>)           \u2013            <p>The reactant structure.</p> </li> <li> <code>product</code>               (<code>Atoms</code>)           \u2013            <p>The product structure.</p> </li> <li> <code>calc_kwargs1</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the ASE calculator for the geodesic and IRC jobs.</p> </li> <li> <code>calc_kwargs2</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments for the ASE calculator for the TS job with custom Hessian.</p> </li> <li> <code>clean_up</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to clean up raw files after completion, by default True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Dict[str, Any]]</code>           \u2013            <p>List containing results from geodesic, TS, and IRC jobs.</p> </li> </ul> Source code in <code>himatcal/recipes/reaction/newtonnet.py</code> <pre><code>def geodesic_ts_hess_irc_newtonnet(\n    reactant: Atoms,\n    product: Atoms,\n    calc_kwargs1: dict[str, Any] | None = None,\n    calc_kwargs2: dict[str, Any] | None = None,\n    clean_up: bool = True,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Perform geodesic, transition state, and intrinsic reaction coordinate (IRC) calculations using NewtonNet.\n\n    Parameters\n    ----------\n    reactant : Atoms\n        The reactant structure.\n    product : Atoms\n        The product structure.\n    calc_kwargs1 : dict\n        Keyword arguments for the ASE calculator for the geodesic and IRC jobs.\n    calc_kwargs2 : dict\n        Keyword arguments for the ASE calculator for the TS job with custom Hessian.\n    clean_up : bool, optional\n        Whether to clean up raw files after completion, by default True.\n\n    Returns\n    -------\n    List[Dict[str, Any]]\n        List containing results from geodesic, TS, and IRC jobs.\n    \"\"\"\n    # Set default values for calc_kwargs1 and calc_kwargs2 if they are None\n    if calc_kwargs1 is None:\n        calc_kwargs1 = {\"hess_method\": None}\n    if calc_kwargs2 is None:\n        calc_kwargs2 = {\"hess_method\": \"autograd\"}\n\n    # Create NEB job\n    job1 = strip_decorator(geodesic_job)(reactant, product, calc_kwargs=calc_kwargs1)\n    logging.info(\"Created Geodesic job.\")\n\n    # Create TS job with custom Hessian\n    job2 = strip_decorator(ts_job)(\n        job1[\"highest_e_atoms\"], use_custom_hessian=True, **calc_kwargs2\n    )\n    logging.info(\"Created TS job with custom Hessian.\")\n\n    # Create IRC job in forward direction\n    job3 = strip_decorator(irc_job)(job2[\"atoms\"], direction=\"forward\", **calc_kwargs1)\n    logging.info(\"Created IRC job in forward direction.\")\n\n    # Create IRC job in reverse direction\n    job4 = strip_decorator(irc_job)(job2[\"atoms\"], direction=\"reverse\", **calc_kwargs1)\n    logging.info(\"Created IRC job in reverse direction.\")\n\n    logging.info(\"All jobs executed successfully.\")\n\n    if clean_up:\n        # Delete the raw files\n        directory_patterns = [\"quacc-*\", \"tmp*\"]\n\n        # Delete directories matching patterns\n        for pattern in directory_patterns:\n            for dir_path in Path.cwd().glob(pattern):\n                if dir_path.is_dir():\n                    shutil.rmtree(dir_path)\n\n    return [job1, job2, job3, job4]\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/utils.html","title":"utils","text":""},{"location":"reference/himatcal/recipes/reaction/utils.html#himatcal.recipes.reaction.utils.get_charge_and_spin","title":"get_charge_and_spin","text":"<pre><code>get_charge_and_spin(smiles)\n</code></pre> Source code in <code>himatcal/recipes/reaction/utils.py</code> <pre><code>def get_charge_and_spin(smiles):\n    from rdkit import Chem\n\n    # \u4eceSMILES\u5b57\u7b26\u4e32\u521b\u5efa\u5206\u5b50\u5bf9\u8c61\n    mol = Chem.MolFromSmiles(smiles)\n\n    # \u8ba1\u7b97\u5206\u5b50\u7684\u7535\u8377\n    charge = sum(atom.GetFormalCharge() for atom in mol.GetAtoms())\n\n    # \u8ba1\u7b97\u5206\u5b50\u7684\u81ea\u65cb\u591a\u91cd\u5ea6\n    num_radicals = sum(atom.GetNumRadicalElectrons() for atom in mol.GetAtoms())\n    spin_multiplicity = num_radicals + 1\n\n    return charge, spin_multiplicity\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/utils.html#himatcal.recipes.reaction.utils.molgraph_relax","title":"molgraph_relax","text":"<pre><code>molgraph_relax(molgraph: MolGraph, charge: int | None, mult: int | None, method: str = 'orca')\n</code></pre> Source code in <code>himatcal/recipes/reaction/utils.py</code> <pre><code>def molgraph_relax(molgraph: MolGraph, charge: int | None, mult: int | None, method: str=\"orca\"):\n\n    if charge is None or mult is None:\n        charge, mult = get_charge_and_spin(molgraph.smiles)\n    if method == \"orca\":\n        from quacc.recipes.orca.core import relax_job\n        result = relax_job(\n            atoms=molgraph.atoms,\n            charge=charge,\n            spin_multiplicity=mult,\n            xc=\"b97-3c\",\n            basis=\"def2-tzvp\",\n        )\n    elif method == \"aimnet2\":\n        from himatcal.calculator.aimnet import AIMNet2ASE\n        from himatcal.recipes.quacc.core import relax_job\n        calc = AIMNet2ASE(\n            \"aimnet2_b973c\",\n            charge=charge,\n            mult=mult,\n        )\n        result = relax_job(\n            atoms=molgraph.atoms,\n            calc=calc,\n        )\n    logging.info(f\"Relaxation of {molgraph.smiles} is done.\")\n\n    molgraph.atoms = result[\"atoms\"]\n    molgraph.energy = result[\"results\"][\"energy\"]\n    molgraph.state = \"opt\"\n    molgraph.label = \"b97-3c\"\n\n    return molgraph\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/utils.html#himatcal.recipes.reaction.utils.molgraph_spe","title":"molgraph_spe","text":"<pre><code>molgraph_spe(molgraph: MolGraph, charge: int | None, mult: int | None)\n</code></pre> Source code in <code>himatcal/recipes/reaction/utils.py</code> <pre><code>def molgraph_spe(molgraph: MolGraph, charge: int | None, mult: int | None):\n    from himatcal.recipes.gaussian.flow import calc_free_energy\n\n    if charge is None or mult is None:\n        charge, mult = get_charge_and_spin(molgraph.smiles)\n\n    freeE = calc_free_energy(\n        atoms=molgraph.atoms,\n        charge=charge,\n        mult=mult,\n        label=\"molgraph\",\n        relax=False,\n    )\n    freeE.run()\n    logging.info(f\"SPE calculation of {molgraph.smiles} is done.\")\n\n    molgraph.energy = freeE.extract_free_energy()\n    molgraph.state = \"final\"\n    molgraph.label = \"b97-3c//b3lyp/6-311+g(d)/gd3bj/acetone\"\n\n    return molgraph\n</code></pre>"},{"location":"reference/himatcal/recipes/reaction/utils.html#himatcal.recipes.reaction.utils.update_molgraph","title":"update_molgraph","text":"<pre><code>update_molgraph(molgraph: MolGraph, filename: str = 'molgraph.json')\n</code></pre> <p>update the molgraph in the JSON file</p> Source code in <code>himatcal/recipes/reaction/utils.py</code> <pre><code>def update_molgraph(molgraph: MolGraph, filename: str = \"molgraph.json\"):\n    \"\"\"\n    update the molgraph in the JSON file\n    \"\"\"\n    with open(filename) as json_file:\n        content = json_file.read()\n        molgraph_list = [] if content == \"\" else json.loads(content)\n\n    # update the molgraph with same smiles\n    mol_json = molgraph.to_json()\n    for i, mol in enumerate(molgraph_list):\n        if mol[\"smiles\"] == molgraph.smiles:\n            molgraph_list[i] = mol_json\n            break\n    else:\n        molgraph_list.append(mol_json)\n\n    # Save the list of dictionaries to a JSON file\n    with open(filename, \"w\") as json_file:\n        json.dump(molgraph_list, json_file, indent=4)\n</code></pre>"},{"location":"reference/himatcal/tools/db.html","title":"db","text":""},{"location":"reference/himatcal/tools/db.html#himatcal.tools.db.load_from_db","title":"load_from_db","text":"<pre><code>load_from_db(label, database='himat', collection_name='job')\n</code></pre> <p>Load a document from the database.</p> Source code in <code>himatcal/tools/db.py</code> <pre><code>def load_from_db(label, database=\"himat\", collection_name=\"job\"):\n    \"\"\"\n    Load a document from the database.\n    \"\"\"\n    store = MongoURIStore(\n        uri=SETTINGS.MONGODB_URI,\n        database=database,\n        collection_name=collection_name,\n    )\n\n    with store:\n        documents = store.query(criteria={\"label\": label})\n    if len(documents) == 0:\n        logging.debug(f\"{label} not found in the database!\")\n        return None\n    else:\n        logging.debug(f\"{label} has been loaded from the database!\")\n        return documents\n</code></pre>"},{"location":"reference/himatcal/tools/db.html#himatcal.tools.db.save_to_db","title":"save_to_db","text":"<pre><code>save_to_db(label, info=None, database='himat', collection_name='job')\n</code></pre> <p>Save a document to the database.</p> Source code in <code>himatcal/tools/db.py</code> <pre><code>def save_to_db(label, info=None, database=\"himat\", collection_name=\"job\"):\n    \"\"\"\n    Save a document to the database.\n    \"\"\"\n    if info is None:\n        info = {}\n    store = MongoURIStore(\n        uri=SETTINGS.MONGODB_URI,\n        database=database,\n        collection_name=collection_name,\n    )\n\n    base_info = {\n        \"label\": label,\n        \"time\": jsanitize(datetime.now(timezone.utc).strftime(\"%Y-%m-%d %H:%M:%S\")),\n    }\n\n    document = {**base_info, **info}\n    with store:\n        store.update([document])\n    logging.debug(f\"{label} has been saved to the database!\")\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html","title":"mpdownload","text":""},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.data","title":"data  <code>module-attribute</code>","text":"<pre><code>data = get_mp_chemsys(input_content)\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.extract_data","title":"extract_data  <code>module-attribute</code>","text":"<pre><code>extract_data = extract_mp_prop(data)\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.input_content","title":"input_content  <code>module-attribute</code>","text":"<pre><code>input_content = argv[2]\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.input_type","title":"input_type  <code>module-attribute</code>","text":"<pre><code>input_type = argv[1]\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.mpr","title":"mpr  <code>module-attribute</code>","text":"<pre><code>mpr = MPRester(api_key=MAPI_KEY)\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.path","title":"path  <code>module-attribute</code>","text":"<pre><code>path = argv[3]\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.extract_mp_data","title":"extract_mp_data","text":"<pre><code>extract_mp_data(material_id, path)\n</code></pre> Source code in <code>himatcal/tools/mpdownload.py</code> <pre><code>def extract_mp_data(material_id, path):\n    stru = mpr.materials.summary.search(material_ids=[material_id])\n    stru = stru[0].structure.to(fmt=\"poscar\", filename=f\"{path}/{material_id}.vasp\")\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.extract_mp_prop","title":"extract_mp_prop","text":"<pre><code>extract_mp_prop(MPdoc)\n</code></pre> Source code in <code>himatcal/tools/mpdownload.py</code> <pre><code>def extract_mp_prop(MPdoc):\n    data = {\n        \"MPID\": [],\n        \"formula\": [],\n        \"CrystalSystem\": [],\n        \"SpaceGroup\": [],\n        \"nsites\": [],\n        \"EHull\": [],\n        \"BandGap\": [],\n    }\n    for i in range(len(MPdoc)):\n        data[\"MPID\"].append(\"mp-\" + str(MPdoc[i].material_id.split(\"-\")[1]))\n        data[\"formula\"].append(MPdoc[i].formula_pretty)\n        data[\"CrystalSystem\"].append(str(MPdoc[i].symmetry.crystal_system))\n        data[\"SpaceGroup\"].append(str(MPdoc[i].symmetry.symbol))\n        data[\"nsites\"].append(MPdoc[i].nsites)\n        data[\"EHull\"].append(MPdoc[i].energy_above_hull)\n        data[\"BandGap\"].append(MPdoc[i].band_gap)\n    return data\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.get_mp_chemsys","title":"get_mp_chemsys","text":"<pre><code>get_mp_chemsys(chemsys)\n</code></pre> Source code in <code>himatcal/tools/mpdownload.py</code> <pre><code>def get_mp_chemsys(chemsys):\n    # chemsys = 'Li-Fe-O'\n    elements = chemsys.split(\"-\")\n    return mpr.materials.summary.search(\n        elements=elements,\n        fields=[\n            \"material_id\",\n            \"formula_pretty\",\n            \"nsites\",\n            \"symmetry\",\n            \"energy_above_hull\",\n            \"band_gap\",\n        ],\n    )\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.get_mp_formula","title":"get_mp_formula","text":"<pre><code>get_mp_formula(formula)\n</code></pre> Source code in <code>himatcal/tools/mpdownload.py</code> <pre><code>def get_mp_formula(formula):\n    return mpr.materials.summary.search(\n        formula=formula,\n        fields=[\n            \"material_id\",\n            \"formula_pretty\",\n            \"nsites\",\n            \"symmetry\",\n            \"energy_above_hull\",\n            \"band_gap\",\n        ],\n    )\n</code></pre>"},{"location":"reference/himatcal/tools/mpdownload.html#himatcal.tools.mpdownload.get_mp_id","title":"get_mp_id","text":"<pre><code>get_mp_id(material_id)\n</code></pre> Source code in <code>himatcal/tools/mpdownload.py</code> <pre><code>def get_mp_id(material_id):\n    return mpr.materials.summary.search(\n        material_ids=[material_id],\n        fields=[\n            \"material_id\",\n            \"formula_pretty\",\n            \"nsites\",\n            \"symmetry\",\n            \"energy_above_hull\",\n            \"band_gap\",\n        ],\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/ase.html","title":"ase","text":""},{"location":"reference/himatcal/utils/ase.html#himatcal.utils.ase.constraints_indices_add","title":"constraints_indices_add","text":"<pre><code>constraints_indices_add(indices_list, num_add) -&gt; list\n</code></pre> <p>Add a specified number to each index in the given list of indices.</p> <p>Args:     indices_list (list of int): A list of indices to be incremented.     num_add (int): The number to add to each index in the list.</p> <p>Returns     list of int: A new list with each index incremented by the specified number.</p> Source code in <code>himatcal/utils/ase.py</code> <pre><code>def constraints_indices_add(indices_list, num_add) -&gt; list:\n    \"\"\"\n    Add a specified number to each index in the given list of indices.\n\n    Args:\n        indices_list (list of int): A list of indices to be incremented.\n        num_add (int): The number to add to each index in the list.\n\n    Returns\n        list of int: A new list with each index incremented by the specified number.\n    \"\"\"\n    return [x + num_add for x in indices_list]\n</code></pre>"},{"location":"reference/himatcal/utils/ct.html","title":"ct","text":"<p>utils for covalent</p>"},{"location":"reference/himatcal/utils/ct.html#himatcal.utils.ct.extract_gaussian_result","title":"extract_gaussian_result","text":"<pre><code>extract_gaussian_result(results, id)\n</code></pre> Source code in <code>himatcal/utils/ct.py</code> <pre><code>def extract_gaussian_result(results, id):\n    final_scf_energy = results.result['attributes']['final_scf_energy']/27.211385 # convert the uint from a.u. to eV\n    parameters = results.result['parameters']\n    input_atoms = results.result['trajectory'][0]\n    final_atoms = results.result['atoms']\n    write('input.xyz',input_atoms)\n    write('final.xyz',final_atoms)\n    with open('log.yaml','w') as f:\n        f.write(f'dispatch_id: {id}\\n')\n        f.write(f'status: \\'{str(results.status.__str__)}\\'\\n')\n        f.write(f'final_scf_energy (a.u.): {final_scf_energy}\\n')\n        f.write(f'parameters: {parameters}\\n')\n    return final_atoms\n</code></pre>"},{"location":"reference/himatcal/utils/ct.html#himatcal.utils.ct.extract_result","title":"extract_result","text":"<pre><code>extract_result(dispatch_id, return_atoms=True)\n</code></pre> <p>extract the result of a covalent job after Gaussian calculation</p> Source code in <code>himatcal/utils/ct.py</code> <pre><code>def extract_result(dispatch_id, return_atoms=True):    # sourcery skip: avoid-builtin-shadow\n    \"\"\"\n    extract the result of a covalent job after Gaussian calculation\n    \"\"\"\n    import os\n    import pickle as pkl\n\n    from monty.os import cd\n    results = ct.get_result(dispatch_id)\n    dispatch_id = results.dispatch_id\n    # create a folder with the dispatch_id\n    os.makedirs(dispatch_id, exist_ok=True)\n    with cd(dispatch_id):\n        with open(f'{dispatch_id}.pkl','wb') as f:\n            pkl.dump(results,f)\n        try:\n            if return_atoms:\n                return extract_gaussian_result(results, dispatch_id)\n            else:\n                extract_gaussian_result(results, dispatch_id)\n                return results # return covalent results\n        except Exception:\n            if results.status.__eq__(_Status__value='RUNNING'):\n                print('Job is still running')\n            with open('log.yaml','w') as f:\n                f.write(f'dispatch_id: {dispatch_id}\\n')\n                f.write(f'job_status: {str(results.status.__str__)}\\n')\n</code></pre>"},{"location":"reference/himatcal/utils/ct.html#himatcal.utils.ct.get_result","title":"get_result","text":"<pre><code>get_result(dispatch_id, job_dir, wait=False)\n</code></pre> <p>extract result in the job_dir</p> Source code in <code>himatcal/utils/ct.py</code> <pre><code>def get_result(dispatch_id, job_dir, wait=False):\n    \"\"\"\n    extract result in the job_dir\n    \"\"\"\n    from monty.os import cd\n    results = ct.get_result(\n        dispatch_id,\n        wait=wait\n    )\n    if results.status.__eq__(\"COMPLETED\") is True:\n        with cd(job_dir):\n            extract_result(dispatch_id)\n            final_scf_energy = (\n                results.result[\"attributes\"][\"final_scf_energy\"] / 27.211385\n            )  # convert to a.u.\n            atoms = results.result[\"atoms\"]\n            write(\"final.xyz\", atoms)\n            print(f\"final_scf_energy (a.u.): {final_scf_energy}\\n\")\n        return atoms\n    else:\n        print(\"The calculation is not completed.\")\n        return None\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html","title":"locache","text":"<p>https://github.com/jla-gardner/locache/blob/master/locache.py</p> <p>Usage:</p> <p>from locache import persist</p> <p>@persist ... def my_func(x, num=3): ...     print(\"Hi from foo!\") ...     return x * num</p>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache._IS_BASE_FUNC","title":"_IS_BASE_FUNC  <code>module-attribute</code>","text":"<pre><code>_IS_BASE_FUNC = '__is_base_func'\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['persist', 'verbose', 'reset']\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = '4.0.0'\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache._logger","title":"_logger  <code>module-attribute</code>","text":"<pre><code>_logger = getLogger(f'{__name__} : local_cache')\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache._get_cache_location_for","title":"_get_cache_location_for","text":"<pre><code>_get_cache_location_for(func) -&gt; Path | None\n</code></pre> <p>get the cache location for a function</p> <p>this should work wherever the function is defined, i.e. in a file somewhere, in a notebook, or in an interactive session</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>the function to cache</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path | None</code>           \u2013            <p>the cache location, or None if the function is defined in the REPL / can't be found</p> </li> </ul> Source code in <code>himatcal/utils/locache.py</code> <pre><code>def _get_cache_location_for(func) -&gt; Path | None:\n    \"\"\"\n    get the cache location for a function\n\n    this should work wherever the function is defined,\n    i.e. in a file somewhere, in a notebook, or in an\n    interactive session\n\n    Parameters\n    ----------\n    func : Callable\n        the function to cache\n\n\n    Returns\n    -------\n    Path | None\n        the cache location, or None if the function is defined\n        in the REPL / can't be found\n    \"\"\"\n\n    file = inspect.getfile(func)\n\n    # filter out if in a REPL\n    if file == \"&lt;stdin&gt;\":\n        return None\n\n    # default case: func is defined in a file:\n    # location = &lt;path-to-function's-file&gt;.cache/&lt;function-name&gt;\n    path = Path(file).with_suffix(\".cache\")\n\n    # if we're in a notebook, we store the cache in\n    # &lt;cwd&gt;/notebook.cache/&lt;function-name&gt;\n    if \"ipykernel\" in file:\n        path = Path.cwd() / \"notebook.cache\"\n\n    return path / func.__name__\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache.persist","title":"persist","text":"<pre><code>persist(func: Callable[..., T]) -&gt; Callable[..., T]\n</code></pre><pre><code>persist(*, max_entries: int = 100, max_age: int = 365) -&gt; Callable[[Callable[..., T]], Callable[..., T]]\n</code></pre> <pre><code>persist(func: Callable[..., T] | None = None, *, max_entries: int = -1, max_age: int = 365) -&gt; Callable[..., T] | Callable[[Callable[..., T]], Callable[..., T]]\n</code></pre> <p>decorator for caching expensive function calls to disk</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>, default:                   <code>None</code> )           \u2013            <p>the function to cache. In order to be cache-able, all arguments and return value must be pickleable.</p> </li> <li> <code>max_size</code>               (<code>int</code>)           \u2013            <p>maximum number of cached results to keep, by default -1 (no limit)</p> </li> <li> <code>max_age</code>               (<code>int</code>, default:                   <code>365</code> )           \u2013            <p>maximum age of cached results to keep, in days, by default 365</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>the decorated function</p> </li> </ul> Source code in <code>himatcal/utils/locache.py</code> <pre><code>def persist(\n    func: Callable[..., T] | None = None,\n    *,\n    max_entries: int = -1,\n    max_age: int = 365,\n) -&gt; Callable[..., T] | Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"\n    decorator for caching expensive function calls to disk\n\n    Parameters\n    ----------\n    func : Callable, optional\n        the function to cache. In order to be cache-able,\n        all arguments and return value must be pickleable.\n    max_size : int, optional\n        maximum number of cached results to keep, by default -1 (no limit)\n    max_age : int, optional\n        maximum age of cached results to keep, in days, by default 365\n\n    Returns\n    -------\n    Callable\n        the decorated function\n    \"\"\"\n\n    def decorator(f: Callable):\n        # we cache the results of this function call to files\n        # in a directory directly associated with the function\n        location = _get_cache_location_for(f)\n        if location is None:\n            _logger.warning(\n                \"Unable to find the definition of this function. \"\n                \"Perhaps you defined it in the REPL? (This is not \"\n                \"supported.) No caching will happen. Please \"\n                \"raise an issue, if you think this should be \"\n                \"working, at https://github.com/jla-gardner/locache/issues\",\n            )\n            return f\n        _logger.debug(f\"caching {f.__name__} to {location}\")\n\n        # mark this as the base function for caching:\n        # this lets us unwrap any decorators that are applied\n        # on top of @persist in a reliable fashion (see reset)\n        setattr(f, _IS_BASE_FUNC, True)\n\n        @functools.wraps(f)\n        def wrapper(*args, **kwargs):\n            _logger.debug(f\"caching {f.__name__} to {location}\")\n\n            location.mkdir(parents=True, exist_ok=True)\n\n            # within this directory, we use a hash of the function's\n            # source code and arguments as a unique identifier for this\n            # particular function call\n            source_code = inspect.getsource(f)\n            dump = pickle.dumps((source_code, args, kwargs))\n            hashed_fn = sha256(dump).hexdigest()[:32]\n\n            # we save the result of this function call to a file\n            # with this unique identifier as the filename\n            file_path = location / f\"{hashed_fn}.pkl\"\n\n            if file_path.exists():\n                _logger.debug(f\"cache hit for {f.__name__} with {args}, {kwargs}\")\n                with open(file_path, \"rb\") as file:\n                    result = pickle.load(file)\n\n            else:\n                _logger.debug(f\"cache miss for {f.__name__} with {args}, {kwargs}\")\n                result = f(*args, **kwargs)\n                with open(file_path, \"wb\") as file:\n                    pickle.dump(result, file)\n\n            # before returning the result, we clean up the cache:\n\n            # some OS settings disable routine writing to st_atime\n            # (i.e. the file's last access time) so instead we update\n            # the file's last modified time\n            file_path.touch()\n\n            # list files in order of last touched ascending\n            all_files = sorted(location.glob(\"*.pkl\"), key=lambda f: f.stat().st_mtime)\n\n            # remove files if we're over the size limit\n            to_delete = len(all_files) - max_entries\n            if max_entries &gt; 0 and to_delete &gt; 0:\n                deletions = all_files[:to_delete]\n                _logger.info(f\"deleting {deletions} to keep {max_entries} entries\")\n                for file in deletions:\n                    os.remove(file)\n                all_files = all_files[to_delete:]\n\n            # delete all old files\n            now = time.time()\n            ages_days = [(now - f.stat().st_mtime) // (60 * 60 * 24) for f in all_files]\n            for age, file in zip(ages_days, all_files):\n                if age &gt;= max_age:\n                    _logger.info(\n                        f\"deleting {file} because it is {age}(&gt;={max_age}) days old\"\n                    )\n                    os.remove(file)\n\n            return result\n\n        return wrapper\n\n    return decorator(func) if func is not None else decorator\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache.reset","title":"reset","text":"<pre><code>reset(func)\n</code></pre> <p>reset the cache for a function</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            <p>the function to reset the cache for</p> </li> </ul> Source code in <code>himatcal/utils/locache.py</code> <pre><code>def reset(func):\n    \"\"\"\n    reset the cache for a function\n\n    Parameters\n    ----------\n    func : Callable\n        the function to reset the cache for\n    \"\"\"\n\n    # unwrap the function (optionally multiply decorated) func\n    # until we get to the function that would have been passed\n    # to @persist\n\n    og_func = func\n    removed = False\n    while not removed:\n        new_func = getattr(func, \"__wrapped__\", None)\n        removed = getattr(func, _IS_BASE_FUNC, False)\n        if removed:\n            func = new_func\n            break\n\n        if new_func is None:\n            _logger.warning(\n                f\"While attempting to unwrap {og_func.__name__}, \"\n                \"we found that the __wrapped__ attribute was not \"\n                f\"properly propagated through {func.__name__}. This suggests \"\n                \"that:\\n (a) you are using a decorator on top of @persist that does not \"\n                \"set the __wrapped__ attribute, using e.g. functools.wraps\\n (b) you \"\n                \"have passed a function that is not decorated at all.\\n\"\n                \"We can't access the actual function that is being cached, \"\n                \"and therefore no cache will be reset. \"\n            )\n            return\n\n        func = new_func\n\n    # func is now the actual function that would have been\n    # passed to @persist\n    location = _get_cache_location_for(func)\n    if location is not None:\n        shutil.rmtree(location, ignore_errors=True)\n</code></pre>"},{"location":"reference/himatcal/utils/locache.html#himatcal.utils.locache.verbose","title":"verbose","text":"<pre><code>verbose(yes=True)\n</code></pre> <p>set the verbosity of the logging</p> <p>Parameters:</p> <ul> <li> <code>yes</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to log or not, by default True</p> </li> </ul> Source code in <code>himatcal/utils/locache.py</code> <pre><code>def verbose(yes=True):\n    \"\"\"\n    set the verbosity of the logging\n\n    Parameters\n    ----------\n    yes : bool, optional\n        whether to log or not, by default True\n    \"\"\"\n    _logger.setLevel(logging.DEBUG if yes else logging.INFO)\n</code></pre>"},{"location":"reference/himatcal/utils/os.html","title":"os","text":"<p>os utilities for himatcal</p>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.MoleculeInfo","title":"MoleculeInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents information about a molecule, including its label, charge, and multiplicity.</p> <p>This class provides methods to parse charge values and to create an instance from a filename that follows a specific naming convention.</p>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.MoleculeInfo.charge","title":"charge  <code>instance-attribute</code>","text":"<pre><code>charge: int\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.MoleculeInfo.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.MoleculeInfo.mult","title":"mult  <code>instance-attribute</code>","text":"<pre><code>mult: int\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.MoleculeInfo.from_filename","title":"from_filename  <code>classmethod</code>","text":"<pre><code>from_filename(filename: str)\n</code></pre> <p>Creates a MoleculeInfo instance from a filename.</p> <p>The filename must match the pattern '_c', where  can be prefixed with 'n' for negative charges. <p>Args:     filename (str): The filename from which to extract molecule information.</p> <p>Returns:     MoleculeInfo: An instance of MoleculeInfo with the extracted label, charge, and multiplicity.</p> <p>Raises:     ValueError: If the filename does not match the expected format.</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>@classmethod\ndef from_filename(cls, filename: str):\n    \"\"\"Creates a MoleculeInfo instance from a filename.\n\n    The filename must match the pattern '&lt;label&gt;_c&lt;charge&gt;&lt;mult&gt;', where &lt;charge&gt; can be prefixed with 'n' for negative charges.\n\n    Args:\n        filename (str): The filename from which to extract molecule information.\n\n    Returns:\n        MoleculeInfo: An instance of MoleculeInfo with the extracted label, charge, and multiplicity.\n\n    Raises:\n        ValueError: If the filename does not match the expected format.\n    \"\"\"\n    pattern = r\"(.*?)-c(n?\\d)s(\\d+)\"\n    if not (match := re.match(pattern, filename)):\n        raise ValueError(f\"Filename {filename} does not match the expected format\")\n    label, chg, mult = match.groups()\n    return cls(label=label, charge=chg, mult=int(mult))\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.MoleculeInfo.parse_charge","title":"parse_charge","text":"<pre><code>parse_charge(value)\n</code></pre> <p>Parses the charge value from a string format.</p> <p>Args:     value (str): The charge value as a string, which may start with 'n' to indicate a negative charge.</p> <p>Returns:     int: The parsed charge as an integer.</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>@field_validator(\"charge\", mode=\"before\")\ndef parse_charge(cls, value):\n    \"\"\"Parses the charge value from a string format.\n\n    Args:\n        value (str): The charge value as a string, which may start with 'n' to indicate a negative charge.\n\n    Returns:\n        int: The parsed charge as an integer.\n    \"\"\"\n    value = str(value)\n    return -int(value[1:]) if value.startswith(\"n\") else int(value)\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.MoleculeInfo.write_filename","title":"write_filename","text":"<pre><code>write_filename()\n</code></pre> Source code in <code>himatcal/utils/os.py</code> <pre><code>def write_filename(self):\n    return (\n        f\"{self.label}-cn{-self.charge}s{self.mult}\"\n        if self.charge &lt; 0\n        else f\"{self.label}-c{self.charge}s{self.mult}\"\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.cclib_result","title":"cclib_result","text":"<pre><code>cclib_result(log_path: Path)\n</code></pre> <p>Extracts and reads computational chemistry log files.</p> <p>This function checks for compressed log files in the specified directory, decompresses the first found file, and reads the contents using the cclib library. It returns the parsed data from the log file.</p> <p>Args:     log_path (Path): The directory path where log files are located.</p> <p>Returns:     object: The parsed data from the log file.</p> <p>Raises:     FileNotFoundError: If no log files are found and the directory is empty.</p> <p>Examples:     result = cclib_result(Path(\"/path/to/logs\"))</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>def cclib_result(log_path: Path):\n    \"\"\"Extracts and reads computational chemistry log files.\n\n    This function checks for compressed log files in the specified directory, decompresses the first found file, and reads the contents using the cclib library. It returns the parsed data from the log file.\n\n    Args:\n        log_path (Path): The directory path where log files are located.\n\n    Returns:\n        object: The parsed data from the log file.\n\n    Raises:\n        FileNotFoundError: If no log files are found and the directory is empty.\n\n    Examples:\n        result = cclib_result(Path(\"/path/to/logs\"))\n    \"\"\"\n\n    import contextlib\n    import gzip\n\n    import cclib\n\n    with contextlib.suppress(FileNotFoundError):\n        if gzip_log := list(log_path.glob(\"*.log.gz\")):\n            unzip_file = gzip.decompress(Path.open(gzip_log[0], \"rb\").read())\n            logfile = gzip_log[0].with_suffix(\"\")\n            with Path.open(logfile, \"w\") as f:\n                f.write(unzip_file.decode())\n        log_files = list(log_path.glob(\"*.log\"))\n        return parse_logfile(log_path / log_files[0])\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.extract_fchk","title":"extract_fchk","text":"<pre><code>extract_fchk(label, dzip=False)\n</code></pre> <p>Extracts the formatted checkpoint file (.fchk) from a Gaussian checkpoint file (.chk).</p> <p>Args:     label (str): The label to use for the extracted .fchk file.     dzip (bool, optional): Whether to decompress the Gaussian checkpoint file if it is gzipped.</p> <p>Returns:     None</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>def extract_fchk(label, dzip=False):\n    \"\"\"\n    Extracts the formatted checkpoint file (.fchk) from a Gaussian checkpoint file (.chk).\n\n    Args:\n        label (str): The label to use for the extracted .fchk file.\n        dzip (bool, optional): Whether to decompress the Gaussian checkpoint file if it is gzipped.\n\n    Returns:\n        None\n    \"\"\"\n    if dzip:\n        os.system(\"gzip -d Gaussian.chk.gz\")\n    chk_file = Path(\"Gaussian.chk\")\n    if not Path.exists(chk_file):\n        logging.info(f\"{chk_file} not found\")\n        return\n    os.system(f\"formchk {chk_file}\")\n    os.system(f\"mv Gaussian.fchk {label}.fchk\")\n    logging.info(f\"fchk file extracted for {label}\")\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.get_chg_mult","title":"get_chg_mult","text":"<pre><code>get_chg_mult(molname: str)\n</code></pre> <p>Get the label, charge, and multiplicity from the name of a molecule. Deprecated: Method moved to MoleculeInfo(BaseModel)</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>def get_chg_mult(molname: str):\n    \"\"\"\n    Get the label, charge, and multiplicity from the name of a molecule.\n    Deprecated: Method moved to MoleculeInfo(BaseModel)\n    \"\"\"\n    mol_info = MoleculeInfo.from_filename(molname)\n    return mol_info.label, mol_info.charge, mol_info.mult\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.get_homo_lumo","title":"get_homo_lumo","text":"<pre><code>get_homo_lumo(logfile: str)\n</code></pre> <p>Extracts HOMO, LUMO, and related energies and gaps from a computational chemistry log file.</p> <p>Args:     logfile (str): Path to the computational chemistry log file.</p> <p>Returns:     dict: A dictionary containing HOMO and LUMO orbitals, energies, gaps, and the minimum HOMO-LUMO gap.</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>def get_homo_lumo(logfile: str):\n    \"\"\"\n    Extracts HOMO, LUMO, and related energies and gaps from a computational chemistry log file.\n\n    Args:\n        logfile (str): Path to the computational chemistry log file.\n\n    Returns:\n        dict: A dictionary containing HOMO and LUMO orbitals, energies, gaps, and the minimum HOMO-LUMO gap.\n    \"\"\"\n\n    data = parse_logfile(logfile)\n    HOMO = data.homos + 1\n    LUMO = data.homos + 2\n    homo_energies, lumo_energies, gaps = parse_homo_lumo(logfile)\n    min_gap = min(gaps)\n    return {\n        \"homo_orbital\": HOMO,\n        \"lumo_orbital\": LUMO,\n        \"homo_energies\": homo_energies,\n        \"lumo_energies\": lumo_energies,\n        \"homo_lumo_gaps\": gaps,\n        \"min_homo_lumo_gap\": min_gap,\n    }\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.labeled_dir","title":"labeled_dir","text":"<pre><code>labeled_dir(main_workdir: Path, label: str)\n</code></pre> <p>Create a new folder in the main working directory with the provided label.</p> <p>Args:     main_workdir (Path): The main working directory.     label (str): The label of the folder.</p> <p>Returns:     Path: The path of the new folder.</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>def labeled_dir(main_workdir: Path, label: str):\n    \"\"\"\n    Create a new folder in the main working directory with the provided label.\n\n    Args:\n        main_workdir (Path): The main working directory.\n        label (str): The label of the folder.\n\n    Returns:\n        Path: The path of the new folder.\n    \"\"\"\n    folder_names = [p.name for p in main_workdir.iterdir() if p.is_dir()]\n    numbers = (\n        int(re.search(r\"\\d+\", name).group())\n        for name in folder_names\n        if re.search(r\"\\d+\", name)\n    )\n    new_number = max(numbers, default=0) + 1\n    # Create new folder\n    folder_name = f\"{new_number:02d}.{label}\"\n    folder_path = main_workdir / folder_name\n    Path.mkdir(folder_path, parents=True, exist_ok=True)\n    return folder_path\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.parse_homo_lumo","title":"parse_homo_lumo","text":"<pre><code>parse_homo_lumo(logfile: str)\n</code></pre> <p>Extracts the highest occupied molecular orbital (HOMO) and lowest unoccupied molecular orbital (LUMO) energies from a specified logfile. This function computes the HOMO and LUMO energies along with the energy gaps between them, providing insights into the electronic structure of the molecule.</p> <p>Args:     logfile (str): The path to the logfile containing molecular orbital energies.</p> <p>Returns:     tuple: A tuple containing three elements:         - List of HOMO energies.         - List of LUMO energies or None if not available.         - List of HOMO-LUMO energy gaps or None if not available.</p> <p>Raises:     ValueError: If the logfile does not contain valid data.</p> <p>Examples:     &gt;&gt;&gt; homo_energies, lumo_energies, gaps = parse_homo_lumo(\"path/to/logfile.log\")</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>def parse_homo_lumo(logfile: str):\n    \"\"\"\n    Extracts the highest occupied molecular orbital (HOMO) and lowest unoccupied molecular orbital (LUMO) energies from a specified logfile.\n    This function computes the HOMO and LUMO energies along with the energy gaps between them, providing insights into the electronic structure of the molecule.\n\n    Args:\n        logfile (str): The path to the logfile containing molecular orbital energies.\n\n    Returns:\n        tuple: A tuple containing three elements:\n            - List of HOMO energies.\n            - List of LUMO energies or None if not available.\n            - List of HOMO-LUMO energy gaps or None if not available.\n\n    Raises:\n        ValueError: If the logfile does not contain valid data.\n\n    Examples:\n        &gt;&gt;&gt; homo_energies, lumo_energies, gaps = parse_homo_lumo(\"path/to/logfile.log\")\n    \"\"\"\n    data = parse_logfile(logfile)\n    moenergies = data.moenergies  # type: ignore\n    homo_indices = data.homos  # type: ignore\n    homo_energies = [moenergies[i][h] for i, h in enumerate(homo_indices)]\n\n    for i, h in enumerate(homo_indices):\n        if len(moenergies[i]) &lt; h + 2:\n            return homo_energies, None, None\n    lumo_energies = [moenergies[i][h + 1] for i, h in enumerate(homo_indices)]\n    homo_lumo_gaps = [\n        lumo_energies[i] - homo_energies[i] for i in range(len(homo_energies))\n    ]\n    return homo_energies, lumo_energies, homo_lumo_gaps\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.parse_logfile","title":"parse_logfile","text":"<pre><code>parse_logfile(logfile: str)\n</code></pre> <p>Parses a Gaussian log file to extract computational chemistry data. This function utilizes the cclib library to read and parse the contents of the specified logfile, returning structured data for further analysis.</p> <p>Args:     logfile (str): The path to the logfile to be parsed.</p> <p>Returns:     object: A structured data object containing the parsed information from the logfile.</p> <p>Raises:     FileNotFoundError: If the specified logfile does not exist.     ValueError: If the logfile cannot be parsed due to invalid format.</p> <p>Examples:     &gt;&gt;&gt; data = parse_logfile(\"path/to/logfile.log\")</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>@persist\ndef parse_logfile(logfile: str):\n    \"\"\"\n    Parses a Gaussian log file to extract computational chemistry data.\n    This function utilizes the cclib library to read and parse the contents of the specified logfile, returning structured data for further analysis.\n\n    Args:\n        logfile (str): The path to the logfile to be parsed.\n\n    Returns:\n        object: A structured data object containing the parsed information from the logfile.\n\n    Raises:\n        FileNotFoundError: If the specified logfile does not exist.\n        ValueError: If the logfile cannot be parsed due to invalid format.\n\n    Examples:\n        &gt;&gt;&gt; data = parse_logfile(\"path/to/logfile.log\")\n    \"\"\"\n\n    import cclib\n\n    return cclib.io.ccopen(logfile).parse()  # type: ignore\n</code></pre>"},{"location":"reference/himatcal/utils/os.html#himatcal.utils.os.write_chg_mult_label","title":"write_chg_mult_label","text":"<pre><code>write_chg_mult_label(label, chg, mult)\n</code></pre> <p>Write the label, chg and mult to a string, format: {label}-c{charge}s{mult}</p> Source code in <code>himatcal/utils/os.py</code> <pre><code>def write_chg_mult_label(label, chg, mult):\n    \"\"\"Write the label, chg and mult to a string, format: {label}-c{charge}s{mult}\"\"\"\n    return MoleculeInfo(label=label, charge=chg, mult=mult).write_filename()\n</code></pre>"},{"location":"reference/himatcal/utils/pretty.html","title":"pretty","text":""},{"location":"reference/himatcal/utils/pretty.html#himatcal.utils.pretty.random_logo","title":"random_logo","text":"<pre><code>random_logo()\n</code></pre> <p>return random ascii logo</p> Source code in <code>himatcal/utils/pretty.py</code> <pre><code>def random_logo():\n    \"\"\"return random ascii logo\"\"\"\n    logo_list = [\n        \"\"\"\n\n \u2588\u2584\u2588 \u2588 \u2588\u2584 \u2584\u2588 \u2584\u2580\u2584 \u2580\u2588\u2580 \u2584\u2580\u2580 \u2584\u2580\u2584 \u2588  \n \u2588 \u2588 \u2588 \u2588 \u2580 \u2588 \u2588\u2580\u2588  \u2588  \u2580\u2584\u2584 \u2588\u2580\u2588 \u2588\u2584\u2584\"\"\",\n        \"\"\"\n\n\u2591\u2591   \u2591\u2591 \u2591\u2591 \u2591\u2591\u2591    \u2591\u2591\u2591  \u2591\u2591\u2591\u2591\u2591  \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \u2591\u2591\u2591\u2591\u2591\u2591  \u2591\u2591\u2591\u2591\u2591  \u2591\u2591      \n\u2592\u2592   \u2592\u2592 \u2592\u2592 \u2592\u2592\u2592\u2592  \u2592\u2592\u2592\u2592 \u2592\u2592   \u2592\u2592    \u2592\u2592    \u2592\u2592      \u2592\u2592   \u2592\u2592 \u2592\u2592      \n\u2592\u2592\u2592\u2592\u2592\u2592\u2592 \u2592\u2592 \u2592\u2592 \u2592\u2592\u2592\u2592 \u2592\u2592 \u2592\u2592\u2592\u2592\u2592\u2592\u2592    \u2592\u2592    \u2592\u2592      \u2592\u2592\u2592\u2592\u2592\u2592\u2592 \u2592\u2592      \n\u2593\u2593   \u2593\u2593 \u2593\u2593 \u2593\u2593  \u2593\u2593  \u2593\u2593 \u2593\u2593   \u2593\u2593    \u2593\u2593    \u2593\u2593      \u2593\u2593   \u2593\u2593 \u2593\u2593      \n\u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588 \u2588\u2588   \u2588\u2588    \u2588\u2588     \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \n\"\"\",\n        \"\"\"\n\n      :::    ::: :::::::::::   :::   :::       ::: ::::::::::: ::::::::      :::     :::  \n     :+:    :+:     :+:      :+:+: :+:+:    :+: :+:   :+:    :+:    :+:   :+: :+:   :+:   \n    +:+    +:+     +:+     +:+ +:+:+ +:+  +:+   +:+  +:+    +:+         +:+   +:+  +:+    \n   +#++:++#++     +#+     +#+  +:+  +#+ +#++:++#++: +#+    +#+        +#++:++#++: +#+     \n  +#+    +#+     +#+     +#+       +#+ +#+     +#+ +#+    +#+        +#+     +#+ +#+      \n #+#    #+#     #+#     #+#       #+# #+#     #+# #+#    #+#    #+# #+#     #+# #+#       \n###    ### ########### ###       ### ###     ### ###     ########  ###     ### ########## \n\"\"\",\n        \"\"\"\n\n.##..##..######..##...##...####...######...####....####...##.....\n.##..##....##....###.###..##..##....##....##..##..##..##..##.....\n.######....##....##.#.##..######....##....##......######..##.....\n.##..##....##....##...##..##..##....##....##..##..##..##..##.....\n.##..##..######..##...##..##..##....##.....####...##..##..######.\n.................................................................\n\"\"\",\n        \"\"\"\n                \u2584\u2584                                                   \u2584\u2584  \n\u2580\u2588\u2588\u2588\u2588\u2580  \u2580\u2588\u2588\u2588\u2588\u2580\u2580 \u2588\u2588 \u2580\u2588\u2588\u2588\u2588\u2584     \u2584\u2588\u2588\u2588\u2580         \u2588\u2588    \u2584\u2584\u2588\u2580\u2580\u2580\u2588\u2584\u2588        \u2580\u2588\u2588\u2588  \n  \u2588\u2588      \u2588\u2588         \u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588           \u2588\u2588  \u2584\u2588\u2588\u2580     \u2580\u2588          \u2588\u2588  \n  \u2588\u2588      \u2588\u2588  \u2580\u2588\u2588\u2588   \u2588 \u2588\u2588   \u2584\u2588 \u2588\u2588  \u2584\u2588\u2580\u2588\u2588\u2584 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580       \u2580\u2584\u2588\u2580\u2588\u2588\u2584    \u2588\u2588  \n  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588   \u2588  \u2588\u2588  \u2588\u2580 \u2588\u2588 \u2588\u2588   \u2588\u2588   \u2588\u2588  \u2588\u2588        \u2588\u2588   \u2588\u2588    \u2588\u2588  \n  \u2588\u2588      \u2588\u2588    \u2588\u2588   \u2588  \u2588\u2588\u2584\u2588\u2580  \u2588\u2588  \u2584\u2588\u2588\u2588\u2588\u2588   \u2588\u2588  \u2588\u2588\u2584        \u2584\u2588\u2588\u2588\u2588\u2588    \u2588\u2588  \n  \u2588\u2588      \u2588\u2588    \u2588\u2588   \u2588  \u2580\u2588\u2588\u2580   \u2588\u2588 \u2588\u2588   \u2588\u2588   \u2588\u2588  \u2580\u2588\u2588\u2584     \u2584\u2580\u2588   \u2588\u2588    \u2588\u2588  \n\u2584\u2588\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2588\u2584\u2584\u2588\u2588\u2588\u2588\u2584\u2588\u2588\u2588\u2584 \u2580\u2580  \u2584\u2588\u2588\u2588\u2588\u2584\u2588\u2588\u2588\u2588\u2580\u2588\u2588\u2584 \u2580\u2588\u2588\u2588\u2588 \u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2588\u2580\u2588\u2588\u2584\u2584\u2588\u2588\u2588\u2588\u2584\n\n\"\"\",\n        \"\"\"\n\n\n\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\"\"\",\n        \"\"\"\n\n \u2584\u2584   \u2584\u2584 \u2584\u2584\u2584 \u2584\u2584   \u2584\u2584 \u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584\u2584\u2584\u2584 \u2584\u2584\u2584     \n\u2588  \u2588 \u2588  \u2588   \u2588  \u2588\u2584\u2588  \u2588      \u2588       \u2588       \u2588      \u2588   \u2588    \n\u2588  \u2588\u2584\u2588  \u2588   \u2588       \u2588  \u2584   \u2588\u2584     \u2584\u2588       \u2588  \u2584   \u2588   \u2588    \n\u2588       \u2588   \u2588       \u2588 \u2588\u2584\u2588  \u2588 \u2588   \u2588 \u2588     \u2584\u2584\u2588 \u2588\u2584\u2588  \u2588   \u2588    \n\u2588   \u2584   \u2588   \u2588       \u2588      \u2588 \u2588   \u2588 \u2588    \u2588  \u2588      \u2588   \u2588\u2584\u2584\u2584 \n\u2588  \u2588 \u2588  \u2588   \u2588 \u2588\u2588\u2584\u2588\u2588 \u2588  \u2584   \u2588 \u2588   \u2588 \u2588    \u2588\u2584\u2584\u2588  \u2584   \u2588       \u2588\n\u2588\u2584\u2584\u2588 \u2588\u2584\u2584\u2588\u2584\u2584\u2584\u2588\u2584\u2588   \u2588\u2584\u2588\u2584\u2588 \u2588\u2584\u2584\u2588 \u2588\u2584\u2584\u2584\u2588 \u2588\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2588\u2584\u2588 \u2588\u2584\u2584\u2588\u2584\u2584\u2584\u2584\u2584\u2584\u2584\u2588\n\"\"\",\n        \"\"\"\n\n'##::::'##:'####:'##::::'##::::'###::::'########::'######:::::'###::::'##:::::::\n ##:::: ##:. ##:: ###::'###:::'## ##:::... ##..::'##... ##:::'## ##::: ##:::::::\n ##:::: ##:: ##:: ####'####::'##:. ##::::: ##:::: ##:::..:::'##:. ##:: ##:::::::\n #########:: ##:: ## ### ##:'##:::. ##:::: ##:::: ##:::::::'##:::. ##: ##:::::::\n ##.... ##:: ##:: ##. #: ##: #########:::: ##:::: ##::::::: #########: ##:::::::\n ##:::: ##:: ##:: ##:.:: ##: ##.... ##:::: ##:::: ##::: ##: ##.... ##: ##:::::::\n ##:::: ##:'####: ##:::: ##: ##:::: ##:::: ##::::. ######:: ##:::: ##: ########:\n..:::::..::....::..:::::..::..:::::..:::::..::::::......:::..:::::..::........::\n\"\"\",\n    ]\n    return random.choice(logo_list)\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html","title":"rmsd","text":"<p>Calculate Root-mean-square deviation (RMSD) between structure A and B, in XYZ or PDB format, using transformation and rotation.</p> <p>For more information, usage, example and citation read more at https://github.com/charnley/rmsd</p>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.AXIS_REFLECTIONS","title":"AXIS_REFLECTIONS  <code>module-attribute</code>","text":"<pre><code>AXIS_REFLECTIONS = array([[1, 1, 1], [-1, 1, 1], [1, -1, 1], [1, 1, -1], [-1, -1, 1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1]])\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.AXIS_SWAPS","title":"AXIS_SWAPS  <code>module-attribute</code>","text":"<pre><code>AXIS_SWAPS = array([[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 1, 0], [2, 0, 1]])\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.ELEMENT_NAMES","title":"ELEMENT_NAMES  <code>module-attribute</code>","text":"<pre><code>ELEMENT_NAMES = {1: 'H', 2: 'He', 3: 'Li', 4: 'Be', 5: 'B', 6: 'C', 7: 'N', 8: 'O', 9: 'F', 10: 'Ne', 11: 'Na', 12: 'Mg', 13: 'Al', 14: 'Si', 15: 'P', 16: 'S', 17: 'Cl', 18: 'Ar', 19: 'K', 20: 'Ca', 21: 'Sc', 22: 'Ti', 23: 'V', 24: 'Cr', 25: 'Mn', 26: 'Fe', 27: 'Co', 28: 'Ni', 29: 'Cu', 30: 'Zn', 31: 'Ga', 32: 'Ge', 33: 'As', 34: 'Se', 35: 'Br', 36: 'Kr', 37: 'Rb', 38: 'Sr', 39: 'Y', 40: 'Zr', 41: 'Nb', 42: 'Mo', 43: 'Tc', 44: 'Ru', 45: 'Rh', 46: 'Pd', 47: 'Ag', 48: 'Cd', 49: 'In', 50: 'Sn', 51: 'Sb', 52: 'Te', 53: 'I', 54: 'Xe', 55: 'Cs', 56: 'Ba', 57: 'La', 58: 'Ce', 59: 'Pr', 60: 'Nd', 61: 'Pm', 62: 'Sm', 63: 'Eu', 64: 'Gd', 65: 'Tb', 66: 'Dy', 67: 'Ho', 68: 'Er', 69: 'Tm', 70: 'Yb', 71: 'Lu', 72: 'Hf', 73: 'Ta', 74: 'W', 75: 'Re', 76: 'Os', 77: 'Ir', 78: 'Pt', 79: 'Au', 80: 'Hg', 81: 'Tl', 82: 'Pb', 83: 'Bi', 84: 'Po', 85: 'At', 86: 'Rn', 87: 'Fr', 88: 'Ra', 89: 'Ac', 90: 'Th', 91: 'Pa', 92: 'U', 93: 'Np', 94: 'Pu', 95: 'Am', 96: 'Cm', 97: 'Bk', 98: 'Cf', 99: 'Es', 100: 'Fm', 101: 'Md', 102: 'No', 103: 'Lr', 104: 'Rf', 105: 'Db', 106: 'Sg', 107: 'Bh', 108: 'Hs', 109: 'Mt', 110: 'Ds', 111: 'Rg', 112: 'Cn', 114: 'Uuq', 116: 'Uuh'}\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.ELEMENT_WEIGHTS","title":"ELEMENT_WEIGHTS  <code>module-attribute</code>","text":"<pre><code>ELEMENT_WEIGHTS = {1: 1.00797, 2: 4.0026, 3: 6.941, 4: 9.01218, 5: 10.81, 6: 12.011, 7: 14.0067, 8: 15.9994, 9: 18.998403, 10: 20.179, 11: 22.98977, 12: 24.305, 13: 26.98154, 14: 28.0855, 15: 30.97376, 16: 32.06, 17: 35.453, 19: 39.0983, 18: 39.948, 20: 40.08, 21: 44.9559, 22: 47.9, 23: 50.9415, 24: 51.996, 25: 54.938, 26: 55.847, 28: 58.7, 27: 58.9332, 29: 63.546, 30: 65.38, 31: 69.72, 32: 72.59, 33: 74.9216, 34: 78.96, 35: 79.904, 36: 83.8, 37: 85.4678, 38: 87.62, 39: 88.9059, 40: 91.22, 41: 92.9064, 42: 95.94, 43: 98, 44: 101.07, 45: 102.9055, 46: 106.4, 47: 107.868, 48: 112.41, 49: 114.82, 50: 118.69, 51: 121.75, 53: 126.9045, 52: 127.6, 54: 131.3, 55: 132.9054, 56: 137.33, 57: 138.9055, 58: 140.12, 59: 140.9077, 60: 144.24, 61: 145, 62: 150.4, 63: 151.96, 64: 157.25, 65: 158.9254, 66: 162.5, 67: 164.9304, 68: 167.26, 69: 168.9342, 70: 173.04, 71: 174.967, 72: 178.49, 73: 180.9479, 74: 183.85, 75: 186.207, 76: 190.2, 77: 192.22, 78: 195.09, 79: 196.9665, 80: 200.59, 81: 204.37, 82: 207.2, 83: 208.9804, 84: 209, 85: 210, 86: 222, 87: 223, 88: 226.0254, 89: 227.0278, 91: 231.0359, 90: 232.0381, 93: 237.0482, 92: 238.029, 94: 242, 95: 243, 97: 247, 96: 247, 102: 250, 98: 251, 99: 252, 108: 255, 109: 256, 100: 257, 101: 258, 103: 260, 104: 261, 107: 262, 105: 262, 106: 263, 110: 269, 111: 272, 112: 277}\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.FORMATS","title":"FORMATS  <code>module-attribute</code>","text":"<pre><code>FORMATS = [FORMAT_XYZ, FORMAT_PDB]\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.FORMAT_PDB","title":"FORMAT_PDB  <code>module-attribute</code>","text":"<pre><code>FORMAT_PDB = 'pdb'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.FORMAT_XYZ","title":"FORMAT_XYZ  <code>module-attribute</code>","text":"<pre><code>FORMAT_XYZ = 'xyz'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.METHOD_KABSCH","title":"METHOD_KABSCH  <code>module-attribute</code>","text":"<pre><code>METHOD_KABSCH = 'kabsch'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.METHOD_NOROTATION","title":"METHOD_NOROTATION  <code>module-attribute</code>","text":"<pre><code>METHOD_NOROTATION = 'none'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.METHOD_QUATERNION","title":"METHOD_QUATERNION  <code>module-attribute</code>","text":"<pre><code>METHOD_QUATERNION = 'quaternion'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.NAMES_ELEMENT","title":"NAMES_ELEMENT  <code>module-attribute</code>","text":"<pre><code>NAMES_ELEMENT = {value: _jmfor (key, value) in items()}\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.REORDER_BRUTE","title":"REORDER_BRUTE  <code>module-attribute</code>","text":"<pre><code>REORDER_BRUTE = 'brute'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.REORDER_DISTANCE","title":"REORDER_DISTANCE  <code>module-attribute</code>","text":"<pre><code>REORDER_DISTANCE = 'distance'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.REORDER_HUNGARIAN","title":"REORDER_HUNGARIAN  <code>module-attribute</code>","text":"<pre><code>REORDER_HUNGARIAN = 'hungarian'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.REORDER_INERTIA_HUNGARIAN","title":"REORDER_INERTIA_HUNGARIAN  <code>module-attribute</code>","text":"<pre><code>REORDER_INERTIA_HUNGARIAN = 'inertia-hungarian'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.REORDER_METHODS","title":"REORDER_METHODS  <code>module-attribute</code>","text":"<pre><code>REORDER_METHODS = [REORDER_NONE, REORDER_QML, REORDER_HUNGARIAN, REORDER_INERTIA_HUNGARIAN, REORDER_BRUTE, REORDER_DISTANCE]\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.REORDER_NONE","title":"REORDER_NONE  <code>module-attribute</code>","text":"<pre><code>REORDER_NONE = 'none'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.REORDER_QML","title":"REORDER_QML  <code>module-attribute</code>","text":"<pre><code>REORDER_QML = 'qml'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.ROTATION_METHODS","title":"ROTATION_METHODS  <code>module-attribute</code>","text":"<pre><code>ROTATION_METHODS = [METHOD_KABSCH, METHOD_QUATERNION, METHOD_NOROTATION]\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = '1.5.1'\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.result","title":"result  <code>module-attribute</code>","text":"<pre><code>result = main()\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.ReorderCallable","title":"ReorderCallable","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.ReorderCallable.__call__","title":"__call__","text":"<pre><code>__call__(p_atoms: ndarray, q_atoms: ndarray, p_coord: ndarray, q_coord: ndarray, **kwargs: Any) -&gt; ndarray\n</code></pre> <p>Protocol for a reorder callable function</p> <p>Return:     ndarray dtype=int  # Array of indices</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def __call__(\n    self,\n    p_atoms: ndarray,\n    q_atoms: ndarray,\n    p_coord: ndarray,\n    q_coord: ndarray,\n    **kwargs: Any,\n) -&gt; ndarray:\n    \"\"\"\n    Protocol for a reorder callable function\n\n    Return:\n        ndarray dtype=int  # Array of indices\n    \"\"\"\n    ...  # pragma: no cover\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.RmsdCallable","title":"RmsdCallable","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.RmsdCallable.__call__","title":"__call__","text":"<pre><code>__call__(P: ndarray, Q: ndarray, **kwargs: Any) -&gt; float\n</code></pre> <p>Protocol for a rotation callable function</p> <p>return:     RMSD after rotation</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def __call__(\n    self,\n    P: ndarray,\n    Q: ndarray,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    Protocol for a rotation callable function\n\n    return:\n        RMSD after rotation\n    \"\"\"\n    ...  # pragma: no cover\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd._parse_pdb_alphacarbon_line","title":"_parse_pdb_alphacarbon_line","text":"<pre><code>_parse_pdb_alphacarbon_line(line: str) -&gt; bool\n</code></pre> <p>Try to read Alpha carbons based on PDB column-based format</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def _parse_pdb_alphacarbon_line(line: str) -&gt; bool:\n    \"\"\"Try to read Alpha carbons based on PDB column-based format\"\"\"\n\n    atom_col = line[12:16]\n    atom = atom_col[0:2]\n    atom = re.sub(r\"\\d\", \" \", atom)\n    atom = atom.strip()\n    atom = atom.capitalize()\n    location = atom_col[2]\n\n    if atom == \"C\" and location == \"A\":\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd._parse_pdb_atom_line","title":"_parse_pdb_atom_line","text":"<pre><code>_parse_pdb_atom_line(line: str) -&gt; Optional[str]\n</code></pre> <p>Will try it best to find atom from an atom-line. The standard of PDB should be column based, however, there are many examples of non-standard files. We try our best to have a minimal reader.</p> <p>From PDB Format 1992 pdf:</p> <pre><code>ATOM Atomic coordinate records for \"standard\" groups\nHETATM Atomic coordinate records for \"non-standard\" groups\n\nCols. 1 - 4  ATOM\n   or 1 - 6  HETATM\n\n      7 - 11 Atom serial number(i)\n     13 - 16 Atom name(ii)\n     17      Alternate location indicator(iii)\n     18 - 20 Residue name(iv,v)\n     22      Chain identifier, e.g., A for hemoglobin \u03b1 chain\n     23 - 26 Residue seq. no.\n     27      Code for insertions of residues, e.g., 66A, 66B, etc.\n     31 - 38 X\n     39 - 46 Y Orthogonal \u00c5 coordinates\n     47 - 54 Z\n     55 - 60 Occupancy\n     61 - 66 Temperature factor(vi)\n     68 - 70 Footnote number\n\nFor (II)\n\nWithin each residue the atoms occur in the order specified by the\nsuperscripts. The extra oxygen atom of the carboxy terminal amino acid\nis designated OXT\n\nFour characters are reserved for these atom names. They are assigned as\nfollows:\n\n1-2 Chemical symbol - right justified\n3 Remoteness indicator (alphabetic)\n4 Branch designator (numeric)\n\nFor protein coordinate sets containing hydrogen atoms, the IUPAC-IUB\nrules1 have been followed. Recommendation rule number 4.4 has been\nmodified as follows: When more than one hydrogen atom is bonded to a\nsingle non-hydrogen atom, the hydrogen atom number designation is given\nas the first character of the atom name rather than as the last\ncharacter (e.g. H\u03b21 is denoted as 1HB). Exceptions to these rules may\noccur in certain data sets at the depositors\u2019 request. Any such\nexceptions will be delineated clearly in FTNOTE and REMARK records\n</code></pre> <p>but, from [PDB Format Version 2.1]</p> <pre><code>In large het groups it sometimes is not possible to follow the\nconvention of having the first two characters be the chemical symbol\nand still use atom names that are meaningful to users. A example is\nnicotinamide adenine dinucleotide, atom names begin with an A or N,\ndepending on which portion of the molecule they appear in, e.g., AC6 or\nNC6, AN1 or NN1.\n\nHydrogen naming sometimes conflicts with IUPAC conventions. For\nexample, a hydrogen named HG11 in columns 13 - 16 is differentiated\nfrom a mercury atom by the element symbol in columns 77 - 78. Columns\n13 - 16 present a unique name for each atom.\n</code></pre> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def _parse_pdb_atom_line(line: str) -&gt; Optional[str]:\n    \"\"\"\n    Will try it best to find atom from an atom-line. The standard of PDB\n    *should* be column based, however, there are many examples of non-standard\n    files. We try our best to have a minimal reader.\n\n    From PDB Format 1992 pdf:\n\n        ATOM Atomic coordinate records for \"standard\" groups\n        HETATM Atomic coordinate records for \"non-standard\" groups\n\n        Cols. 1 - 4  ATOM\n           or 1 - 6  HETATM\n\n              7 - 11 Atom serial number(i)\n             13 - 16 Atom name(ii)\n             17      Alternate location indicator(iii)\n             18 - 20 Residue name(iv,v)\n             22      Chain identifier, e.g., A for hemoglobin \u03b1 chain\n             23 - 26 Residue seq. no.\n             27      Code for insertions of residues, e.g., 66A, 66B, etc.\n             31 - 38 X\n             39 - 46 Y Orthogonal \u00c5 coordinates\n             47 - 54 Z\n             55 - 60 Occupancy\n             61 - 66 Temperature factor(vi)\n             68 - 70 Footnote number\n\n        For (II)\n\n        Within each residue the atoms occur in the order specified by the\n        superscripts. The extra oxygen atom of the carboxy terminal amino acid\n        is designated OXT\n\n        Four characters are reserved for these atom names. They are assigned as\n        follows:\n\n        1-2 Chemical symbol - right justified\n        3 Remoteness indicator (alphabetic)\n        4 Branch designator (numeric)\n\n        For protein coordinate sets containing hydrogen atoms, the IUPAC-IUB\n        rules1 have been followed. Recommendation rule number 4.4 has been\n        modified as follows: When more than one hydrogen atom is bonded to a\n        single non-hydrogen atom, the hydrogen atom number designation is given\n        as the first character of the atom name rather than as the last\n        character (e.g. H\u03b21 is denoted as 1HB). Exceptions to these rules may\n        occur in certain data sets at the depositors\u2019 request. Any such\n        exceptions will be delineated clearly in FTNOTE and REMARK records\n\n    but, from [PDB Format Version 2.1]\n\n        In large het groups it sometimes is not possible to follow the\n        convention of having the first two characters be the chemical symbol\n        and still use atom names that are meaningful to users. A example is\n        nicotinamide adenine dinucleotide, atom names begin with an A or N,\n        depending on which portion of the molecule they appear in, e.g., AC6 or\n        NC6, AN1 or NN1.\n\n        Hydrogen naming sometimes conflicts with IUPAC conventions. For\n        example, a hydrogen named HG11 in columns 13 - 16 is differentiated\n        from a mercury atom by the element symbol in columns 77 - 78. Columns\n        13 - 16 present a unique name for each atom.\n\n    \"\"\"\n\n    atom_col = line[12:16]\n    atom = atom_col[0:2]\n    atom = re.sub(r\"\\d\", \" \", atom)\n    atom = atom.strip()\n    atom = atom.capitalize()\n\n    # Highly unlikely that it is Mercury, Helium, Hafnium etc. See comment in\n    # function description. [PDB Format v2.1]\n    if len(atom) == 2 and atom[0] == \"H\":\n        atom = \"H\"\n\n    if atom in NAMES_ELEMENT:\n        return atom\n\n    tokens = line.split()\n    atom = tokens[2][0]\n    if atom in NAMES_ELEMENT:\n        return atom\n\n    # e.g. 1HD1\n    atom = tokens[2][1]\n    if atom.upper() == \"H\":\n        return atom\n\n    return None\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd._parse_pdb_coord_line","title":"_parse_pdb_coord_line","text":"<pre><code>_parse_pdb_coord_line(line: str)\n</code></pre> <p>Try my best to coordinates from a PDB ATOM or HETATOM line</p> <p>The coordinates should be located in     31 - 38 X     39 - 46 Y     47 - 54 Z</p> <p>as defined in PDB, ATOMIC COORDINATE AND BIBLIOGRAPHIC ENTRY FORMAT DESCRIPTION, Feb, 1992</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def _parse_pdb_coord_line(line: str):\n    \"\"\"\n    Try my best to coordinates from a PDB ATOM or HETATOM line\n\n    The coordinates should be located in\n        31 - 38 X\n        39 - 46 Y\n        47 - 54 Z\n\n    as defined in PDB, ATOMIC COORDINATE AND BIBLIOGRAPHIC ENTRY FORMAT DESCRIPTION, Feb, 1992\n    \"\"\"\n\n    # If that doesn't work, use hardcoded indices\n    try:\n        x = line[30:38]\n        y = line[38:46]\n        z = line[46:54]\n        coord = np.asarray([x, y, z], dtype=float)\n        return coord\n\n    except ValueError:\n        coord = None\n\n    tokens = line.split()\n\n    x_column: Optional[int] = None\n\n    # look for x column\n    for i, x in enumerate(tokens):\n        if \".\" in x and \".\" in tokens[i + 1] and \".\" in tokens[i + 2]:\n            x_column = i\n            break\n\n    if x_column is None:\n        return None\n\n    # Try to read the coordinates\n    try:\n        coord = np.asarray(tokens[x_column : x_column + 3], dtype=float)\n        return coord\n    except ValueError:\n        coord = None\n\n    return None\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.brute_permutation","title":"brute_permutation","text":"<pre><code>brute_permutation(A: ndarray, B: ndarray) -&gt; ndarray\n</code></pre> <p>Re-orders the input atom list and xyz coordinates using the brute force method of permuting all rows of the input coordinates</p> <p>Parameters:</p> <ul> <li> <code>A</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> <li> <code>B</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>view</code> (              <code>array</code> )          \u2013            <p>(N,1) matrix, reordered view of B projected to A</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def brute_permutation(A: ndarray, B: ndarray) -&gt; ndarray:\n    \"\"\"\n    Re-orders the input atom list and xyz coordinates using the brute force\n    method of permuting all rows of the input coordinates\n\n    Parameters\n    ----------\n    A : array\n        (N,D) matrix, where N is points and D is dimension\n    B : array\n        (N,D) matrix, where N is points and D is dimension\n\n    Returns\n    -------\n    view : array\n        (N,1) matrix, reordered view of B projected to A\n    \"\"\"\n\n    rmsd_min = np.inf\n    view_min: ndarray\n\n    # Sets initial ordering for row indices to [0, 1, 2, ..., len(A)], used in\n    # brute-force method\n\n    num_atoms = A.shape[0]\n    initial_order = list(range(num_atoms))\n\n    for reorder_indices in generate_permutations(initial_order, num_atoms):\n        # Re-order the atom array and coordinate matrix\n        coords_ordered = B[reorder_indices]\n\n        # Calculate the RMSD between structure 1 and the Hungarian re-ordered\n        # structure 2\n        rmsd_temp = kabsch_rmsd(A, coords_ordered)\n\n        # Replaces the atoms and coordinates with the current structure if the\n        # RMSD is lower\n        if rmsd_temp &lt; rmsd_min:\n            rmsd_min = rmsd_temp\n            view_min = np.asarray(copy.deepcopy(reorder_indices))\n\n    return view_min\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.centroid","title":"centroid","text":"<pre><code>centroid(X: ndarray) -&gt; ndarray\n</code></pre> <p>Centroid is the mean position of all the points in all of the coordinate directions, from a vectorset X.</p> <p>https://en.wikipedia.org/wiki/Centroid</p> <p>C = sum(X)/len(X)</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>C</code> (              <code>ndarray</code> )          \u2013            <p>centroid</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def centroid(X: ndarray) -&gt; ndarray:\n    \"\"\"\n    Centroid is the mean position of all the points in all of the coordinate\n    directions, from a vectorset X.\n\n    https://en.wikipedia.org/wiki/Centroid\n\n    C = sum(X)/len(X)\n\n    Parameters\n    ----------\n    X : array\n        (N,D) matrix, where N is points and D is dimension.\n\n    Returns\n    -------\n    C : ndarray\n        centroid\n    \"\"\"\n    C: ndarray = X.mean(axis=0)\n    return C\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.check_reflections","title":"check_reflections","text":"<pre><code>check_reflections(p_atoms: ndarray, q_atoms: ndarray, p_coord: ndarray, q_coord: ndarray, reorder_method: Optional[ReorderCallable] = None, rmsd_method: RmsdCallable = kabsch_rmsd, keep_stereo: bool = False) -&gt; Tuple[float, ndarray, ndarray, ndarray]\n</code></pre> <p>Minimize RMSD using reflection planes for molecule P and Q</p> <p>Warning: This will affect stereo-chemistry</p> <p>Parameters:</p> <ul> <li> <code>p_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>q_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>p_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> <li> <code>q_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>min_rmsd</code>           \u2013            </li> <li> <code>min_swap</code>           \u2013            </li> <li> <code>min_reflection</code>           \u2013            </li> <li> <code>min_review</code>           \u2013            </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def check_reflections(\n    p_atoms: ndarray,\n    q_atoms: ndarray,\n    p_coord: ndarray,\n    q_coord: ndarray,\n    reorder_method: Optional[ReorderCallable] = None,\n    rmsd_method: RmsdCallable = kabsch_rmsd,\n    keep_stereo: bool = False,\n) -&gt; Tuple[float, ndarray, ndarray, ndarray]:\n    \"\"\"\n    Minimize RMSD using reflection planes for molecule P and Q\n\n    Warning: This will affect stereo-chemistry\n\n    Parameters\n    ----------\n    p_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    q_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    p_coord : array\n        (N,D) matrix, where N is points and D is dimension\n    q_coord : array\n        (N,D) matrix, where N is points and D is dimension\n\n    Returns\n    -------\n    min_rmsd\n    min_swap\n    min_reflection\n    min_review\n\n    \"\"\"\n\n    if reorder_method is None:\n        assert (\n            p_atoms == q_atoms\n        ).all(), \"No reorder method selected, but atoms are not ordered\"\n\n    min_rmsd = np.inf\n    min_swap: ndarray\n    min_reflection: ndarray\n    min_review: ndarray = np.array(range(len(p_atoms)))\n    tmp_review: ndarray = min_review\n    swap_mask = [1, -1, -1, 1, -1, 1]\n    reflection_mask = [1, -1, -1, -1, 1, 1, 1, -1]\n\n    for swap, i in zip(AXIS_SWAPS, swap_mask):\n        for reflection, j in zip(AXIS_REFLECTIONS, reflection_mask):\n            # skip enantiomers\n            if keep_stereo and i * j == -1:\n                continue\n\n            tmp_atoms = copy.copy(q_atoms)\n            tmp_coord = copy.deepcopy(q_coord)\n            tmp_coord = tmp_coord[:, swap]\n            tmp_coord = np.dot(tmp_coord, np.diag(reflection))\n            tmp_coord -= centroid(tmp_coord)\n\n            # Reorder\n            if reorder_method is not None:\n                tmp_review = reorder_method(p_atoms, tmp_atoms, p_coord, tmp_coord)\n                tmp_coord = tmp_coord[tmp_review]\n                tmp_atoms = tmp_atoms[tmp_review]\n\n            # Rotation\n            this_rmsd = rmsd_method(p_coord, tmp_coord)\n\n            if this_rmsd &lt; min_rmsd:\n                min_rmsd = this_rmsd\n                min_swap = swap\n                min_reflection = reflection\n                min_review = tmp_review\n\n    assert (p_atoms == q_atoms[min_review]).all(), \"error: Not aligned\"\n\n    return min_rmsd, min_swap, min_reflection, min_review\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.generate_permutations","title":"generate_permutations","text":"<pre><code>generate_permutations(elements: List[int], n: int) -&gt; Iterator[List[int]]\n</code></pre> <p>Heap's algorithm for generating all n! permutations in a list https://en.wikipedia.org/wiki/Heap%27s_algorithm</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def generate_permutations(elements: List[int], n: int) -&gt; Iterator[List[int]]:\n    \"\"\"\n    Heap's algorithm for generating all n! permutations in a list\n    https://en.wikipedia.org/wiki/Heap%27s_algorithm\n\n    \"\"\"\n    c = [0] * n\n    yield elements\n    i = 0\n    while i &lt; n:\n        if c[i] &lt; i:\n            if i % 2 == 0:\n                elements[0], elements[i] = elements[i], elements[0]\n            else:\n                elements[c[i]], elements[i] = elements[i], elements[c[i]]\n            yield elements\n            c[i] += 1\n            i = 0\n        else:\n            c[i] = 0\n            i += 1\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.get_cm","title":"get_cm","text":"<pre><code>get_cm(atoms: ndarray, V: ndarray) -&gt; ndarray\n</code></pre> Get the center of mass of V. <p>atoms : list     List of atomic types V : array     (N,3) matrix of atomic coordinates</p> Return <p>output : (3) array     The CM vector</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def get_cm(atoms: ndarray, V: ndarray) -&gt; ndarray:\n    \"\"\"\n    Get the center of mass of V.\n    ----------\n    atoms : list\n        List of atomic types\n    V : array\n        (N,3) matrix of atomic coordinates\n\n    Return\n    ------\n    output : (3) array\n        The CM vector\n    \"\"\"\n\n    weights: Union[List[float], ndarray] = [ELEMENT_WEIGHTS[x] for x in atoms]\n    weights = np.asarray(weights)\n    center_of_mass: ndarray = np.average(V, axis=0, weights=weights)\n\n    return center_of_mass\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.get_coordinates","title":"get_coordinates","text":"<pre><code>get_coordinates(filename: Path, fmt: str, is_gzip: bool = False, return_atoms_as_int: bool = False) -&gt; Tuple[ndarray, ndarray]\n</code></pre> <p>Get coordinates from filename in format fmt. Supports XYZ and PDB.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>string</code>)           \u2013            <p>Filename to read</p> </li> <li> <code>fmt</code>               (<code>string</code>)           \u2013            <p>Format of filename. Either xyz or pdb.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code> (              <code>list</code> )          \u2013            <p>List of atomic types</p> </li> <li> <code>V</code> (              <code>array</code> )          \u2013            <p>(N,3) where N is number of atoms</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def get_coordinates(\n    filename: Path, fmt: str, is_gzip: bool = False, return_atoms_as_int: bool = False\n) -&gt; Tuple[ndarray, ndarray]:\n    \"\"\"\n    Get coordinates from filename in format fmt. Supports XYZ and PDB.\n    Parameters\n    ----------\n    filename : string\n        Filename to read\n    fmt : string\n        Format of filename. Either xyz or pdb.\n    Returns\n    -------\n    atoms : list\n        List of atomic types\n    V : array\n        (N,3) where N is number of atoms\n    \"\"\"\n    if fmt == \"xyz\":\n        get_func = get_coordinates_xyz\n\n    elif fmt == \"pdb\":\n        get_func = get_coordinates_pdb\n\n    else:\n        raise ValueError(f\"Could not recognize file format: {fmt:s}\")\n\n    val = get_func(filename, is_gzip=is_gzip, return_atoms_as_int=return_atoms_as_int)\n\n    return val\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.get_coordinates_pdb","title":"get_coordinates_pdb","text":"<pre><code>get_coordinates_pdb(filename: Path, is_gzip: bool = False, return_atoms_as_int: bool = False, only_alpha_carbon: bool = False) -&gt; Tuple[ndarray, ndarray]\n</code></pre> <p>Get coordinates from the first chain in a pdb file and return a vectorset with all the coordinates.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>string</code>)           \u2013            <p>Filename to read</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code> (              <code>list</code> )          \u2013            <p>List of atomic types</p> </li> <li> <code>V</code> (              <code>array</code> )          \u2013            <p>(N,3) where N is number of atoms</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def get_coordinates_pdb(\n    filename: Path,\n    is_gzip: bool = False,\n    return_atoms_as_int: bool = False,\n    only_alpha_carbon: bool = False,\n) -&gt; Tuple[ndarray, ndarray]:\n    \"\"\"\n    Get coordinates from the first chain in a pdb file\n    and return a vectorset with all the coordinates.\n\n    Parameters\n    ----------\n    filename : string\n        Filename to read\n\n    Returns\n    -------\n    atoms : list\n        List of atomic types\n    V : array\n        (N,3) where N is number of atoms\n    \"\"\"\n\n    # PDB files tend to be a bit of a mess. The x, y and z coordinates\n    # are supposed to be in column 31-38, 39-46 and 47-54, but this is\n    # not always the case.\n    # Because of this the three first columns containing a decimal is used.\n    # Since the format doesn't require a space between columns, we use the\n    # above column indices as a fallback.\n\n    V: Union[List[ndarray], ndarray] = list()\n    assert isinstance(V, list)\n\n    # Same with atoms and atom naming.\n    # The most robust way to do this is probably\n    # to assume that the atomtype is given in column 3.\n\n    atoms: List[str] = list()\n    alpha_carbons: List[bool] = list()\n    assert isinstance(atoms, list)\n    openfunc: Any\n\n    if is_gzip:\n        openfunc = gzip.open\n        openarg = \"rt\"\n    else:\n        openfunc = open\n        openarg = \"r\"\n\n    with openfunc(filename, openarg) as f:\n        lines = f.readlines()\n        for line in lines:\n            if line.startswith(\"TER\") or line.startswith(\"END\"):\n                break\n\n            if not (line.startswith(\"ATOM\") or line.startswith(\"HETATM\")):\n                continue\n\n            atom = _parse_pdb_atom_line(line)\n            if atom is None:\n                raise ValueError(f\"error: Parsing for atom line: {line}\")\n            atoms.append(atom)\n\n            coord = _parse_pdb_coord_line(line)\n            if coord is None:\n                raise ValueError(f\"error: Parsing coordinates for line: {line}\")\n            V.append(coord)\n\n            # Check if alpha-carbon\n            is_alpha = _parse_pdb_alphacarbon_line(line)\n            alpha_carbons.append(is_alpha)\n\n    if return_atoms_as_int:\n        _atoms = np.asarray([int_atom(str(atom)) for atom in atoms])\n    else:\n        _atoms = np.asarray(atoms)\n\n    V = np.asarray(V)\n    assert isinstance(V, ndarray)\n\n    assert isinstance(_atoms, ndarray)\n    assert V.shape[0] == _atoms.size\n\n    if only_alpha_carbon:\n        # Check that any alpha carbons were found\n        if not sum(alpha_carbons):\n            raise ValueError(\n                \"Trying to filter for alpha carbons, but couldn't find any\"\n            )\n\n        _alpha_carbons = np.asarray(alpha_carbons, dtype=bool)\n\n        V = V[_alpha_carbons, :]\n        _atoms = _atoms[_alpha_carbons]\n\n    return _atoms, V\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.get_coordinates_xyz","title":"get_coordinates_xyz","text":"<pre><code>get_coordinates_xyz(filename: Path, is_gzip: bool = False, return_atoms_as_int: bool = False) -&gt; Tuple[ndarray, ndarray]\n</code></pre> <p>Get coordinates from filename and return a vectorset with all the coordinates, in XYZ format.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>string</code>)           \u2013            <p>Filename to read</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code> (              <code>list</code> )          \u2013            <p>List of atomic types</p> </li> <li> <code>V</code> (              <code>array</code> )          \u2013            <p>(N,3) where N is number of atoms</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def get_coordinates_xyz(\n    filename: Path,\n    is_gzip: bool = False,\n    return_atoms_as_int: bool = False,\n) -&gt; Tuple[ndarray, ndarray]:\n    \"\"\"\n    Get coordinates from filename and return a vectorset with all the\n    coordinates, in XYZ format.\n\n    Parameters\n    ----------\n    filename : string\n        Filename to read\n\n    Returns\n    -------\n    atoms : list\n        List of atomic types\n    V : array\n        (N,3) where N is number of atoms\n    \"\"\"\n\n    openfunc: Any\n\n    if is_gzip:\n        openfunc = gzip.open\n        openarg = \"rt\"\n    else:\n        openfunc = open\n        openarg = \"r\"\n\n    with openfunc(filename, openarg) as f:\n        lines = f.readlines()\n\n    atoms, V = get_coordinates_xyz_lines(lines, return_atoms_as_int=return_atoms_as_int)\n\n    return atoms, V\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.get_coordinates_xyz_lines","title":"get_coordinates_xyz_lines","text":"<pre><code>get_coordinates_xyz_lines(lines: List[str], return_atoms_as_int: bool = False) -&gt; Tuple[ndarray, ndarray]\n</code></pre> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def get_coordinates_xyz_lines(\n    lines: List[str], return_atoms_as_int: bool = False\n) -&gt; Tuple[ndarray, ndarray]:\n    V: Union[List[ndarray], ndarray] = list()\n    atoms: Union[List[str], ndarray] = list()\n    n_atoms = 0\n\n    assert isinstance(V, list)\n    assert isinstance(atoms, list)\n\n    # Read the first line to obtain the number of atoms to read\n    try:\n        n_atoms = int(lines[0])\n    except ValueError:\n        exit(\"error: Could not obtain the number of atoms in the .xyz file.\")\n\n    # Skip the title line\n    # Use the number of atoms to not read beyond the end of a file\n    for lines_read, line in enumerate(lines[2:]):\n        line = line.strip()\n\n        if lines_read == n_atoms:\n            break\n\n        values = line.split()\n\n        if len(values) &lt; 4:\n            atom = re.findall(r\"[a-zA-Z]+\", line)[0]\n            atom = atom.upper()\n            numbers = re.findall(r\"[-]?\\d+\\.\\d*(?:[Ee][-\\+]\\d+)?\", line)\n            numbers = [float(number) for number in numbers]\n        else:\n            atom = values[0]\n            numbers = [float(number) for number in values[1:]]\n\n        # The numbers are not valid unless we obtain exacly three\n        if len(numbers) &gt;= 3:\n            V.append(np.array(numbers)[:3])\n            atoms.append(atom)\n        else:\n            msg = (\n                f\"Reading the .xyz file failed in line {lines_read + 2}.\"\n                \"Please check the format.\"\n            )\n            exit(msg)\n\n    try:\n        # I've seen examples where XYZ are written with integer atoms types\n        atoms_ = [int(atom) for atom in atoms]\n        atoms = [str_atom(atom) for atom in atoms_]\n\n    except ValueError:\n        # Correct atom spelling\n        atoms = [atom.capitalize() for atom in atoms]\n\n    if return_atoms_as_int:\n        atoms_ = [int_atom(atom) for atom in atoms]\n        atoms = np.array(atoms_)\n    else:\n        atoms = np.array(atoms)\n\n    V = np.array(V)\n\n    return atoms, V\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.get_inertia_tensor","title":"get_inertia_tensor","text":"<pre><code>get_inertia_tensor(atoms: ndarray, V: ndarray) -&gt; ndarray\n</code></pre> Get the tensor of intertia of V. <p>atoms : list     List of atomic types V : array     (N,3) matrix of atomic coordinates</p> Return <p>output : 3x3 float matrix     The tensor of inertia</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def get_inertia_tensor(atoms: ndarray, V: ndarray) -&gt; ndarray:\n    \"\"\"\n    Get the tensor of intertia of V.\n    ----------\n    atoms : list\n        List of atomic types\n    V : array\n        (N,3) matrix of atomic coordinates\n\n    Return\n    ------\n    output : 3x3 float matrix\n        The tensor of inertia\n    \"\"\"\n\n    CV = V - get_cm(atoms, V)\n\n    Ixx = 0.0\n    Iyy = 0.0\n    Izz = 0.0\n    Ixy = 0.0\n    Ixz = 0.0\n    Iyz = 0.0\n\n    for sp, acoord in zip(atoms, CV):\n        amass = ELEMENT_WEIGHTS[sp]\n        Ixx += amass * (acoord[1] * acoord[1] + acoord[2] * acoord[2])\n        Iyy += amass * (acoord[0] * acoord[0] + acoord[2] * acoord[2])\n        Izz += amass * (acoord[0] * acoord[0] + acoord[1] * acoord[1])\n        Ixy += -amass * acoord[0] * acoord[1]\n        Ixz += -amass * acoord[0] * acoord[2]\n        Iyz += -amass * acoord[1] * acoord[2]\n\n    return np.array([[Ixx, Ixy, Ixz], [Ixy, Iyy, Iyz], [Ixz, Iyz, Izz]])\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.get_principal_axis","title":"get_principal_axis","text":"<pre><code>get_principal_axis(atoms: ndarray, V: ndarray) -&gt; ndarray\n</code></pre> Get the molecule's principal axis. <p>atoms : list     List of atomic types V : array     (N,3) matrix of atomic coordinates</p> Return <p>output : array     Array of dim 3 containing the principal axis</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def get_principal_axis(atoms: ndarray, V: ndarray) -&gt; ndarray:\n    \"\"\"\n    Get the molecule's principal axis.\n    ----------\n    atoms : list\n        List of atomic types\n    V : array\n        (N,3) matrix of atomic coordinates\n\n    Return\n    ------\n    output : array\n        Array of dim 3 containing the principal axis\n    \"\"\"\n    inertia = get_inertia_tensor(atoms, V)\n\n    eigval, eigvec = np.linalg.eig(inertia)\n\n    principal_axis: ndarray = eigvec[np.argmax(eigval)]\n\n    return principal_axis\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.hungarian","title":"hungarian","text":"<pre><code>hungarian(A: ndarray, B: ndarray) -&gt; ndarray\n</code></pre> <p>Hungarian reordering.</p> <p>Assume A and B are coordinates for atoms of SAME type only</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def hungarian(A: ndarray, B: ndarray) -&gt; ndarray:\n    \"\"\"\n    Hungarian reordering.\n\n    Assume A and B are coordinates for atoms of SAME type only\n    \"\"\"\n\n    # should be kabasch here i think\n    distances = cdist(A, B, \"euclidean\")\n\n    # Perform Hungarian analysis on distance matrix between atoms of 1st\n    # structure and trial structure\n    indices_b: ndarray\n    indices_a: ndarray\n    indices_a, indices_b = linear_sum_assignment(distances)\n\n    return indices_b\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.hungarian_vectors","title":"hungarian_vectors","text":"<pre><code>hungarian_vectors(p_vecs: ndarray, q_vecs: ndarray, sigma: float = 1.0, use_kernel: bool = True) -&gt; ndarray\n</code></pre> <p>Hungarian cost assignment of a similiarty molecule kernel.</p> <p>Note: Assumes p and q are atoms of same type</p> <p>Parameters:</p> <ul> <li> <code>p_vecs</code>               (<code>array</code>)           \u2013            <p>(N,L) matrix, where N is no. of atoms and L is representation length</p> </li> <li> <code>q_vecs</code>               (<code>array</code>)           \u2013            <p>(N,L) matrix, where N is no. of atoms and L is representation length</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>indices_b</code> (              <code>array</code> )          \u2013            <p>(N) view vector of reordered assignment</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def hungarian_vectors(\n    p_vecs: ndarray, q_vecs: ndarray, sigma: float = 1e-0, use_kernel: bool = True\n) -&gt; ndarray:\n    \"\"\"\n\n    Hungarian cost assignment of a similiarty molecule kernel.\n\n    Note: Assumes p and q are atoms of same type\n\n    Parameters\n    ----------\n    p_vecs : array\n        (N,L) matrix, where N is no. of atoms and L is representation length\n    q_vecs : array\n        (N,L) matrix, where N is no. of atoms and L is representation length\n\n    Returns\n    -------\n    indices_b : array\n        (N) view vector of reordered assignment\n\n    \"\"\"\n\n    if use_kernel:\n        # Calculate cost matrix from similarity kernel\n        K = laplacian_kernel(p_vecs, q_vecs, sigma)\n        K *= -1.0\n        K += 1.0\n\n    else:\n        K = distance_matrix(p_vecs, q_vecs)\n\n    # Perform Hungarian analysis on distance matrix between atoms of 1st\n    # structure and trial structure\n    indices_b: ndarray\n    indices_a: ndarray\n    indices_a, indices_b = linear_sum_assignment(K)\n\n    return indices_b\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.int_atom","title":"int_atom","text":"<pre><code>int_atom(atom: str) -&gt; int\n</code></pre> <p>Convert atom type from string to integer</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>string</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code> (              <code>integer</code> )          \u2013            </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def int_atom(atom: str) -&gt; int:\n    \"\"\"\n    Convert atom type from string to integer\n\n    Parameters\n    ----------\n    atoms : string\n\n    Returns\n    -------\n    atoms : integer\n    \"\"\"\n\n    atom = atom.capitalize().strip()\n    return NAMES_ELEMENT[atom]\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.kabsch","title":"kabsch","text":"<pre><code>kabsch(P: ndarray, Q: ndarray) -&gt; ndarray\n</code></pre> <p>Using the Kabsch algorithm with two sets of paired point P and Q, centered around the centroid. Each vector set is represented as an NxD matrix, where D is the the dimension of the space. The algorithm works in three steps: - a centroid translation of P and Q (assumed done before this function   call) - the computation of a covariance matrix C - computation of the optimal rotation matrix U For more info see http://en.wikipedia.org/wiki/Kabsch_algorithm</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Q</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>U</code> (              <code>matrix</code> )          \u2013            <p>Rotation matrix (D,D)</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def kabsch(P: ndarray, Q: ndarray) -&gt; ndarray:\n    \"\"\"\n    Using the Kabsch algorithm with two sets of paired point P and Q, centered\n    around the centroid. Each vector set is represented as an NxD\n    matrix, where D is the the dimension of the space.\n    The algorithm works in three steps:\n    - a centroid translation of P and Q (assumed done before this function\n      call)\n    - the computation of a covariance matrix C\n    - computation of the optimal rotation matrix U\n    For more info see http://en.wikipedia.org/wiki/Kabsch_algorithm\n    Parameters\n    ----------\n    P : array\n        (N,D) matrix, where N is points and D is dimension.\n    Q : array\n        (N,D) matrix, where N is points and D is dimension.\n    Returns\n    -------\n    U : matrix\n        Rotation matrix (D,D)\n    \"\"\"\n\n    # Computation of the covariance matrix\n    C = np.dot(np.transpose(P), Q)\n\n    # Computation of the optimal rotation matrix\n    # This can be done using singular value decomposition (SVD)\n    # Getting the sign of the det(V)*(W) to decide\n    # whether we need to correct our rotation matrix to ensure a\n    # right-handed coordinate system.\n    # And finally calculating the optimal rotation matrix U\n    # see http://en.wikipedia.org/wiki/Kabsch_algorithm\n    V, S, W = np.linalg.svd(C)\n    d = (np.linalg.det(V) * np.linalg.det(W)) &lt; 0.0\n\n    if d:\n        S[-1] = -S[-1]\n        V[:, -1] = -V[:, -1]\n\n    # Create Rotation matrix U\n    U: ndarray = np.dot(V, W)\n\n    return U\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.kabsch_fit","title":"kabsch_fit","text":"<pre><code>kabsch_fit(P: ndarray, Q: ndarray, W: Optional[ndarray] = None) -&gt; ndarray\n</code></pre> <p>Rotate and translate matrix P unto matrix Q using Kabsch algorithm. An optional vector of weights W may be provided.</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Q</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>W</code>               (<code>array or None</code>, default:                   <code>None</code> )           \u2013            <p>(N) vector, where N is points.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>P</code> (              <code>array</code> )          \u2013            <p>(N,D) matrix, where N is points and D is dimension, rotated and translated.</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def kabsch_fit(P: ndarray, Q: ndarray, W: Optional[ndarray] = None) -&gt; ndarray:\n    \"\"\"\n    Rotate and translate matrix P unto matrix Q using Kabsch algorithm.\n    An optional vector of weights W may be provided.\n\n    Parameters\n    ----------\n    P : array\n        (N,D) matrix, where N is points and D is dimension.\n    Q : array\n        (N,D) matrix, where N is points and D is dimension.\n    W : array or None\n        (N) vector, where N is points.\n\n    Returns\n    -------\n    P : array\n        (N,D) matrix, where N is points and D is dimension,\n        rotated and translated.\n\n    \"\"\"\n    if W is not None:\n        P, _ = kabsch_weighted_fit(P, Q, W, return_rmsd=False)\n    else:\n        QC = centroid(Q)\n        Q = Q - QC\n        P = P - centroid(P)\n        P = kabsch_rotate(P, Q) + QC\n    return P\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.kabsch_rmsd","title":"kabsch_rmsd","text":"<pre><code>kabsch_rmsd(P: ndarray, Q: ndarray, W: Optional[ndarray] = None, translate: bool = False, **kwargs: Any) -&gt; float\n</code></pre> <p>Rotate matrix P unto Q using Kabsch algorithm and calculate the RMSD. An optional vector of weights W may be provided.</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Q</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>W</code>               (<code>array or None</code>, default:                   <code>None</code> )           \u2013            <p>(N) vector, where N is points.</p> </li> <li> <code>translate</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use centroids to translate vector P and Q unto each other.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rmsd</code> (              <code>float</code> )          \u2013            <p>root-mean squared deviation</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def kabsch_rmsd(\n    P: ndarray,\n    Q: ndarray,\n    W: Optional[ndarray] = None,\n    translate: bool = False,\n    **kwargs: Any,\n) -&gt; float:\n    \"\"\"\n    Rotate matrix P unto Q using Kabsch algorithm and calculate the RMSD.\n    An optional vector of weights W may be provided.\n\n    Parameters\n    ----------\n    P : array\n        (N,D) matrix, where N is points and D is dimension.\n    Q : array\n        (N,D) matrix, where N is points and D is dimension.\n    W : array or None\n        (N) vector, where N is points.\n    translate : bool\n        Use centroids to translate vector P and Q unto each other.\n\n    Returns\n    -------\n    rmsd : float\n        root-mean squared deviation\n    \"\"\"\n\n    if translate:\n        Q = Q - centroid(Q)\n        P = P - centroid(P)\n\n    if W is not None:\n        return kabsch_weighted_rmsd(P, Q, W)\n\n    P = kabsch_rotate(P, Q)\n    return rmsd(P, Q)\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.kabsch_rotate","title":"kabsch_rotate","text":"<pre><code>kabsch_rotate(P: ndarray, Q: ndarray) -&gt; ndarray\n</code></pre> <p>Rotate matrix P unto matrix Q using Kabsch algorithm.</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Q</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>P</code> (              <code>array</code> )          \u2013            <p>(N,D) matrix, where N is points and D is dimension, rotated</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def kabsch_rotate(P: ndarray, Q: ndarray) -&gt; ndarray:\n    \"\"\"\n    Rotate matrix P unto matrix Q using Kabsch algorithm.\n\n    Parameters\n    ----------\n    P : array\n        (N,D) matrix, where N is points and D is dimension.\n    Q : array\n        (N,D) matrix, where N is points and D is dimension.\n\n    Returns\n    -------\n    P : array\n        (N,D) matrix, where N is points and D is dimension,\n        rotated\n\n    \"\"\"\n    U = kabsch(P, Q)\n\n    # Rotate P\n    P = np.dot(P, U)\n    return P\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.kabsch_weighted","title":"kabsch_weighted","text":"<pre><code>kabsch_weighted(P: ndarray, Q: ndarray, W: Optional[ndarray] = None) -&gt; Tuple[ndarray, ndarray, float]\n</code></pre> <p>Using the Kabsch algorithm with two sets of paired point P and Q. Each vector set is represented as an NxD matrix, where D is the dimension of the space. An optional vector of weights W may be provided.</p> <p>Note that this algorithm does not require that P and Q have already been overlayed by a centroid translation.</p> <p>The function returns the rotation matrix U, translation vector V, and RMS deviation between Q and P', where P' is:</p> <pre><code>P' = P * U + V\n</code></pre> <p>For more info see http://en.wikipedia.org/wiki/Kabsch_algorithm</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Q</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>W</code>               (<code>array or None</code>, default:                   <code>None</code> )           \u2013            <p>(N) vector, where N is points.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>U</code> (              <code>matrix</code> )          \u2013            <p>Rotation matrix (D,D)</p> </li> <li> <code>V</code> (              <code>vector</code> )          \u2013            <p>Translation vector (D)</p> </li> <li> <code>RMSD</code> (              <code>float</code> )          \u2013            <p>Root mean squared deviation between P and Q</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def kabsch_weighted(\n    P: ndarray, Q: ndarray, W: Optional[ndarray] = None\n) -&gt; Tuple[ndarray, ndarray, float]:\n    \"\"\"\n    Using the Kabsch algorithm with two sets of paired point P and Q.\n    Each vector set is represented as an NxD matrix, where D is the\n    dimension of the space.\n    An optional vector of weights W may be provided.\n\n    Note that this algorithm does not require that P and Q have already\n    been overlayed by a centroid translation.\n\n    The function returns the rotation matrix U, translation vector V,\n    and RMS deviation between Q and P', where P' is:\n\n        P' = P * U + V\n\n    For more info see http://en.wikipedia.org/wiki/Kabsch_algorithm\n\n    Parameters\n    ----------\n    P : array\n        (N,D) matrix, where N is points and D is dimension.\n    Q : array\n        (N,D) matrix, where N is points and D is dimension.\n    W : array or None\n        (N) vector, where N is points.\n\n    Returns\n    -------\n    U    : matrix\n           Rotation matrix (D,D)\n    V    : vector\n           Translation vector (D)\n    RMSD : float\n           Root mean squared deviation between P and Q\n    \"\"\"\n    # Computation of the weighted covariance matrix\n    CMP = np.zeros(3)\n    CMQ = np.zeros(3)\n    C = np.zeros((3, 3))\n    if W is None:\n        W = np.ones(len(P)) / len(P)\n    W = np.array([W, W, W]).T\n    # NOTE UNUSED psq = 0.0\n    # NOTE UNUSED qsq = 0.0\n    iw = 3.0 / W.sum()\n    n = len(P)\n    for i in range(3):\n        for j in range(n):\n            for k in range(3):\n                C[i, k] += P[j, i] * Q[j, k] * W[j, i]\n    CMP = (P * W).sum(axis=0)\n    CMQ = (Q * W).sum(axis=0)\n    PSQ = (P * P * W).sum() - (CMP * CMP).sum() * iw\n    QSQ = (Q * Q * W).sum() - (CMQ * CMQ).sum() * iw\n    C = (C - np.outer(CMP, CMQ) * iw) * iw\n\n    # Computation of the optimal rotation matrix\n    # This can be done using singular value decomposition (SVD)\n    # Getting the sign of the det(V)*(W) to decide\n    # whether we need to correct our rotation matrix to ensure a\n    # right-handed coordinate system.\n    # And finally calculating the optimal rotation matrix U\n    # see http://en.wikipedia.org/wiki/Kabsch_algorithm\n    V, S, W = np.linalg.svd(C)\n    d = (np.linalg.det(V) * np.linalg.det(W)) &lt; 0.0\n\n    if d:\n        S[-1] = -S[-1]\n        V[:, -1] = -V[:, -1]\n\n    # Create Rotation matrix U, translation vector V, and calculate RMSD:\n    U = np.dot(V, W)\n    msd = (PSQ + QSQ) * iw - 2.0 * S.sum()\n    if msd &lt; 0.0:\n        msd = 0.0\n    rmsd_ = np.sqrt(msd)\n    V = np.zeros(3)\n    for i in range(3):\n        t = (U[i, :] * CMQ).sum()\n        V[i] = CMP[i] - t\n    V = V * iw\n    return U, V, rmsd_\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.kabsch_weighted_fit","title":"kabsch_weighted_fit","text":"<pre><code>kabsch_weighted_fit(P: ndarray, Q: ndarray, W: Optional[ndarray] = None, return_rmsd: bool = False) -&gt; Tuple[ndarray, Optional[float]]\n</code></pre> <p>Fit P to Q with optional weights W. Also returns the RMSD of the fit if return_rmsd=True.</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code>ndarray</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Q</code>               (<code>ndarray</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>W</code>               (<code>Optional[ndarray]</code>, default:                   <code>None</code> )           \u2013            <p>(N) vector, where N is points</p> </li> <li> <code>rmsd</code>               (<code>Bool</code>)           \u2013            <p>If True, rmsd is returned as well as the fitted coordinates.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>P'   : array</code>           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>RMSD</code> (              <code>float</code> )          \u2013            <p>if the function is called with rmsd=True</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def kabsch_weighted_fit(\n    P: ndarray,\n    Q: ndarray,\n    W: Optional[ndarray] = None,\n    return_rmsd: bool = False,\n) -&gt; Tuple[ndarray, Optional[float]]:\n    \"\"\"\n    Fit P to Q with optional weights W.\n    Also returns the RMSD of the fit if return_rmsd=True.\n\n    Parameters\n    ----------\n    P    : array\n           (N,D) matrix, where N is points and D is dimension.\n    Q    : array\n           (N,D) matrix, where N is points and D is dimension.\n    W    : vector\n           (N) vector, where N is points\n    rmsd : Bool\n           If True, rmsd is returned as well as the fitted coordinates.\n\n    Returns\n    -------\n    P'   : array\n           (N,D) matrix, where N is points and D is dimension.\n    RMSD : float\n           if the function is called with rmsd=True\n    \"\"\"\n    rmsd_: float\n    R, T, rmsd_ = kabsch_weighted(Q, P, W)\n    PNEW: ndarray = np.dot(P, R.T) + T\n    if return_rmsd:\n        return (PNEW, rmsd_)\n    else:\n        return (PNEW, None)\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.kabsch_weighted_rmsd","title":"kabsch_weighted_rmsd","text":"<pre><code>kabsch_weighted_rmsd(P: ndarray, Q: ndarray, W: Optional[ndarray] = None) -&gt; float\n</code></pre> <p>Calculate the RMSD between P and Q with optional weights W</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Q</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>W</code>               (<code>vector</code>, default:                   <code>None</code> )           \u2013            <p>(N) vector, where N is points</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RMSD</code> (              <code>float</code> )          \u2013            </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def kabsch_weighted_rmsd(P: ndarray, Q: ndarray, W: Optional[ndarray] = None) -&gt; float:\n    \"\"\"\n    Calculate the RMSD between P and Q with optional weights W\n\n    Parameters\n    ----------\n    P : array\n        (N,D) matrix, where N is points and D is dimension.\n    Q : array\n        (N,D) matrix, where N is points and D is dimension.\n    W : vector\n        (N) vector, where N is points\n\n    Returns\n    -------\n    RMSD : float\n    \"\"\"\n    _, _, w_rmsd = kabsch_weighted(P, Q, W)\n    return w_rmsd\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.main","title":"main","text":"<pre><code>main(args: Optional[List[str]] = None) -&gt; str\n</code></pre> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def main(args: Optional[List[str]] = None) -&gt; str:\n    # Parse arguments\n    settings = parse_arguments(args)\n\n    # Define the read function\n    if settings.format == FORMAT_XYZ:\n        get_coordinates = partial(\n            get_coordinates_xyz,\n            is_gzip=settings.format_is_gzip,\n            return_atoms_as_int=True,\n        )\n\n    elif settings.format == FORMAT_PDB:\n        get_coordinates = partial(\n            get_coordinates_pdb,\n            is_gzip=settings.format_is_gzip,\n            return_atoms_as_int=True,\n            only_alpha_carbon=settings.only_alpha_carbons,\n        )\n    else:\n        print(f\"Unknown format: {settings.format}\")\n        sys.exit(1)\n\n    # As default, load the extension as format\n    # Parse pdb.gz and xyz.gz as pdb and xyz formats\n    p_atoms, p_coord = get_coordinates(\n        settings.structure_a,\n    )\n\n    q_atoms, q_coord = get_coordinates(\n        settings.structure_b,\n    )\n\n    p_size = p_coord.shape[0]\n    q_size = q_coord.shape[0]\n\n    if p_size != q_size:\n        print(\"error: Structures not same size\")\n        sys.exit()\n\n    if np.count_nonzero(p_atoms != q_atoms) and not settings.reorder:\n        msg = \"\"\"\nerror: Atoms are not in the same order.\n\nUse --reorder to align the atoms (can be expensive for large structures).\n\nPlease see --help or documentation for more information or\nhttps://github.com/charnley/rmsd for further examples.\n\"\"\"\n        print(msg)\n        sys.exit()\n\n    # Typing\n    index: Union[Set[int], List[int], ndarray]\n\n    # Set local view\n    p_view: Optional[ndarray] = None\n    q_view: Optional[ndarray] = None\n    use_view: bool = True\n\n    if settings.ignore_hydrogen:\n        (p_view,) = np.where(p_atoms != 1)\n        (q_view,) = np.where(q_atoms != 1)\n\n    elif settings.remove_idx:\n        index = np.array(list(set(range(p_size)) - set(settings.remove_idx)))\n        p_view = index\n        q_view = index\n\n    elif settings.add_idx:\n        p_view = settings.add_idx\n        q_view = settings.add_idx\n\n    else:\n        use_view = False\n\n    # Set local view\n    if use_view:\n        p_coord_sub = copy.deepcopy(p_coord[p_view])\n        q_coord_sub = copy.deepcopy(q_coord[q_view])\n        p_atoms_sub = copy.deepcopy(p_atoms[p_view])\n        q_atoms_sub = copy.deepcopy(q_atoms[q_view])\n\n    else:\n        p_coord_sub = copy.deepcopy(p_coord)\n        q_coord_sub = copy.deepcopy(q_coord)\n        p_atoms_sub = copy.deepcopy(p_atoms)\n        q_atoms_sub = copy.deepcopy(q_atoms)\n\n    # Recenter to centroid\n    p_cent_sub = centroid(p_coord_sub)\n    q_cent_sub = centroid(q_coord_sub)\n    p_coord_sub -= p_cent_sub\n    q_coord_sub -= q_cent_sub\n\n    rmsd_method: RmsdCallable\n    reorder_method: Optional[ReorderCallable]\n\n    # set rotation method\n    if settings.rotation == METHOD_KABSCH:\n        rmsd_method = kabsch_rmsd\n    elif settings.rotation == METHOD_QUATERNION:\n        rmsd_method = quaternion_rmsd\n    else:\n        rmsd_method = rmsd\n\n    # set reorder method\n    reorder_method = None\n    if settings.reorder_method == REORDER_QML:\n        reorder_method = reorder_similarity\n    elif settings.reorder_method == REORDER_HUNGARIAN:\n        reorder_method = reorder_hungarian\n    elif settings.reorder_method == REORDER_INERTIA_HUNGARIAN:\n        reorder_method = reorder_inertia_hungarian\n    elif settings.reorder_method == REORDER_BRUTE:\n        reorder_method = reorder_brute  # pragma: no cover\n    elif settings.reorder_method == REORDER_DISTANCE:\n        reorder_method = reorder_distance\n\n    # Save the resulting RMSD\n    result_rmsd: Optional[float] = None\n\n    # Collect changes to be done on q coords\n    q_swap = None\n    q_reflection = None\n    q_review = None\n\n    if settings.use_reflections:\n        result_rmsd, q_swap, q_reflection, q_review = check_reflections(\n            p_atoms_sub,\n            q_atoms_sub,\n            p_coord_sub,\n            q_coord_sub,\n            reorder_method=reorder_method,\n            rmsd_method=rmsd_method,\n        )\n\n    elif settings.use_reflections_keep_stereo:\n        result_rmsd, q_swap, q_reflection, q_review = check_reflections(\n            p_atoms_sub,\n            q_atoms_sub,\n            p_coord_sub,\n            q_coord_sub,\n            reorder_method=reorder_method,\n            rmsd_method=rmsd_method,\n            keep_stereo=True,\n        )\n\n    elif settings.reorder:\n        assert (\n            reorder_method is not None\n        ), \"Cannot reorder without selecting --reorder method\"\n        q_review = reorder_method(p_atoms_sub, q_atoms_sub, p_coord_sub, q_coord_sub)\n\n    # If there is a reorder, then apply before print\n    if q_review is not None:\n        q_atoms_sub = q_atoms_sub[q_review]\n        q_coord_sub = q_coord_sub[q_review]\n\n        assert all(\n            p_atoms_sub == q_atoms_sub\n        ), \"error: Structure not aligned. Please submit bug report at http://github.com/charnley/rmsd\"\n\n    # Calculate the RMSD value\n    if result_rmsd is None:\n        result_rmsd = rmsd_method(p_coord_sub, q_coord_sub)\n\n    # print result\n    if settings.output:\n        if q_swap is not None:\n            q_coord_sub = q_coord_sub[:, q_swap]\n\n        if q_reflection is not None:\n            q_coord_sub = np.dot(q_coord_sub, np.diag(q_reflection))\n\n        U = kabsch(q_coord_sub, p_coord_sub)\n\n        if settings.print_only_rmsd_atoms or not use_view:\n            q_coord_sub = np.dot(q_coord_sub, U)\n            q_coord_sub += p_cent_sub\n            return set_coordinates(\n                q_atoms_sub,\n                q_coord_sub,\n                title=f\"Rotated '{settings.structure_b}' to match '{settings.structure_a}', with a RMSD of {result_rmsd:.8f}\",\n            )\n\n        # Swap, reflect, rotate and re-center on the full atom and coordinate set\n        q_coord -= q_cent_sub\n\n        if q_swap is not None:\n            q_coord = q_coord[:, q_swap]\n\n        if q_reflection is not None:\n            q_coord = np.dot(q_coord, np.diag(q_reflection))\n\n        q_coord = np.dot(q_coord, U)\n        q_coord += p_cent_sub\n        return set_coordinates(\n            q_atoms,\n            q_coord,\n            title=f\"Rotated {settings.structure_b} to match {settings.structure_a}, with RMSD of {result_rmsd:.8f}\",\n        )\n\n    return str(result_rmsd)\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.makeQ","title":"makeQ","text":"<pre><code>makeQ(r1: float, r2: float, r3: float, r4: float = 0) -&gt; ndarray\n</code></pre> <p>matrix involved in quaternion rotation</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def makeQ(r1: float, r2: float, r3: float, r4: float = 0) -&gt; ndarray:\n    \"\"\"\n    matrix involved in quaternion rotation\n    \"\"\"\n    Q = np.asarray(\n        [\n            [r4, -r3, r2, r1],\n            [r3, r4, -r1, r2],\n            [-r2, r1, r4, r3],\n            [-r1, -r2, -r3, r4],\n        ]\n    )\n    return Q\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.makeW","title":"makeW","text":"<pre><code>makeW(r1: float, r2: float, r3: float, r4: float = 0) -&gt; ndarray\n</code></pre> <p>matrix involved in quaternion rotation</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def makeW(r1: float, r2: float, r3: float, r4: float = 0) -&gt; ndarray:\n    \"\"\"\n    matrix involved in quaternion rotation\n    \"\"\"\n    W = np.asarray(\n        [\n            [r4, r3, -r2, r1],\n            [-r3, r4, r1, r2],\n            [r2, -r1, r4, r3],\n            [-r1, -r2, -r3, r4],\n        ]\n    )\n    return W\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.parse_arguments","title":"parse_arguments","text":"<pre><code>parse_arguments(arguments: Optional[Union[str, List[str]]] = None) -&gt; Namespace\n</code></pre> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def parse_arguments(\n    arguments: Optional[Union[str, List[str]]] = None,\n) -&gt; argparse.Namespace:\n    description = __doc__\n\n    version_msg = f\"\"\"\nrmsd {__version__}\n\nSee https://github.com/charnley/rmsd for citation information\n\n\"\"\"\n\n    epilog = \"\"\"\n\"\"\"\n\n    valid_reorder_methods = \", \".join(REORDER_METHODS)\n    valid_rotation_methods = \", \".join(ROTATION_METHODS)\n\n    parser = argparse.ArgumentParser(\n        usage=\"calculate_rmsd [options] FILE_A FILE_B\",\n        description=description,\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=epilog,\n    )\n\n    # Input structures\n    parser.add_argument(\n        \"structure_a\",\n        metavar=\"FILE_A\",\n        type=str,\n        help=\"structures in .xyz or .pdb format\",\n    )\n    parser.add_argument(\"structure_b\", metavar=\"FILE_B\", type=str)\n\n    # Admin\n    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=version_msg)\n\n    # Rotation\n    parser.add_argument(\n        \"-r\",\n        \"--rotation\",\n        action=\"store\",\n        default=\"kabsch\",\n        help=(\n            \"select rotation method. Valid methods are \"\n            f\"{valid_rotation_methods}. \"\n            \"Default is Kabsch.\"\n        ),\n        metavar=\"METHOD\",\n        choices=ROTATION_METHODS,\n    )\n\n    # Reorder arguments\n    parser.add_argument(\n        \"-e\",\n        \"--reorder\",\n        action=\"store_true\",\n        help=\"align the atoms of molecules\",\n    )\n    parser.add_argument(\n        \"--reorder-method\",\n        action=\"store\",\n        default=\"hungarian\",\n        metavar=\"METHOD\",\n        help=(\n            \"select reorder method. Valid method are \"\n            f\"{valid_reorder_methods}. \"\n            \"Default is Hungarian.\"\n        ),\n        choices=REORDER_METHODS,\n    )\n    parser.add_argument(\n        \"-ur\",\n        \"--use-reflections\",\n        action=\"store_true\",\n        help=(\n            \"scan through reflections in planes \"\n            \"(eg Y transformed to -Y -&gt; X, -Y, Z) \"\n            \"and axis changes, (eg X and Z coords exchanged -&gt; Z, Y, X). \"\n            \"This will affect stereo-chemistry.\"\n        ),\n    )\n    parser.add_argument(\n        \"-urks\",\n        \"--use-reflections-keep-stereo\",\n        action=\"store_true\",\n        help=(\n            \"scan through reflections in planes \"\n            \"(eg Y transformed to -Y -&gt; X, -Y, Z) \"\n            \"and axis changes, (eg X and Z coords exchanged -&gt; Z, Y, X). \"\n            \"Stereo-chemistry will be kept.\"\n        ),\n    )\n\n    # Filter\n    index_group = parser.add_mutually_exclusive_group()\n    index_group.add_argument(\n        \"--only-alpha-carbons\",\n        action=\"store_true\",\n        help=\"use only alpha carbons (only for pdb)\",\n    )\n    index_group.add_argument(\n        \"-nh\",\n        \"--ignore-hydrogen\",\n        \"--no-hydrogen\",\n        action=\"store_true\",\n        help=\"ignore hydrogens when calculating RMSD\",\n    )\n    index_group.add_argument(\n        \"--remove-idx\",\n        nargs=\"+\",\n        type=int,\n        help=\"index list of atoms NOT to consider\",\n        metavar=\"IDX\",\n    )\n    index_group.add_argument(\n        \"--add-idx\",\n        nargs=\"+\",\n        type=int,\n        help=\"index list of atoms to consider\",\n        metavar=\"IDX\",\n    )\n\n    parser.add_argument(\n        \"--format\",\n        action=\"store\",\n        help=f\"format of input files. valid format are {', '.join(FORMATS)}.\",\n        metavar=\"FMT\",\n    )\n    parser.add_argument(\n        \"--format-is-gzip\",\n        action=\"store_true\",\n        default=False,\n        help=argparse.SUPPRESS,\n    )\n\n    parser.add_argument(\n        \"-p\",\n        \"--output\",\n        \"--print\",\n        action=\"store_true\",\n        help=(\n            \"print out structure B, centered and rotated unto structure A's coordinates in XYZ format\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--print-only-rmsd-atoms\",\n        action=\"store_true\",\n        help=(\n            \"Print only atoms used in finding optimal RMSD calculation (relevant if filtering e.g. Hydrogens)\"\n        ),\n    )\n\n    args = parser.parse_args(arguments)\n\n    # Check illegal combinations\n    if (\n        args.output\n        and args.reorder\n        and (args.ignore_hydrogen or args.add_idx or args.remove_idx)\n    ):\n        print(\n            \"error: Cannot reorder atoms and print structure, when excluding atoms (such as --ignore-hydrogen)\"\n        )\n        sys.exit(5)\n\n    if (\n        args.use_reflections\n        and args.output\n        and (args.ignore_hydrogen or args.add_idx or args.remove_idx)\n    ):\n        print(\n            \"error: Cannot use reflections on atoms and print, \"\n            \"when excluding atoms (such as --ignore-hydrogen)\"\n        )\n        sys.exit(5)\n\n    # Check methods\n    args.rotation = args.rotation.lower()\n    if args.rotation not in ROTATION_METHODS:\n        print(\n            f\"error: Unknown rotation method: '{args.rotation}'. \"\n            f\"Please use {valid_rotation_methods}\"\n        )\n        sys.exit(5)\n\n    # Check reorder methods\n    args.reorder_method = args.reorder_method.lower()\n    if args.reorder_method not in REORDER_METHODS:\n        print(\n            f'error: Unknown reorder method: \"{args.reorder_method}\". '\n            f\"Please use {valid_reorder_methods}\"\n        )\n        sys.exit(5)\n\n    # Check fileformat\n    if args.format is None:\n        filename = args.structure_a\n        suffixes = Path(filename).suffixes\n\n        if len(suffixes) == 0:\n            ext = None\n\n        elif suffixes[-1] == \".gz\":\n            args.format_is_gzip = True\n            ext = suffixes[-2].strip(\".\")\n\n        else:\n            ext = suffixes[-1].strip(\".\")\n\n        args.format = ext\n\n    # Check if format exist\n    if args.format not in FORMATS:\n        print(f\"error: Format not supported {args.format}\")\n        sys.exit(5)\n\n    # Check illegal argument\n    if args.format != FORMAT_PDB and args.only_alpha_carbons:\n        print(\"Alpha carbons only exist in pdb files\")\n        sys.exit(5)\n\n    # Check QML is installed\n    if args.reorder_method == REORDER_QML and qmllib is None:\n        print(\n            \"'qmllib' is not installed. Package is avaliable from: github.com/qmlcode/qmllib or pip install qmllib.\"\n        )\n        sys.exit(1)\n\n    return args\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.quaternion_rmsd","title":"quaternion_rmsd","text":"<pre><code>quaternion_rmsd(P: ndarray, Q: ndarray, **kwargs: Any) -&gt; float\n</code></pre> <p>Rotate matrix P unto Q and calculate the RMSD based on doi:10.1016/1049-9660(91)90036-O</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Q</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rmsd</code> (              <code>float</code> )          \u2013            </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def quaternion_rmsd(P: ndarray, Q: ndarray, **kwargs: Any) -&gt; float:\n    \"\"\"\n    Rotate matrix P unto Q and calculate the RMSD\n    based on doi:10.1016/1049-9660(91)90036-O\n\n    Parameters\n    ----------\n    P : array\n        (N,D) matrix, where N is points and D is dimension.\n    Q : array\n        (N,D) matrix, where N is points and D is dimension.\n\n    Returns\n    -------\n    rmsd : float\n    \"\"\"\n    rot = quaternion_rotate(P, Q)\n    P = np.dot(P, rot)\n    return rmsd(P, Q)\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.quaternion_rotate","title":"quaternion_rotate","text":"<pre><code>quaternion_rotate(X: ndarray, Y: ndarray) -&gt; ndarray\n</code></pre> <p>Calculate the rotation</p> <p>Parameters:</p> <ul> <li> <code>X</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>Y</code>               (<code>ndarray</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rot</code> (              <code>matrix</code> )          \u2013            <p>Rotation matrix (D,D)</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def quaternion_rotate(X: ndarray, Y: ndarray) -&gt; ndarray:\n    \"\"\"\n    Calculate the rotation\n\n    Parameters\n    ----------\n    X : array\n        (N,D) matrix, where N is points and D is dimension.\n    Y: array\n        (N,D) matrix, where N is points and D is dimension.\n\n    Returns\n    -------\n    rot : matrix\n        Rotation matrix (D,D)\n    \"\"\"\n    N = X.shape[0]\n    W = np.asarray([makeW(*Y[k]) for k in range(N)])\n    Q = np.asarray([makeQ(*X[k]) for k in range(N)])\n    Qt_dot_W = np.asarray([np.dot(Q[k].T, W[k]) for k in range(N)])\n    # NOTE UNUSED W_minus_Q = np.asarray([W[k] - Q[k] for k in range(N)])\n    A = np.sum(Qt_dot_W, axis=0)\n    eigen = np.linalg.eigh(A)\n    r = eigen[1][:, eigen[0].argmax()]\n    rot = quaternion_transform(r)\n    return rot\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.quaternion_transform","title":"quaternion_transform","text":"<pre><code>quaternion_transform(r: ndarray) -&gt; ndarray\n</code></pre> <p>Get optimal rotation note: translation will be zero when the centroids of each molecule are the same</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def quaternion_transform(r: ndarray) -&gt; ndarray:\n    \"\"\"\n    Get optimal rotation\n    note: translation will be zero when the centroids of each molecule are the\n    same\n    \"\"\"\n    Wt_r = makeW(*r).T\n    Q_r = makeQ(*r)\n    rot: ndarray = Wt_r.dot(Q_r)[:3, :3]\n    return rot\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.reorder_brute","title":"reorder_brute","text":"<pre><code>reorder_brute(p_atoms: ndarray, q_atoms: ndarray, p_coord: ndarray, q_coord: ndarray, **kwargs: Any) -&gt; ndarray\n</code></pre> <p>Re-orders the input atom list and xyz coordinates using all permutation of rows (using optimized column results)</p> <p>Parameters:</p> <ul> <li> <code>p_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>q_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>p_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> <li> <code>q_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>view_reorder</code> (              <code>array</code> )          \u2013            <p>(N,1) matrix, reordered indexes of atom alignment based on the coordinates of the atoms</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def reorder_brute(\n    p_atoms: ndarray,\n    q_atoms: ndarray,\n    p_coord: ndarray,\n    q_coord: ndarray,\n    **kwargs: Any,\n) -&gt; ndarray:\n    \"\"\"\n    Re-orders the input atom list and xyz coordinates using all permutation of\n    rows (using optimized column results)\n\n    Parameters\n    ----------\n    p_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    q_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    p_coord : array\n        (N,D) matrix, where N is points and D is dimension\n    q_coord : array\n        (N,D) matrix, where N is points and D is dimension\n\n    Returns\n    -------\n    view_reorder : array\n        (N,1) matrix, reordered indexes of atom alignment based on the\n        coordinates of the atoms\n\n    \"\"\"\n\n    # Find unique atoms\n    unique_atoms = np.unique(p_atoms)\n\n    # generate full view from q shape to fill in atom view on the fly\n    view_reorder = np.zeros(q_atoms.shape, dtype=int)\n    view_reorder -= 1\n\n    for atom in unique_atoms:\n        (p_atom_idx,) = np.where(p_atoms == atom)\n        (q_atom_idx,) = np.where(q_atoms == atom)\n\n        A_coord = p_coord[p_atom_idx]\n        B_coord = q_coord[q_atom_idx]\n\n        view = brute_permutation(A_coord, B_coord)\n        view_reorder[p_atom_idx] = q_atom_idx[view]\n\n    return view_reorder\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.reorder_distance","title":"reorder_distance","text":"<pre><code>reorder_distance(p_atoms: ndarray, q_atoms: ndarray, p_coord: ndarray, q_coord: ndarray, **kwargs: Any) -&gt; ndarray\n</code></pre> <p>Re-orders the input atom list and xyz coordinates by atom type and then by distance of each atom from the centroid.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms_reordered</code> (              <code>array</code> )          \u2013            <p>(N,1) matrix, where N is points holding the ordered atoms' names</p> </li> <li> <code>coords_reordered</code> (              <code>array</code> )          \u2013            <p>(N,D) matrix, where N is points and D is dimension (rows re-ordered)</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def reorder_distance(\n    p_atoms: ndarray,\n    q_atoms: ndarray,\n    p_coord: ndarray,\n    q_coord: ndarray,\n    **kwargs: Any,\n) -&gt; ndarray:\n    \"\"\"\n    Re-orders the input atom list and xyz coordinates by atom type and then by\n    distance of each atom from the centroid.\n\n    Parameters\n    ----------\n    atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    coord : array\n        (N,D) matrix, where N is points and D is dimension\n\n    Returns\n    -------\n    atoms_reordered : array\n        (N,1) matrix, where N is points holding the ordered atoms' names\n    coords_reordered : array\n        (N,D) matrix, where N is points and D is dimension (rows re-ordered)\n    \"\"\"\n\n    # Find unique atoms\n    unique_atoms = np.unique(p_atoms)\n\n    # generate full view from q shape to fill in atom view on the fly\n    view_reorder = np.zeros(q_atoms.shape, dtype=int)\n\n    for atom in unique_atoms:\n        (p_atom_idx,) = np.where(p_atoms == atom)\n        (q_atom_idx,) = np.where(q_atoms == atom)\n\n        A_coord = p_coord[p_atom_idx]\n        B_coord = q_coord[q_atom_idx]\n\n        # Calculate distance from each atom to centroid\n        A_norms = np.linalg.norm(A_coord, axis=1)\n        B_norms = np.linalg.norm(B_coord, axis=1)\n\n        reorder_indices_A = np.argsort(A_norms)\n        reorder_indices_B = np.argsort(B_norms)\n\n        # Project the order of P onto Q\n        translator = np.argsort(reorder_indices_A)\n        view = reorder_indices_B[translator]\n        view_reorder[p_atom_idx] = q_atom_idx[view]\n\n    return view_reorder\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.reorder_hungarian","title":"reorder_hungarian","text":"<pre><code>reorder_hungarian(p_atoms: ndarray, q_atoms: ndarray, p_coord: ndarray, q_coord: ndarray, **kwargs: Any) -&gt; ndarray\n</code></pre> <p>Re-orders the input atom list and xyz coordinates using the Hungarian method (using optimized column results)</p> <p>Parameters:</p> <ul> <li> <code>p_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>p_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>p_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> <li> <code>q_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>view_reorder</code> (              <code>array</code> )          \u2013            <p>(N,1) matrix, reordered indexes of atom alignment based on the coordinates of the atoms</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def reorder_hungarian(\n    p_atoms: ndarray,\n    q_atoms: ndarray,\n    p_coord: ndarray,\n    q_coord: ndarray,\n    **kwargs: Any,\n) -&gt; ndarray:\n    \"\"\"\n    Re-orders the input atom list and xyz coordinates using the Hungarian\n    method (using optimized column results)\n\n    Parameters\n    ----------\n    p_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    p_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    p_coord : array\n        (N,D) matrix, where N is points and D is dimension\n    q_coord : array\n        (N,D) matrix, where N is points and D is dimension\n\n    Returns\n    -------\n    view_reorder : array\n             (N,1) matrix, reordered indexes of atom alignment based on the\n             coordinates of the atoms\n\n    \"\"\"\n\n    # Find unique atoms\n    unique_atoms = np.unique(p_atoms)\n\n    # generate full view from q shape to fill in atom view on the fly\n    view_reorder = np.zeros(q_atoms.shape, dtype=int)\n    view_reorder -= 1\n\n    for atom in unique_atoms:\n        (p_atom_idx,) = np.where(p_atoms == atom)\n        (q_atom_idx,) = np.where(q_atoms == atom)\n\n        A_coord = p_coord[p_atom_idx]\n        B_coord = q_coord[q_atom_idx]\n\n        view = hungarian(A_coord, B_coord)\n        view_reorder[p_atom_idx] = q_atom_idx[view]\n\n    return view_reorder\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.reorder_inertia_hungarian","title":"reorder_inertia_hungarian","text":"<pre><code>reorder_inertia_hungarian(p_atoms: ndarray, q_atoms: ndarray, p_coord: ndarray, q_coord: ndarray, **kwargs: Any) -&gt; ndarray\n</code></pre> <p>Align the principal intertia axis and then re-orders the input atom list and xyz coordinates using the Hungarian method (using optimized column results)</p> <p>Parameters:</p> <ul> <li> <code>p_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>p_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>p_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> <li> <code>q_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>view_reorder</code> (              <code>array</code> )          \u2013            <p>(N,1) matrix, reordered indexes of atom alignment based on the coordinates of the atoms</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def reorder_inertia_hungarian(\n    p_atoms: ndarray,\n    q_atoms: ndarray,\n    p_coord: ndarray,\n    q_coord: ndarray,\n    **kwargs: Any,\n) -&gt; ndarray:\n    \"\"\"\n    Align the principal intertia axis and then re-orders the input atom list\n    and xyz coordinates using the Hungarian method (using optimized column\n    results)\n\n    Parameters\n    ----------\n    p_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    p_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    p_coord : array\n        (N,D) matrix, where N is points and D is dimension\n    q_coord : array\n        (N,D) matrix, where N is points and D is dimension\n\n    Returns\n    -------\n    view_reorder : array\n             (N,1) matrix, reordered indexes of atom alignment based on the\n             coordinates of the atoms\n\n    \"\"\"\n    # get the principal axis of P and Q\n    p_axis = get_principal_axis(p_atoms, p_coord)\n    q_axis = get_principal_axis(q_atoms, q_coord)\n\n    # rotate Q onto P considering that the axis are parallel and antiparallel\n    U1 = rotation_matrix_vectors(p_axis, q_axis)\n    U2 = rotation_matrix_vectors(p_axis, -q_axis)\n    q_coord1 = np.dot(q_coord, U1)\n    q_coord2 = np.dot(q_coord, U2)\n\n    q_review1 = reorder_hungarian(p_atoms, q_atoms, p_coord, q_coord1)\n    q_review2 = reorder_hungarian(p_atoms, q_atoms, p_coord, q_coord2)\n    q_coord1 = q_coord1[q_review1]\n    q_coord2 = q_coord2[q_review2]\n\n    rmsd1 = kabsch_rmsd(p_coord, q_coord1)\n    rmsd2 = kabsch_rmsd(p_coord, q_coord2)\n\n    if rmsd1 &lt; rmsd2:\n        return q_review1\n    else:\n        return q_review2\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.reorder_similarity","title":"reorder_similarity","text":"<pre><code>reorder_similarity(p_atoms: ndarray, q_atoms: ndarray, p_coord: ndarray, q_coord: ndarray, use_kernel: bool = True, **kwargs: Any) -&gt; ndarray\n</code></pre> <p>Re-orders the input atom list and xyz coordinates using QML similarity the Hungarian method for assignment.</p> <p>Parameters:</p> <ul> <li> <code>p_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>p_atoms</code>               (<code>array</code>)           \u2013            <p>(N,1) matrix, where N is points holding the atoms' names</p> </li> <li> <code>p_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> <li> <code>q_coord</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>view_reorder</code> (              <code>array</code> )          \u2013            <p>(N,1) matrix, reordered indexes of atom alignment based on the coordinates of the atoms</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def reorder_similarity(\n    p_atoms: ndarray,\n    q_atoms: ndarray,\n    p_coord: ndarray,\n    q_coord: ndarray,\n    use_kernel: bool = True,\n    **kwargs: Any,\n) -&gt; ndarray:\n    \"\"\"\n    Re-orders the input atom list and xyz coordinates using QML similarity\n    the Hungarian method for assignment.\n\n    Parameters\n    ----------\n    p_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    p_atoms : array\n        (N,1) matrix, where N is points holding the atoms' names\n    p_coord : array\n        (N,D) matrix, where N is points and D is dimension\n    q_coord : array\n        (N,D) matrix, where N is points and D is dimension\n\n    Returns\n    -------\n    view_reorder : array\n             (N,1) matrix, reordered indexes of atom alignment based on the\n             coordinates of the atoms\n    \"\"\"\n\n    elements = np.unique(p_atoms)\n    n_atoms = p_atoms.shape[0]\n    distance_cut = 20.0\n\n    parameters = {\n        \"elements\": elements,\n        \"pad\": n_atoms,\n        \"rcut\": distance_cut,\n        \"acut\": distance_cut,\n    }\n\n    p_vecs = generate_fchl19(p_atoms, p_coord, **parameters)\n\n    q_vecs = generate_fchl19(q_atoms, q_coord, **parameters)\n\n    # generate full view from q shape to fill in atom view on the fly\n    view_reorder = np.zeros(q_atoms.shape, dtype=int)\n\n    for atom in elements:\n        (p_atom_idx,) = np.where(p_atoms == atom)\n        (q_atom_idx,) = np.where(q_atoms == atom)\n\n        p_vecs_atom = p_vecs[p_atom_idx]\n        q_vecs_atom = q_vecs[q_atom_idx]\n\n        view = hungarian_vectors(p_vecs_atom, q_vecs_atom, use_kernel=use_kernel)\n        view_reorder[p_atom_idx] = q_atom_idx[view]\n\n    return view_reorder\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.rmsd","title":"rmsd","text":"<pre><code>rmsd(P: ndarray, Q: ndarray, **kwargs) -&gt; float\n</code></pre> <p>Calculate Root-mean-square deviation from two sets of vectors V and W.</p> <p>Parameters:</p> <ul> <li> <code>V</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> <li> <code>W</code>               (<code>array</code>)           \u2013            <p>(N,D) matrix, where N is points and D is dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rmsd</code> (              <code>float</code> )          \u2013            <p>Root-mean-square deviation between the two vectors</p> </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def rmsd(P: ndarray, Q: ndarray, **kwargs) -&gt; float:\n    \"\"\"\n    Calculate Root-mean-square deviation from two sets of vectors V and W.\n\n    Parameters\n    ----------\n    V : array\n        (N,D) matrix, where N is points and D is dimension.\n    W : array\n        (N,D) matrix, where N is points and D is dimension.\n\n    Returns\n    -------\n    rmsd : float\n        Root-mean-square deviation between the two vectors\n    \"\"\"\n    diff = P - Q\n    return np.sqrt((diff * diff).sum() / P.shape[0])\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.rotation_matrix_vectors","title":"rotation_matrix_vectors","text":"<pre><code>rotation_matrix_vectors(v1: ndarray, v2: ndarray) -&gt; ndarray\n</code></pre> <p>Returns the rotation matrix that rotates v1 onto v2 using Rodrigues' rotation formula.</p> (see https://math.stackexchange.com/a/476311) <p>v1 : array     Dim 3 float array v2 : array     Dim 3 float array</p> Return <p>output : 3x3 matrix     Rotation matrix</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def rotation_matrix_vectors(v1: ndarray, v2: ndarray) -&gt; ndarray:\n    \"\"\"\n    Returns the rotation matrix that rotates v1 onto v2\n    using Rodrigues' rotation formula.\n    (see https://math.stackexchange.com/a/476311)\n    ----------\n    v1 : array\n        Dim 3 float array\n    v2 : array\n        Dim 3 float array\n\n    Return\n    ------\n    output : 3x3 matrix\n        Rotation matrix\n    \"\"\"\n\n    rot: ndarray\n\n    if (v1 == v2).all():\n        rot = np.eye(3)\n\n    # return a rotation of pi around the y-axis\n    elif (v1 == -v2).all():\n        rot = np.array([[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]])\n\n    else:\n        v = np.cross(v1, v2)\n        s = np.linalg.norm(v)\n        c = np.vdot(v1, v2)\n\n        vx = np.array([[0.0, -v[2], v[1]], [v[2], 0.0, -v[0]], [-v[1], v[0], 0.0]])\n\n        rot = np.eye(3) + vx + np.dot(vx, vx) * ((1.0 - c) / (s * s))\n\n    return rot\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.set_coordinates","title":"set_coordinates","text":"<pre><code>set_coordinates(atoms: ndarray, V: ndarray, title: str = '', decimals: int = 8) -&gt; str\n</code></pre> <p>Print coordinates V with corresponding atoms to stdout in XYZ format.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>list</code>)           \u2013            <p>List of atomic types</p> </li> <li> <code>V</code>               (<code>array</code>)           \u2013            <p>(N,3) matrix of atomic coordinates</p> </li> <li> <code>title</code>               (<code>string(optional)</code>, default:                   <code>''</code> )           \u2013            <p>Title of molecule</p> </li> <li> <code>decimals</code>               (<code>int(optional)</code>, default:                   <code>8</code> )           \u2013            <p>number of decimals for the coordinates</p> </li> </ul> Return <p>output : str     Molecule in XYZ format</p> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def set_coordinates(\n    atoms: ndarray, V: ndarray, title: str = \"\", decimals: int = 8\n) -&gt; str:\n    \"\"\"\n    Print coordinates V with corresponding atoms to stdout in XYZ format.\n    Parameters\n    ----------\n    atoms : list\n        List of atomic types\n    V : array\n        (N,3) matrix of atomic coordinates\n    title : string (optional)\n        Title of molecule\n    decimals : int (optional)\n        number of decimals for the coordinates\n\n    Return\n    ------\n    output : str\n        Molecule in XYZ format\n\n    \"\"\"\n    N, D = V.shape\n\n    if len(atoms) != N:\n        raise ValueError(\"Mismatch between expected atoms and coordinate size\")\n\n    fmt = \"{:&lt;2}\" + (\" {:15.\" + str(decimals) + \"f}\") * 3\n\n    out = list()\n    out += [str(N)]\n    out += [title]\n\n    for i in range(N):\n        atom = atoms[i]\n        out += [fmt.format(atom, V[i, 0], V[i, 1], V[i, 2])]\n\n    return \"\\n\".join(out)\n</code></pre>"},{"location":"reference/himatcal/utils/rmsd.html#himatcal.utils.rmsd.str_atom","title":"str_atom","text":"<pre><code>str_atom(atom: int) -&gt; str\n</code></pre> <p>Convert atom type from integer to string</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>string</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code> (              <code>integer</code> )          \u2013            </li> </ul> Source code in <code>himatcal/utils/rmsd.py</code> <pre><code>def str_atom(atom: int) -&gt; str:\n    \"\"\"\n    Convert atom type from integer to string\n\n    Parameters\n    ----------\n    atoms : string\n\n    Returns\n    -------\n    atoms : integer\n\n    \"\"\"\n    return ELEMENT_NAMES[atom]\n</code></pre>"},{"location":"reference/himatcal/utils/visualize.html","title":"visualize","text":"<p>functions for visualization</p>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize--todo","title":"TODO:","text":""},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.InitStyleConfig","title":"InitStyleConfig","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.InitStyleConfig.vis","title":"vis  <code>instance-attribute</code>","text":"<pre><code>vis: Literal['mpl', 'bokeh']\n</code></pre>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.InitStyleConfig.check_vis","title":"check_vis","text":"<pre><code>check_vis(v)\n</code></pre> Source code in <code>himatcal/utils/visualize.py</code> <pre><code>@field_validator(\"vis\")\ndef check_vis(cls, v):\n    if v not in [\"mpl\", \"bokeh\"]:\n        raise ValueError(\"vis must be either 'mpl' or 'bokeh'\")\n    return v\n</code></pre>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.init_style","title":"init_style","text":"<pre><code>init_style(vis: Literal['mpl', 'bokeh'] = 'mpl')\n</code></pre> <p>Use the science style for matplotlib plots.</p> <p>This function sets the style and font family for matplotlib plots to a predefined science style.</p> <p>Args:     vis (Literal[\"mpl\", \"bokeh\"]): The visualization library to use. Options are 'mpl' or 'bokeh'.</p> <p>Returns:     None</p> Source code in <code>himatcal/utils/visualize.py</code> <pre><code>def init_style(vis: Literal[\"mpl\", \"bokeh\"] = \"mpl\"):\n    \"\"\"\n    Use the science style for matplotlib plots.\n\n    This function sets the style and font family for matplotlib plots to a predefined science style.\n\n    Args:\n        vis (Literal[\"mpl\", \"bokeh\"]): The visualization library to use. Options are 'mpl' or 'bokeh'.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        config = InitStyleConfig(vis=vis)\n    except ValidationError as e:\n        import logging\n\n        logging.error(e)\n        return\n\n    import pkg_resources\n\n    if config.vis == \"mpl\":\n        import matplotlib.pyplot as plt\n\n        plt.style.use(\n            pkg_resources.resource_filename(\"himatcal\", \"tools/science-1.mplstyle\")\n        )\n        plt.rcParams[\"font.family\"] = \"Calibri, Microsoft YaHei\"\n    elif config.vis == \"bokeh\":\n        import json\n\n        from bokeh.io import curdoc\n        from bokeh.themes import Theme\n\n        with Path.open(\n            Path(pkg_resources.resource_filename(\"himatcal\", \"tools/bokeh_theme.json\"))\n        ) as f:\n            theme_dict = json.load(f)\n            theme = Theme(json=theme_dict)\n\n        curdoc().theme = theme\n</code></pre>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.mpl_view_atoms","title":"mpl_view_atoms","text":"<pre><code>mpl_view_atoms(atoms)\n</code></pre> <p>view atoms using matplotlib at top and side view</p> Source code in <code>himatcal/utils/visualize.py</code> <pre><code>def mpl_view_atoms(atoms):\n    \"\"\"\n    view atoms using matplotlib at top and side view\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from ase.visualize.plot import plot_atoms\n\n    fig, axs = plt.subplots(1, 2, figsize=(5, 5))\n    plot_atoms(atoms, axs[0])\n    plot_atoms(atoms, axs[1], rotation=(\"-90x\"))\n</code></pre>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.show_xyz_mol","title":"show_xyz_mol","text":"<pre><code>show_xyz_mol(xyz_file: Path)\n</code></pre> <p>Visualize a stk molecule using py3Dmol.</p> Source code in <code>himatcal/utils/visualize.py</code> <pre><code>def show_xyz_mol(xyz_file: Path):\n    \"\"\"\n    Visualize a stk molecule using py3Dmol.\n    \"\"\"\n    import py3Dmol\n\n    with xyz_file.open(\"r\") as file:\n        mol = file.read()\n\n    p = py3Dmol.view(\n        data=mol,\n        style={\"stick\": {\"colorscheme\": \"Jmol\"}},\n        width=400,\n        height=400,\n    )\n    p.setBackgroundColor(\"white\")\n    p.zoomTo()\n    p.show()\n</code></pre>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.view_atoms","title":"view_atoms","text":"<pre><code>view_atoms(atoms: Atoms, engine: str = 'weaswidget')\n</code></pre> Source code in <code>himatcal/utils/visualize.py</code> <pre><code>def view_atoms(atoms: Atoms, engine: str = \"weaswidget\"):\n    if engine == \"py3Dmol\":\n        return view_atoms_py3dmol(atoms)\n    elif engine == \"weaswidget\":\n        from weas_widget import WeasWidget\n\n        return WeasWidget(from_ase=atoms)\n    else:\n        raise ValueError(\"Invalid engine\")\n</code></pre>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.view_atoms_py3dmol","title":"view_atoms_py3dmol","text":"<pre><code>view_atoms_py3dmol(atoms)\n</code></pre> Source code in <code>himatcal/utils/visualize.py</code> <pre><code>def view_atoms_py3dmol(atoms):\n    import py3Dmol\n    from ase.io import write\n\n    Path(\".cache\").mkdir(exist_ok=True)\n    tmp_path = Path(\".cache/tmp_atoms\")\n    write(tmp_path, atoms, format=\"xyz\")\n    atoms_data = Path.open(tmp_path).read()\n    view = py3Dmol.view(width=800, height=400)\n    view.addModel(atoms_data, format)\n    view.setStyle({\"stick\": {}})\n    view.zoomTo()\n    return view\n</code></pre>"},{"location":"reference/himatcal/utils/visualize.html#himatcal.utils.visualize.xyz_to_mol","title":"xyz_to_mol","text":"<pre><code>xyz_to_mol(xyz_file: Path, write_mol=True)\n</code></pre> <p>Convert a xyz file to a mol file and block.</p> Source code in <code>himatcal/utils/visualize.py</code> <pre><code>def xyz_to_mol(xyz_file: Path, write_mol=True):\n    \"\"\"\n    Convert a xyz file to a mol file and block.\n    \"\"\"\n    from openbabel import pybel as pb  # type: ignore\n\n    # TODO: Find another way to convert xyz to mol\n    # ! openbabel is a conda package, try other packages if openbabel is not available.\n    mol = next(pb.readfile(\"xyz\", xyz_file))\n    if write_mol:\n        mol.write(\"mol\", f\"{xyz_file}.mol\", overwrite=True)\n        return Path(f\"{xyz_file}.mol\").open().read()\n    return None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html","title":"chem","text":"<p>--chem.py-- Declaring classes. (Intermediates, molecules, atoms, ...) Some parts can be replaced by ASE formats, but now we are using these settings for convenient customization.</p>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom","title":"Atom","text":"<pre><code>Atom(data=None)\n</code></pre> <p>:class Atom:     class Atom mainly contains atomic_number, element, and x,     Other attributes are not widely used     molecule_index shows on which molecule that this atom is contained in. For example, if we consider Intermediate C.C,     molecule_index can have either 0 or 1, and every atom within atom_list of Intermediate can be assigned by checking     which molecule does the atom belong to.</p> <p>:param data(str or integer):     Data is either symbol that represents element or atomic number</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def __init__(self, data=None):\n    self.atomic_number = None\n    self.element = None\n    self.x = 0.00\n    self.y = 0.00\n    self.z = 0.00\n    self.molecule_index = 0\n    self.is_divalent_hydrogen = False\n    if data is not None:\n        if type(data) is str:\n            self.element = data\n        else:\n            self.atomic_number = data\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.atomic_number","title":"atomic_number  <code>instance-attribute</code>","text":"<pre><code>atomic_number = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.element","title":"element  <code>instance-attribute</code>","text":"<pre><code>element = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.is_divalent_hydrogen","title":"is_divalent_hydrogen  <code>instance-attribute</code>","text":"<pre><code>is_divalent_hydrogen = False\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.molecule_index","title":"molecule_index  <code>instance-attribute</code>","text":"<pre><code>molecule_index = 0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.periodic_table","title":"periodic_table  <code>class-attribute</code>","text":"<pre><code>periodic_table: list[str] = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn']\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x = 0.0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y = 0.0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z = 0.0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.__eq__","title":"__eq__","text":"<pre><code>__eq__(atom)\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def __eq__(self, atom):\n    return self.is_same_atom(atom)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def copy(self):\n    new_atom = Atom()\n    # Copy all attributes\n    new_atom.atomic_number = self.atomic_number\n    new_atom.element = self.element\n    new_atom.x = self.x\n    new_atom.y = self.y\n    new_atom.z = self.z\n    return new_atom\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.get_atomic_number","title":"get_atomic_number","text":"<pre><code>get_atomic_number()\n</code></pre> <p>Returns the atomic number (number of protons) of a given atom.</p> <p>:param:</p> <p>:return integer:     Directly the atomic number of a given atom is returned</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_atomic_number(self):\n    \"\"\"\n    Returns the atomic number (number of protons) of a given atom.\n\n    :param:\n\n    :return integer:\n        Directly the atomic number of a given atom is returned\n    \"\"\"\n    if self.atomic_number == None:\n        element = self.element\n        if element == None:\n            print(\"atom is not specified!\")\n        if len(element) &gt; 1:\n            end_part = element[1:]\n            end_part = str.lower(end_part)\n            element = element[0] + end_part\n            self.element = element\n        if element in periodic_table:\n            index = periodic_table.index(element)\n            self.atomic_number = index + 1\n        else:\n            print(\"element\", element)\n            print(\"modify periodic table!!!\")\n    return self.atomic_number\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.get_content","title":"get_content","text":"<pre><code>get_content(option='element', criteria=0.0001)\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_content(self, option=\"element\", criteria=1e-4):\n    x = self.x\n    y = self.y\n    z = self.z\n    if abs(x) &lt; criteria:\n        x = 0.00\n    if abs(y) &lt; criteria:\n        y = 0.00\n    if abs(z) &lt; criteria:\n        z = 0.00\n    content = \" \" + str(x) + \" \" + str(y) + \" \" + str(z) + \"\\n\"\n    if option == \"element\":\n        content = self.get_element() + content\n    else:\n        content = str(self.get_atomic_number()) + content\n    return content\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.get_coordinate","title":"get_coordinate","text":"<pre><code>get_coordinate()\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_coordinate(self):\n    return np.array([self.x, self.y, self.z])\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.get_element","title":"get_element","text":"<pre><code>get_element()\n</code></pre> <p>Returns symbol of a given atom.</p> <p>:param:</p> <p>:return str:     Directly the symbol of a given atom is returned</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_element(self):\n    \"\"\"\n    Returns symbol of a given atom.\n\n    :param:\n\n    :return str:\n        Directly the symbol of a given atom is returned\n    \"\"\"\n    if self.element == None:\n        atomic_number = self.atomic_number\n        if atomic_number == None:\n            print(\"atom is not specified!\")\n        z = int(self.atomic_number) - 1\n        self.element = periodic_table[z]\n    return self.element\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.get_mass","title":"get_mass","text":"<pre><code>get_mass()\n</code></pre> <p>Returns the exact value (float) of an atomic mass of a given atom.</p> <p>:param:</p> <p>:return float:     Directly the atomic mass of a given atom is returned</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_mass(self):\n    \"\"\"\n    Returns the exact value (float) of an atomic mass of a given atom.\n\n    :param:\n\n    :return float:\n        Directly the atomic mass of a given atom is returned\n    \"\"\"\n    element = self.get_element()\n    a = str.lower(element)\n    if a == \"h\":\n        return 1.008\n    elif a == \"he\":\n        return 4.003\n    elif a == \"li\":\n        return 6.941\n    elif a == \"be\":\n        return 9.012\n    elif a == \"b\":\n        return 10.81\n    elif a == \"c\":\n        return 12.01\n    elif a == \"n\":\n        return 14.01\n    elif a == \"o\":\n        return 16.00\n    elif a == \"f\":\n        return 19.00\n    elif a == \"ne\":\n        return 20.18\n    elif a == \"na\":\n        return 22.99\n    elif a == \"mg\":\n        return 24.31\n    elif a == \"al\":\n        return 26.98\n    elif a == \"si\":\n        return 28.09\n    elif a == \"p\":\n        return 30.97\n    elif a == \"s\":\n        return 32.07\n    elif a == \"cl\":\n        return 35.45\n    elif a == \"ar\":\n        return 39.95\n    elif a == \"k\":\n        return 39.10\n    elif a == \"ca\":\n        return 40.08\n    elif a == \"au\":\n        return 196.97\n    elif a == \"co\":\n        return 58.9332\n    elif a == \"ni\":\n        return 58.6934\n    elif a == \"ti\":\n        return 47.8671\n    elif a == \"fe\":\n        return 55.845\n    elif a == \"br\":\n        return 79.904\n    elif a == \"rh\":\n        return 102.90550\n    elif a == \"pd\":\n        return 106.42\n    elif a == \"hf\":\n        return 178.49\n    elif a == \"i\":\n        return 126.90447\n    else:\n        return 0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.get_period_group","title":"get_period_group","text":"<pre><code>get_period_group()\n</code></pre> <p>Returns a period,group information from a given atom. It finds period, group by identifying electron configuration (orbital configuration)</p> <p>:param:</p> <p>:return period,group(int,int):     Note that these values are actual period and group. If C atomm is given, it returns 2,4</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_period_group(self):\n    \"\"\"\n    Returns a period,group information from a given atom. It finds period, group by identifying\n    electron configuration (orbital configuration)\n\n    :param:\n\n    :return period,group(int,int):\n        Note that these values are actual period and group. If C atomm is given, it returns 2,4\n\n    \"\"\"\n    atomic_number = self.get_atomic_number()\n    num_of_electrons = atomic_number\n    # Orbital: [n,l,num_of_electrons]\n    sum_of_n_and_l = 1\n    orbital_configuration = []\n    while num_of_electrons &gt; 0:\n        # Generate orbitals within sum_of_n_and_l=k\n        # New orbitals are introduced for (k+1)/2\n        maximal_l = int((sum_of_n_and_l - 1) / 2)\n        for l in range(maximal_l, -1, -1):\n            # Start with lowest l\n            if num_of_electrons &gt; 4 * l + 2:\n                num_of_electrons -= 4 * l + 2\n                orbital_configuration.append([sum_of_n_and_l - l, l, 4 * l + 2])\n            else:\n                orbital_configuration.append(\n                    [sum_of_n_and_l - l, l, num_of_electrons]\n                )\n                num_of_electrons = 0\n                break\n        sum_of_n_and_l += 1\n    # Get maximal n and l\n    period = 0\n    for orbital in orbital_configuration:\n        if orbital[0] &gt; period:\n            period = orbital[0]\n    # If transition metal, we add 9, Sc has group 9 for else, we do not consider ...\n    last_orbital = orbital_configuration[-1]\n    if last_orbital[1] &lt; 2:\n        group = 2 * last_orbital[1] ** 2 + last_orbital[2]\n    else:\n        group = 8 + last_orbital[2]\n    return period, group\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.get_radius","title":"get_radius","text":"<pre><code>get_radius()\n</code></pre> <p>Returns a radius information of a given atom. Reference is given here: Dalton Trans., 2008, 2832-2838</p> <p>:param:</p> <p>:return float:     It directly returns the reference values</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_radius(self):\n    \"\"\"\n    Returns a radius information of a given atom. Reference is given here: Dalton Trans., 2008, 2832-2838\n\n    :param:\n\n    :return float:\n        It directly returns the reference values\n    \"\"\"\n    element = self.get_element()\n    a = str.lower(element)\n    # reference : Dalton Trans., 2008, 2832-2838\n    if a == \"h\":\n        return 0.31\n    elif a == \"li\":\n        return 1.28\n    elif a == \"be\":\n        return 0.96\n    elif a == \"b\":\n        return 0.84\n    elif a == \"c\":\n        return 0.76\n    elif a == \"n\":\n        return 0.71\n    elif a == \"o\":\n        return 0.66\n    elif a == \"f\":\n        return 0.57\n    elif a == \"na\":\n        return 1.66\n    elif a == \"mg\":\n        return 1.41\n    elif a == \"al\":\n        return 1.21\n    elif a == \"si\":\n        return 1.11\n    elif a == \"p\":\n        return 1.07\n    elif a == \"s\":\n        return 1.05\n    elif a == \"cl\":\n        return 1.02\n    elif a == \"ar\":\n        return 0.76\n    elif a == \"k\":\n        return 2.03\n    elif a == \"ca\":\n        return 1.76\n    elif a == \"co\":\n        return 1.38  # 1/2*(lowspin+highspin)\n    # elif a=='co': return 1.26 #lowspin\n    # elif a=='co': return 1.50 #highspin\n    elif a == \"fe\":\n        return 1.42  # 1/2*(lowspin+highspin)\n    elif a == \"ni\":\n        return 1.24\n    # elif a=='cr': return 1.39\n    elif a == \"ti\":\n        return 1.60\n    elif a == \"br\":\n        return 1.20\n    elif a == \"rh\":\n        return 1.42\n    elif a == \"pd\" or a == \"i\":\n        return 1.39\n    elif a == \"hf\":\n        return 1.75\n    else:\n        return 0\n\n    # reference : J. Chem. Phys. 41, 3199 (1964)\n    \"\"\"\n    if a=='h': return 0.25\n    elif a=='li': return 1.45\n    elif a=='be': return 1.05\n    elif a=='b': return 0.85\n    elif a=='c': return 0.70\n    elif a=='n': return 0.65\n    elif a=='o': return 0.60\n    elif a=='f': return 0.50\n    elif a=='na': return 1.80\n    elif a=='mg': return 1.50\n    elif a=='al': return 1.25\n    elif a=='si': return 1.10\n    elif a=='p': return 1.00\n    elif a=='s': return 1.00\n    elif a=='cl': return 1.00\n    elif a=='ar': return 0.71\n    elif a=='k': return 2.20\n    elif a=='ca': return 1.80\n    elif a=='co': return 1.35\n    else: return 0\n    \"\"\"\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.is_same_atom","title":"is_same_atom","text":"<pre><code>is_same_atom(atom)\n</code></pre> <p>Returns whether the two atoms have same type by comparing atomic number</p> <p>:param atom(pyclass 'Atom'):     Our defined class 'Atom'</p> <p>:return:     True: Two atoms are same type     False: Two atoms are different type</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def is_same_atom(self, atom):\n    \"\"\"\n    Returns whether the two atoms have same type by comparing atomic number\n\n    :param atom(pyclass 'Atom'):\n        Our defined class 'Atom'\n\n    :return:\n        True: Two atoms are same type\n        False: Two atoms are different type\n    \"\"\"\n    atomic_number = self.get_atomic_number()\n    atomic_number_prime = atom.get_atomic_number()\n    return atomic_number == atomic_number_prime\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.set_atomic_number","title":"set_atomic_number","text":"<pre><code>set_atomic_number(atomic_number)\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def set_atomic_number(self, atomic_number):\n    self.atomic_number = atomic_number\n    self.element = periodic_table[atomic_number - 1]\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.set_coordinate","title":"set_coordinate","text":"<pre><code>set_coordinate(position)\n</code></pre> <p>Set Cartesian coordinates of an atom</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def set_coordinate(self, position):\n    \"\"\"Set Cartesian coordinates of an atom\"\"\"\n    dim = len(position)\n    if dim == 2:\n        x = position[0]\n        y = position[1]\n        z = 0\n    elif dim == 3:\n        x = position[0]\n        y = position[1]\n        z = position[2]\n    self.x = x\n    self.y = y\n    self.z = z\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Atom.set_element","title":"set_element","text":"<pre><code>set_element(element)\n</code></pre> <p>Type of an atom. e.g. 'C', 'H', 'O', and so on.</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def set_element(self, element):\n    \"\"\"Type of an atom. e.g. 'C', 'H', 'O', and so on.\"\"\"\n    self.element = element\n    self.atomic_number = periodic_table.index(element) + 1\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule","title":"Molecule","text":"<pre><code>Molecule(data=None)\n</code></pre> <p>:class Molecule:     class Molecule mainly contains atom_list, atom_feature, chg, bo_matrix, adj_matrix, energy, smiles, c_eig_list     atom_list is a list of atom (pyclass 'Atom')     atom_feature is a dict, where features of atom such as formal charge, number of pi bonds, etc, are stored.     Those information can be freely added by giving new dict     c_eig_list can be used to identify whether the given two molecules are the same. This c_eig_list is invariant     to the permutation of atom indexing, identification between any two generated molecules can be easily checked.</p> <p>:param data(str or xyz file or None):     data should be feeded as either smiles(str), xyz file(file) or None     * If smiles is used, rd_mol is generated using the given smiles and converted into ace_mol (pyclass 'Molecule)     * If xyz file is used, directly the 3d geometry of the given molecule is generated. If you want to generate adj_matrix,     bo_matrix, chg_list, etc, refer following method contained in pyclass 'Molecule' (charge of molecule should be given!!!)     i. Generate adj_matrix by using 'get_adj_matrix_from_distance' stored in class 'Molecule'     ii. Generate bo_matrix by using 'get_adj_matrix_from_adj_matrix' stored in class 'Molecule'     iii. Then, using those bo_matrix, get chg_list by using 'get_chg_list_from_bo_matrix' stored n class 'Molecule'     * If None is used, only blank virtual molecule is generated</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def __init__(self, data=None):\n    self.atom_list = []\n    self.atom_feature = dict()\n    self.adj_matrix = None\n    self.bo_matrix = None\n    self.chg = None\n    self.energy = None\n    self.smiles = None\n    self.multiplicity = None\n\n    if data == None:\n        pass\n\n    elif (type(data) == str) and (data[-4:] == \".xyz\"):\n        # data is already opened file\n        f = open(data)\n        atom_list = []\n        try:\n            atom_num = int(f.readline())\n        except:\n            print(\"Wrong format! Should start with number of atoms!\")\n        try:\n            energy = float(f.readline())\n            self.energy = energy\n        except:\n            self.energy = None\n        for i in range(atom_num):\n            try:\n                content = f.readline().strip()\n                atom_line = content.split()\n                # atomic_number = int(atom_line[0])\n                element_symbol = atom_line[0]\n                x = float(atom_line[1])\n                y = float(atom_line[2])\n                z = float(atom_line[3])\n                new_atom = Atom(element_symbol)\n                new_atom.x = x\n                new_atom.y = y\n                new_atom.z = z\n                atom_list.append(new_atom)\n            except:\n                print(\"Error found in:\", content)\n                print(\"Check the file again:\", data)\n        self.atom_list = atom_list\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.adj_matrix","title":"adj_matrix  <code>instance-attribute</code>","text":"<pre><code>adj_matrix = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.atom_feature","title":"atom_feature  <code>instance-attribute</code>","text":"<pre><code>atom_feature = dict()\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.atom_list","title":"atom_list  <code>instance-attribute</code>","text":"<pre><code>atom_list = []\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.bo_matrix","title":"bo_matrix  <code>instance-attribute</code>","text":"<pre><code>bo_matrix = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.chg","title":"chg  <code>instance-attribute</code>","text":"<pre><code>chg = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy = energy\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.multiplicity","title":"multiplicity  <code>instance-attribute</code>","text":"<pre><code>multiplicity = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.smiles","title":"smiles  <code>instance-attribute</code>","text":"<pre><code>smiles = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def copy(self):\n    new_molecule = Molecule()\n    atom_list = self.atom_list\n    # First copy atoms\n    new_atom_list = []\n    for atom in atom_list:\n        new_atom_list.append(atom.copy())\n    new_molecule.atom_list = new_atom_list\n    # Copy connectivity information\n    bo_matrix = self.get_bo_matrix()\n    if bo_matrix is not None:\n        new_molecule.bo_matrix = np.copy(bo_matrix)\n    else:\n        adj_matrix = self.get_adj_matrix()\n        if adj_matrix is not None:\n            new_molecule.adj_matrix = np.copy(adj_matrix)\n        else:\n            print(\n                \"Warning: Connectivity information is not included in the molecule!!!\"\n            )\n    return new_molecule\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_adj_matrix","title":"get_adj_matrix","text":"<pre><code>get_adj_matrix()\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_adj_matrix(self):\n    if self.adj_matrix is not None:\n        return self.adj_matrix\n    if self.bo_matrix is not None:\n        adj_matrix = np.where(self.bo_matrix &gt; 0, 1, 0)\n        return adj_matrix\n    return None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_angle_between_atoms","title":"get_angle_between_atoms","text":"<pre><code>get_angle_between_atoms(idx1, idx2, idx3, unit='rad')\n</code></pre> <p>Returns the distance between chosen two atoms</p> <p>:param idx1,idx2(int):     indices of chosen two atoms.</p> <p>:return distance(float):     Distance between selected two atoms</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_angle_between_atoms(self, idx1, idx2, idx3, unit=\"rad\"):\n    \"\"\"\n    Returns the distance between chosen two atoms\n\n    :param idx1,idx2(int):\n        indices of chosen two atoms.\n\n    :return distance(float):\n        Distance between selected two atoms\n\n    \"\"\"\n    coordinate_list = self.get_coordinate_list()\n    angle = ic.get_angle(coordinate_list, idx1, idx2, idx3)\n    if unit == \"degree\":\n        angle *= 180 / np.pi\n    return angle\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_bo_matrix","title":"get_bo_matrix","text":"<pre><code>get_bo_matrix()\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_bo_matrix(self):\n    return self.bo_matrix\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_bond_list","title":"get_bond_list","text":"<pre><code>get_bond_list(contain_bond_order=True)\n</code></pre> <p>Returns the total bond list as list of tuples For example, if CH4 is given with atom order [C,H,H,H,H], if contain_bond_order = False, the output is given as [(0,1),(0,2),(0,3),(0,4)] if contain_bond_order = True, the output is given as [(0,1,1),(0,2,1),(0,3,1),(0,4,1)]</p> <p>:param contain_bond_order(boolean):     If contain_bond_order is False, it only returns bonds represented as (i,j) between atoms within the given intermediate.     If contain_bond_order is True, it returns bonds with bond order included (i,j,bond_order), where bond_order can only have 1,2,3.     Therefore, a given molecule(self) should be kekulized.</p> <p>:return bond_list(either list of tuple with size 2 or 3):     bond_list</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_bond_list(self, contain_bond_order=True):\n    \"\"\"\n    Returns the total bond list as list of tuples\n    For example, if CH4 is given with atom order [C,H,H,H,H], if contain_bond_order = False, the output is given as\n    [(0,1),(0,2),(0,3),(0,4)]\n    if contain_bond_order = True, the output is given as\n    [(0,1,1),(0,2,1),(0,3,1),(0,4,1)]\n\n    :param contain_bond_order(boolean):\n        If contain_bond_order is False, it only returns bonds represented as (i,j) between atoms within the given intermediate.\n        If contain_bond_order is True, it returns bonds with bond order included (i,j,bond_order), where bond_order can only have 1,2,3.\n        Therefore, a given molecule(self) should be kekulized.\n\n    :return bond_list(either list of tuple with size 2 or 3):\n        bond_list\n    \"\"\"\n    atom_list = self.atom_list\n    n = len(atom_list)\n    check_matrix = self.bo_matrix\n    total_bond_list = []\n    if contain_bond_order:\n        check_matrix = self.get_bo_matrix()\n        if check_matrix is None:\n            print(\"we cannot give bond order!!!\")\n            print(\"We will automatically give only bond list!\")\n            contain_bond_order = False\n            check_matrix = self.get_adj_matrix()\n            if check_matrix is None:\n                print(\"matrix\", self.atom_list)\n                print(\"hahahahahaha\", check_matrix)\n                print(\"Give connectivity! We cannot find the bond!\")\n                return None\n    if contain_bond_order:\n        bond_type = [1, 2, 3]\n        check_matrix = self.get_bo_matrix()\n    else:\n        bond_type = [1]\n        check_matrix = self.get_adj_matrix()\n    # check_matrix = self.adj_matrix\n    for bond_order in bond_type:\n        bond_list = np.where(check_matrix == bond_order)\n        bond_list = np.stack(bond_list, axis=1)\n        for array in bond_list:\n            if array[0] &lt; array[1]:\n                if contain_bond_order:\n                    bond_tuple = (int(array[0]), int(array[1]), int(bond_order))\n                else:\n                    bond_tuple = (int(array[0]), int(array[1]))\n                total_bond_list.append(bond_tuple)\n    return total_bond_list\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_chg","title":"get_chg","text":"<pre><code>get_chg()\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_chg(self):\n    if self.chg is None:\n        chg_list = self.get_chg_list()\n        if chg_list is None:\n            return None\n        else:\n            return np.sum(chg_list)\n    else:\n        return self.chg\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_chg_list","title":"get_chg_list","text":"<pre><code>get_chg_list()\n</code></pre> <p>Returns chg list of a given molecule</p> <p>:param:</p> <p>:return chg_list(pyclass 'numpy.ndarray'):     list of formal charge</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_chg_list(self):\n    \"\"\"\n    Returns chg list of a given molecule\n\n    :param:\n\n    :return chg_list(pyclass 'numpy.ndarray'):\n        list of formal charge\n    \"\"\"\n    atom_feature = self.atom_feature\n    try:\n        return atom_feature[\"chg\"]\n    except:\n        print(\"charge lists are not prepared!!!\")\n        return None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_coordinate_list","title":"get_coordinate_list","text":"<pre><code>get_coordinate_list()\n</code></pre> <p>Returns 3d coordinate of a given molecule</p> <p>:param:</p> <p>:return coordinate_list(list(size n) of tuple of float(size 3)):</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_coordinate_list(self):\n    \"\"\"\n    Returns 3d coordinate of a given molecule\n\n    :param:\n\n    :return coordinate_list(list(size n) of tuple of float(size 3)):\n\n    \"\"\"\n    atom_list = self.atom_list\n    if \"coords\" in self.atom_feature:\n        return self.atom_feature[\"coords\"]\n    coordinate_list = [[atom.x, atom.y, atom.z] for atom in atom_list]\n    return np.array(coordinate_list)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_dihedral_angle_between_atoms","title":"get_dihedral_angle_between_atoms","text":"<pre><code>get_dihedral_angle_between_atoms(idx1, idx2, idx3, idx4, unit='rad')\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_dihedral_angle_between_atoms(self, idx1, idx2, idx3, idx4, unit=\"rad\"):\n    coordinate_list = self.get_coordinate_list()\n    angle = ic.get_dihedral_angle(coordinate_list, idx1, idx2, idx3, idx4)\n    if unit == \"degree\":\n        angle *= 180 / np.pi\n    return angle\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_distance_between_atoms","title":"get_distance_between_atoms","text":"<pre><code>get_distance_between_atoms(idx1, idx2)\n</code></pre> <p>Returns the distance between chosen two atoms</p> <p>:param idx1,idx2(int):     indices of chosen two atoms.</p> <p>:return distance(float):     Distance between selected two atoms</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_distance_between_atoms(self, idx1, idx2):\n    \"\"\"\n    Returns the distance between chosen two atoms\n\n    :param idx1,idx2(int):\n        indices of chosen two atoms.\n\n    :return distance(float):\n        Distance between selected two atoms\n\n    \"\"\"\n    coordinate_list = self.get_coordinate_list()\n    return ic.get_distance(coordinate_list, idx1, idx2)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_element_list","title":"get_element_list","text":"<pre><code>get_element_list()\n</code></pre> <p>Returns element list of a given molecule</p> <p>:param:</p> <p>:return element_list(list of string):     list of element written as capital letters</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_element_list(self):\n    \"\"\"\n    Returns element list of a given molecule\n\n    :param:\n\n    :return element_list(list of string):\n        list of element written as capital letters\n    \"\"\"\n    atom_feature = self.atom_feature\n    if atom_feature is not None and \"element\" in atom_feature:\n        return atom_feature[\"element\"]\n    else:\n        element_list = list(map(lambda x: x.get_element(), self.atom_list))\n        return element_list\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_internal_coordinate","title":"get_internal_coordinate","text":"<pre><code>get_internal_coordinate(indices, unit='degree')\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_internal_coordinate(self, indices, unit=\"degree\"):\n    if len(indices) == 2:\n        idx1, idx2 = indices\n        return self.get_distance_between_atoms(idx1, idx2)\n    elif len(indices) == 3:\n        idx1, idx2, idx3 = indices\n        return self.get_angle_between_atoms(idx1, idx2, idx3, unit)\n    elif len(indices) == 4:\n        idx1, idx2, idx3, idx4 = indices\n        return self.get_dihedral_angle_between_atoms(idx1, idx2, idx3, idx4, unit)\n    else:\n        print(f\"Wrong coordinate (={indices}) given!\")\n        return None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_minimal_data","title":"get_minimal_data","text":"<pre><code>get_minimal_data()\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_minimal_data(self):\n    data = dict()\n    data[\"z\"] = self.get_z_list()\n    data[\"adj\"] = self.get_adj_matrix()\n    data[\"bo\"] = self.get_bo_matrix()\n    data[\"chg\"] = self.get_chg()\n    data[\"atom chg\"] = self.get_chg_list()\n    data[\"coords\"] = self.get_coordinate_list()\n    return data\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_multiplicity","title":"get_multiplicity","text":"<pre><code>get_multiplicity()\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_multiplicity(self):\n    try:\n        e_list = self.get_num_of_lone_pair_list()\n        num_of_unpaired_e = len(np.where((2 * e_list) % 2 == 1)[0])\n        multiplicity = num_of_unpaired_e + 1\n        return multiplicity\n    except:\n        return None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_normal_vector","title":"get_normal_vector","text":"<pre><code>get_normal_vector(idx1, idx2, idx3)\n</code></pre> <p>For given three atom indices, it returns normal vector that is perpendicular to the plane generated by three indices</p> <p>:param idx1,idx2,idx3(int):     Indices for selected three atoms</p> <p>:return normal_vector(pyclass 'numpy.ndarray' with length 3)     normal vector</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_normal_vector(self, idx1, idx2, idx3):\n    \"\"\"\n    For given three atom indices, it returns normal vector that is perpendicular to\n    the plane generated by three indices\n\n    :param idx1,idx2,idx3(int):\n        Indices for selected three atoms\n\n    :return normal_vector(pyclass 'numpy.ndarray' with length 3)\n        normal vector\n    \"\"\"\n    vector1 = self.get_vector_between_atoms(idx3, idx1)\n    vector2 = self.get_vector_between_atoms(idx3, idx2)\n    cross_vector = np.cross(vector1, vector2)\n    norm = np.linalg.norm(cross_vector)\n    if norm == 0:\n        return cross_vector\n    else:\n        return cross_vector / norm\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_radius_list","title":"get_radius_list","text":"<pre><code>get_radius_list()\n</code></pre> <p>Returns radius list of a given molecule Ex. For CH4 with atom order [C,H,H,H,H], then radius_list is given as [0.8,0.5,0.5,0.5,0.5], if radius of C and H are given as 0.8 and 0.5 (unit is Angstrom)</p> <p>:param:</p> <p>:return radius_list(list of float):     list of radius of each atom</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_radius_list(self):\n    \"\"\"\n    Returns radius list of a given molecule\n    Ex. For CH4 with atom order [C,H,H,H,H], then radius_list is given as\n    [0.8,0.5,0.5,0.5,0.5], if radius of C and H are given as 0.8 and 0.5 (unit is Angstrom)\n\n    :param:\n\n    :return radius_list(list of float):\n        list of radius of each atom\n    \"\"\"\n    atom_list = self.atom_list\n    atom_feature = self.atom_feature\n    if \"radius\" in atom_feature:\n        return atom_feature[\"radius\"]\n    radius_list = []\n    for atom in atom_list:\n        radius_list.append(atom.get_radius())\n    return radius_list\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_vector_between_atoms","title":"get_vector_between_atoms","text":"<pre><code>get_vector_between_atoms(idx1, idx2, normalize=True)\n</code></pre> <p>For given two atom indices, it returns difference vector between two atoms. This function can be used to move or rotate a given molecule</p> <p>:param idx1,idx2(int):     Indices for selected two atoms</p> <p>:return difference_vector(pyclass 'numpy.ndarray' with length 3)</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_vector_between_atoms(self, idx1, idx2, normalize=True):\n    \"\"\"\n    For given two atom indices, it returns difference vector between two atoms. This function can be used to\n    move or rotate a given molecule\n\n    :param idx1,idx2(int):\n        Indices for selected two atoms\n\n    :return difference_vector(pyclass 'numpy.ndarray' with length 3)\n\n    \"\"\"\n    atom_list = self.atom_list\n    atom_coord1 = atom_list[idx1].get_coordinate()\n    atom_coord2 = atom_list[idx2].get_coordinate()\n    vector = atom_coord2 - atom_coord1\n    if normalize:\n        norm = np.linalg.norm(vector)\n        if norm &lt; 0.0001:\n            print(\"zero vector is found ...\")\n            return vector\n        else:\n            # print ('finalvector',vector,vector/norm)\n            return vector / norm\n    return vector\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.get_z_list","title":"get_z_list","text":"<pre><code>get_z_list()\n</code></pre> <p>Returns atomic number list of a given molecule</p> <p>:param:</p> <p>:return z_list(pyclass 'numpy.ndarray'):     list of atomic number</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def get_z_list(self):\n    \"\"\"\n    Returns atomic number list of a given molecule\n\n    :param:\n\n    :return z_list(pyclass 'numpy.ndarray'):\n        list of atomic number\n    \"\"\"\n    atom_feature = self.atom_feature\n    if atom_feature is not None and \"atomic number\" in atom_feature:\n        return atom_feature[\"atomic number\"]\n    else:\n        z_list = list(map(lambda x: x.get_atomic_number(), self.atom_list))\n        return np.array(z_list)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.print_coordinate_list","title":"print_coordinate_list","text":"<pre><code>print_coordinate_list(option='element')\n</code></pre> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def print_coordinate_list(self, option=\"element\"):\n    coordinate_list = self.get_coordinate_list()\n    atom_list = self.atom_list\n    n = len(atom_list)\n    for i in range(n):\n        coordinate = coordinate_list[i]\n        element = atom_list[i].get_element()\n        if option == \"number\":\n            element = atom_list[i].get_atomic_number()\n        print_x = coordinate[0]\n        print_y = coordinate[1]\n        print_z = coordinate[2]\n        if abs(print_x) &lt; 0.0001:\n            print_x = 0.00\n        if abs(print_y) &lt; 0.0001:\n            print_y = 0.00\n        if abs(print_z) &lt; 0.0001:\n            print_z = 0.00\n        print(element, print_x, print_y, print_z)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/chem.html#himatcal.utils.mcd.chem.Molecule.write_geometry","title":"write_geometry","text":"<pre><code>write_geometry(file_directory, option='element', criteria=0.0001)\n</code></pre> <p>Writes xyz file that contains the 3d molecular geometry</p> <p>:param file_directory(str):     Directory for saving 3d geometry xyz file</p> <p>:return:</p> Source code in <code>himatcal/utils/mcd/chem.py</code> <pre><code>def write_geometry(self, file_directory, option=\"element\", criteria=1e-4):\n    \"\"\"\n    Writes xyz file that contains the 3d molecular geometry\n\n    :param file_directory(str):\n        Directory for saving 3d geometry xyz file\n\n    :return:\n\n    \"\"\"\n    atom_list = self.atom_list\n    n = len(atom_list)\n    with open(file_directory, \"w\") as f:\n        content = str(n) + \"\\n\"\n        if self.energy is not None:\n            content = content + str(self.energy) + \"\\n\"\n        else:\n            content = content + \"\\n\"\n        f.write(content)\n        for atom in atom_list:\n            f.write(atom.get_content(option, criteria))\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html","title":"ic","text":""},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.coordinate_list","title":"coordinate_list  <code>module-attribute</code>","text":"<pre><code>coordinate_list = get_coordinate_list()\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.delta_qs","title":"delta_qs  <code>module-attribute</code>","text":"<pre><code>delta_qs = dict()\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.internal_coordinate","title":"internal_coordinate  <code>module-attribute</code>","text":"<pre><code>internal_coordinate = (0, 1, 2)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.internal_coordinates","title":"internal_coordinates  <code>module-attribute</code>","text":"<pre><code>internal_coordinates = list(keys())\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.matrix","title":"matrix  <code>module-attribute</code>","text":"<pre><code>matrix = get_wilsonB_derivative_matrix(coordinate_list, internal_coordinates)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.molecule","title":"molecule  <code>module-attribute</code>","text":"<pre><code>molecule = Molecule('R.xyz')\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.arccos","title":"arccos","text":"<pre><code>arccos(x)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def arccos(x):\n    return np.arccos(x)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.cos","title":"cos","text":"<pre><code>cos(x)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def cos(x):\n    return np.cos(x)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_angle","title":"get_angle","text":"<pre><code>get_angle(xyz_coordinates, idx1, idx2, idx3)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_angle(xyz_coordinates, idx1, idx2, idx3):\n    # Formula: theta = cos-1(u.v/|u||v|)\n    v_21 = get_vector(xyz_coordinates, idx2, idx1, True)\n    v_23 = get_vector(xyz_coordinates, idx2, idx3, True)\n    return get_vector_angle(v_21, v_23)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_cross_vector","title":"get_cross_vector","text":"<pre><code>get_cross_vector(v1, v2, normalize=False)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_cross_vector(v1, v2, normalize=False):\n    v = np.cross(v1, v2)\n    if normalize:\n        d = np.linalg.norm(v)\n        v /= d\n    return v\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_dihedral_angle","title":"get_dihedral_angle","text":"<pre><code>get_dihedral_angle(xyz_coordinates, idx1, idx2, idx3, idx4)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_dihedral_angle(xyz_coordinates, idx1, idx2, idx3, idx4):\n    # Formula: theta = cos-1((uxw)_n.(vxw)_n], (uxw)_n: normalized cross vector\n    v_12 = get_vector(xyz_coordinates, idx1, idx2, True)  # u\n    v_23 = get_vector(xyz_coordinates, idx2, idx3, True)  # w\n    v_34 = get_vector(xyz_coordinates, idx3, idx4, True)  # v\n    w1 = get_cross_vector(v_12, v_23, True)\n    w2 = get_cross_vector(v_23, v_34, True)\n    return get_vector_angle(w1, w2)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_distance","title":"get_distance","text":"<pre><code>get_distance(xyz_coordinates, idx1, idx2)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_distance(xyz_coordinates, idx1, idx2):\n    v = get_vector(xyz_coordinates, idx1, idx2)\n    return np.linalg.norm(v)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_gradient_q","title":"get_gradient_q","text":"<pre><code>get_gradient_q(g_x, xyz_coordinates, internal_coordinates)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_gradient_q(g_x, xyz_coordinates, internal_coordinates):\n    B = get_wilsonB_matrix(xyz_coordinates, internal_coordinates)  # M x 3N, B.T: 3N x M\n    BT_inverse = np.linalg.pinv(B.T)\n    return BT_inverse @ g_x  # M x 1\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_hessian_q","title":"get_hessian_q","text":"<pre><code>get_hessian_q(g_x, h_x, xyz_coordinates, internal_coordinates)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_hessian_q(g_x, h_x, xyz_coordinates, internal_coordinates):\n    # print ('bf',internal_coordinates)\n    B = get_wilsonB_matrix(xyz_coordinates, internal_coordinates)  # M x 3N\n    # print ('af',internal_coordinates)\n    B_prime = get_wilsonB_derivative_matrix(\n        xyz_coordinates, internal_coordinates\n    )  # M x 3N x 3N\n    BT_inverse = np.linalg.pinv(B.T)\n    B_inverse = np.linalg.pinv(B)\n    g_q = BT_inverse @ g_x  # M x 1\n    # print (g_q.shape,B_prime.shape)\n    K = np.squeeze(\n        np.einsum(\"il,ijk-&gt;ljk\", g_q, B_prime), axis=0\n    )  # M x 1, M x 3N x 3N -&gt; 1 x 3N x 3N (einsum) -&gt; 3N x 3N (squeeze)\n    # print (K.shape)\n    # print (h_x.shape)\n    # print ('K',np.sum(np.abs(K)))\n    h_q = BT_inverse @ (h_x - K) @ B_inverse\n    # print (h_q.shape)\n    return h_q\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_internal_coordinate_info","title":"get_internal_coordinate_info","text":"<pre><code>get_internal_coordinate_info(coordinate_list, internal_coordinates)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_internal_coordinate_info(coordinate_list, internal_coordinates):\n    infos = dict()\n    q = get_q(coordinate_list, internal_coordinates)\n    for idx, internal_coordinate in enumerate(internal_coordinates):\n        infos[internal_coordinate] = q[idx]\n    return infos\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_q","title":"get_q","text":"<pre><code>get_q(xyz_coordinates, internal_coordinates)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_q(xyz_coordinates, internal_coordinates):\n    q = []\n    for internal_coordinate in internal_coordinates:\n        q.append(get_single_q_element(xyz_coordinates, internal_coordinate))\n    return np.array(q).T\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_single_q_element","title":"get_single_q_element","text":"<pre><code>get_single_q_element(xyz_coordinates, internal_coordinate)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_single_q_element(xyz_coordinates, internal_coordinate):\n    if len(internal_coordinate) == 2:\n        idx1, idx2 = internal_coordinate\n        return get_distance(xyz_coordinates, idx2, idx1)\n    elif len(internal_coordinate) == 3:\n        idx1, idx2, idx3 = internal_coordinate\n        return get_angle(xyz_coordinates, idx1, idx2, idx3)\n    else:\n        idx1, idx2, idx3, idx4 = internal_coordinate\n        return get_dihedral_angle(xyz_coordinates, idx1, idx2, idx3, idx4)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_vector","title":"get_vector","text":"<pre><code>get_vector(xyz_coordinates, idx1, idx2, normalize=False)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_vector(xyz_coordinates, idx1, idx2, normalize=False):\n    start = xyz_coordinates[idx1]\n    end = xyz_coordinates[idx2]\n    v = start - end\n    if normalize:\n        d = np.linalg.norm(v)\n        v /= d\n    return v\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_vector_angle","title":"get_vector_angle","text":"<pre><code>get_vector_angle(v1, v2)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_vector_angle(v1, v2):\n    return np.arccos(np.dot(v1, v2))\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_wilsonB_derivative_matrix","title":"get_wilsonB_derivative_matrix","text":"<pre><code>get_wilsonB_derivative_matrix(xyz_coordinates, internal_coordinates)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_wilsonB_derivative_matrix(xyz_coordinates, internal_coordinates):\n    n = len(xyz_coordinates)\n    m = len(internal_coordinates)\n    B_derivative_matrix = np.zeros((m, 3 * n, 3 * n))\n    for row_idx, internal_coordinate in enumerate(internal_coordinates):\n        tensor, scanning_indices = get_wilsonB_derivative_sub_matrix(\n            xyz_coordinates, internal_coordinate\n        )  # tensor: m x m x 3 x 3\n        for indices in scanning_indices:\n            x, y = indices\n            a = internal_coordinate[x]\n            b = internal_coordinate[y]\n            B_derivative_matrix[row_idx, 3 * a : 3 * a + 3, 3 * b : 3 * b + 3] = tensor[\n                x, y, :, :\n            ]\n    return B_derivative_matrix\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_wilsonB_derivative_sub_matrix","title":"get_wilsonB_derivative_sub_matrix","text":"<pre><code>get_wilsonB_derivative_sub_matrix(xyz_coordinates, internal_coordinate)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_wilsonB_derivative_sub_matrix(xyz_coordinates, internal_coordinate):\n    m = len(internal_coordinate)\n    indices = list(range(m))\n    scanning_indices = list(itertools.product(indices, indices))\n    tensor = np.zeros((m, m, 3, 3))\n    if m == 2:\n        a, b = internal_coordinate\n        u = get_vector(xyz_coordinates, a, b, False)\n        l_u = np.linalg.norm(u)\n        u /= l_u  # Normalized u\n        # m: a, n: b\n        for indices in list(scanning_indices):\n            x, y = indices\n            idx1 = internal_coordinate[x]\n            idx2 = internal_coordinate[y]\n            # a: idx1, b: idx2\n            for i in range(3):\n                for j in range(3):\n                    u_i = u[i]\n                    u_j = u[j]\n                    tensor[x][y][i][j] = (\n                        (-1) ** kronecker_delta(idx1, idx2)\n                        * (u_i * u_j - kronecker_delta(i, j))\n                        / l_u\n                    )\n    if m == 3:\n        a, b, c = internal_coordinate\n        u = get_vector(xyz_coordinates, a, b, False)\n        l_u = np.linalg.norm(u)\n        u /= l_u  # Normalized u\n        v = get_vector(xyz_coordinates, c, b, False)\n        l_v = np.linalg.norm(v)\n        v /= l_v  # Normalized v\n        cos_q = np.sum(u * v)\n        sin_q = np.sqrt(1 - cos_q**2)\n        vector_dict = get_wilsonB_vector(xyz_coordinates, internal_coordinate)\n        # m: a, o: b, n: c\n        for indices in scanning_indices:\n            x, y = indices\n            idx1 = internal_coordinate[x]\n            idx2 = internal_coordinate[y]\n            # a: idx1, b: idx2\n            for i in range(3):\n                for j in range(3):\n                    u_i = u[i]\n                    u_j = u[j]\n                    v_i = v[j]\n                    v_j = u[j]\n                    first_term = (\n                        u_i * v_j\n                        + u_j * v_i\n                        - 3 * u_i * u_j * cos_q\n                        + kronecker_delta(i, j) * cos_q\n                    ) / (l_u**2 * sin_q)\n                    first_term *= sign_factor(idx1, a, b) * sign_factor(idx2, a, b)\n                    second_term = (\n                        v_i * u_j\n                        + v_j * u_i\n                        - 3 * v_i * v_j * cos_q\n                        + kronecker_delta(i, j) * cos_q\n                    ) / (l_v**2 * sin_q)\n                    second_term *= sign_factor(idx1, c, b) * sign_factor(idx2, c, b)\n                    third_term = (\n                        u_i * u_j\n                        + v_j * v_i\n                        - u_i * v_j * cos_q\n                        - kronecker_delta(i, j)\n                    ) / (l_u * l_v * sin_q)\n                    third_term *= sign_factor(idx1, a, b) * sign_factor(idx2, c, b)\n                    fourth_term = (\n                        v_i * v_j\n                        + u_j * u_i\n                        - v_i * u_j * cos_q\n                        - kronecker_delta(i, j)\n                    ) / (l_u * l_v * sin_q)\n                    fourth_term *= sign_factor(idx1, c, b) * sign_factor(idx2, a, b)\n                    fifth_term = (\n                        cos_q / sin_q * vector_dict[idx1][i] * vector_dict[idx2][j]\n                    )\n                    tensor[x][y][i][j] = (\n                        first_term + second_term + third_term + fourth_term - fifth_term\n                    )\n\n    elif m == 4:\n        a, b, c, d = internal_coordinate\n        u = get_vector(xyz_coordinates, a, b, False)\n        l_u = np.linalg.norm(u)\n        u /= l_u  # Normalized u\n        v = get_vector(xyz_coordinates, d, c, False)\n        l_v = np.linalg.norm(v)\n        v /= l_v  # Normalized v\n        w = get_vector(xyz_coordinates, c, b, False)\n        l_w = np.linalg.norm(w)\n        w /= l_w  # Normalized w\n        uw = get_cross_vector(u, w, False)\n        vw = get_cross_vector(v, w, False)\n        cos_phi_u = np.sum(u * w)\n        sin_phi_u = np.sqrt(1 - cos_phi_u**2)\n        cos_phi_v = np.sum(v * w)\n        sin_phi_v = np.sqrt(1 - cos_phi_v**2)\n        cos_q = np.sum(uw * vw) / (sin_phi_u * sin_phi_v)\n        # m: a, o: b, p: c, n: d\n        for indices in scanning_indices:\n            x, y = indices\n            idx1 = internal_coordinate[x]\n            idx2 = internal_coordinate[y]\n            # a: idx1, b: idx2\n            for i in range(3):\n                for j in range(3):\n                    u_i = u[i]\n                    u_j = u[j]\n                    v_i = v[j]\n                    v_j = u[j]\n                    w_i = w[i]\n                    w_j = w[j]\n                    first_term = (uw[i] * (cos_phi_u * w_j - u_j)) / (\n                        l_u**2 * sin_phi_u**4\n                    )\n                    first_term *= sign_factor(idx1, a, b) * sign_factor(idx2, a, b)\n                    second_term = (uw[j] * (cos_phi_u * w_i - u_i)) / (\n                        l_u**2 * sin_phi_u**4\n                    )\n                    second_term *= sign_factor(idx1, a, b) * sign_factor(idx2, a, b)\n                    third_term = (vw[i] * (w_j * cos_phi_v - v_j)) / (\n                        l_v**2 * sin_phi_v**4\n                    )\n                    third_term *= sign_factor(idx1, d, c) * sign_factor(idx2, d, c)\n                    fourth_term = (vw[j] * (w_i * cos_phi_v - v_i)) / (\n                        l_v**2 * sin_phi_v**4\n                    )\n                    fourth_term *= sign_factor(idx1, d, c) * sign_factor(idx2, d, c)\n                    fifth_term = (\n                        uw[i] * (w_j - 2 * u_j * cos_phi_u + w_j * cos_phi_u**2)\n                    ) / (2 * l_u * l_w * sin_phi_u**4)\n                    fifth_term *= sign_factor(idx1, a, b) * sign_factor(\n                        idx2, b, c\n                    ) + sign_factor(idx1, c, b) * sign_factor(idx2, b, a)\n                    sixth_term = (\n                        uw[j] * (w_i - 2 * u_i * cos_phi_u + w_i * cos_phi_u**2)\n                    ) / (2 * l_u * l_w * sin_phi_u**4)\n                    sixth_term *= sign_factor(idx1, a, b) * sign_factor(\n                        idx2, b, c\n                    ) + sign_factor(idx1, c, b) * sign_factor(idx2, b, a)\n                    seventh_term = (\n                        vw[i] * (w_j + 2 * u_j * cos_phi_v + w_j * cos_phi_v**2)\n                    ) / (2 * l_v * l_w * sin_phi_v**4)\n                    seventh_term *= sign_factor(idx1, d, c) * sign_factor(\n                        idx2, c, b\n                    ) + sign_factor(idx1, c, b) * sign_factor(idx2, d, c)\n                    eighth_term = (\n                        vw[j] * (w_i + 2 * u_i * cos_phi_v + w_i * cos_phi_v**2)\n                    ) / (2 * l_v * l_w * sin_phi_v**4)\n                    eighth_term *= sign_factor(idx1, d, c) * sign_factor(\n                        idx2, c, b\n                    ) + sign_factor(idx1, c, b) * sign_factor(idx2, d, c)\n                    ninth_term = (\n                        uw[i]\n                        * (\n                            u_j\n                            + u_j * cos_phi_u**2\n                            - 3 * w_j * cos_phi_u\n                            + w_j * cos_phi_u**3\n                        )\n                    ) / (2 * l_w**2 * sin_phi_u**4)\n                    ninth_term *= sign_factor(idx1, b, c) * sign_factor(idx2, c, b)\n                    tenth_term = (\n                        uw[j]\n                        * (\n                            u_i\n                            + u_i * cos_phi_u**2\n                            - 3 * w_i * cos_phi_u\n                            + w_i * cos_phi_u**3\n                        )\n                    ) / (2 * l_w**2 * sin_phi_u**4)\n                    tenth_term *= sign_factor(idx1, b, c) * sign_factor(idx2, c, b)\n                    eleventh_term = (\n                        vw[i]\n                        * (\n                            v_j\n                            + v_j * cos_phi_v**2\n                            + 3 * w_j * cos_phi_v\n                            - w_j * cos_phi_v**3\n                        )\n                    ) / (2 * l_w**2 * sin_phi_v**4)\n                    eleventh_term *= sign_factor(idx1, b, c) * sign_factor(idx2, b, c)\n                    twelvth_term = (\n                        vw[j]\n                        * (\n                            v_i\n                            + v_i * cos_phi_v**2\n                            + 3 * w_i * cos_phi_v\n                            - w_i * cos_phi_v**3\n                        )\n                    ) / (2 * l_w**2 * sin_phi_v**4)\n                    twelvth_term *= sign_factor(idx1, b, c) * sign_factor(idx2, b, c)\n                    if i != j:\n                        k = list(set([0, 1, 2]) - set([i, j]))[0]\n                        w_k = w[k]\n                        u_k = u[k]\n                        v_k = v[k]\n                        thirteenth_term = (\n                            (j - i)\n                            * (-1 / 2) ** (abs(i - j))\n                            * (w_k * cos_phi_u - u_k)\n                            / (l_u * l_w * sin_phi_u)\n                        )\n                        thirteenth_term *= (1 - kronecker_delta(idx1, idx2)) * (\n                            sign_factor(idx1, a, b) * sign_factor(idx2, b, c)\n                            + sign_factor(idx1, c, b) * sign_factor(idx2, b, a)\n                        )\n                        fourteenth_term = (\n                            (j - i)\n                            * (-1 / 2) ** (abs(i - j))\n                            * (w_k * cos_phi_v - v_k)\n                            / (l_v * -l_w * sin_phi_v)\n                        )\n                        fourteenth_term *= (1 - kronecker_delta(idx1, idx2)) * (\n                            sign_factor(idx1, d, b) * sign_factor(idx2, b, c)\n                            + sign_factor(idx1, c, b) * sign_factor(idx2, b, a)\n                        )\n                    else:\n                        thirteenth_term = 0\n                        fourteenth_term = 0\n                    tensor[x][y][i][j] = (\n                        first_term\n                        + second_term\n                        + third_term\n                        + fourth_term\n                        + fifth_term\n                        + sixth_term\n                        + seventh_term\n                        + eighth_term\n                        + ninth_term\n                        + tenth_term\n                        + eleventh_term\n                        + twelvth_term\n                        + thirteenth_term\n                        + fourteenth_term\n                    )\n\n    return tensor, scanning_indices\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_wilsonB_matrix","title":"get_wilsonB_matrix","text":"<pre><code>get_wilsonB_matrix(xyz_coordinates, internal_coordinates)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_wilsonB_matrix(xyz_coordinates, internal_coordinates):\n    # Reshape xyzs\n    n = len(xyz_coordinates)\n    m = len(internal_coordinates)\n    B_matrix = np.zeros((m, 3 * n))\n    for row_idx, internal_coordinate in enumerate(internal_coordinates):\n        vectors = get_wilsonB_vector(xyz_coordinates, internal_coordinate)\n        for index in vectors:\n            B_matrix[row_idx, 3 * index : 3 * index + 3] = vectors[index]\n    return B_matrix\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_wilsonB_vector","title":"get_wilsonB_vector","text":"<pre><code>get_wilsonB_vector(xyz_coordinates, internal_coordinate)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_wilsonB_vector(xyz_coordinates, internal_coordinate):\n    vector_dict = dict()\n    if len(internal_coordinate) == 2:\n        idx1, idx2 = internal_coordinate\n        u = get_vector(xyz_coordinates, idx1, idx2, True)\n        # a: idx1, m: idx1, n: idx2\n        vector_dict[idx2] = sign_factor(idx2, idx1, idx2) * u\n        vector_dict[idx1] = sign_factor(idx1, idx1, idx2) * u\n    elif len(internal_coordinate) == 3:\n        idx1, idx2, idx3 = internal_coordinate\n        u = get_vector(xyz_coordinates, idx1, idx2, False)\n        l_u = np.linalg.norm(u)\n        u /= l_u  # Normalized u\n        v = get_vector(xyz_coordinates, idx3, idx2, False)\n        l_v = np.linalg.norm(v)  # Normalized v\n        v /= l_v\n        w = get_cross_vector(u, v, True)  # Normalized w\n        uw = get_cross_vector(u, w, False)\n        wv = get_cross_vector(w, v, False)\n        # m: idx1, o: idx2, n: idx3\n        for idx in [idx1, idx2, idx3]:\n            vector_dict[idx] = (\n                sign_factor(idx, idx1, idx2) * uw / l_u\n                + sign_factor(idx, idx3, idx2) * wv / l_v\n            )\n    else:\n        idx1, idx2, idx3, idx4 = internal_coordinate\n        # m:idx1, o:idx2, p:idx3, n: idx4\n        u = get_vector(xyz_coordinates, idx1, idx2, False)\n        l_u = np.linalg.norm(u)\n        u /= l_u  # Normalized u\n        v = get_vector(xyz_coordinates, idx4, idx3, False)\n        l_v = np.linalg.norm(v)\n        v /= l_v  # Normalized v\n        w = get_vector(xyz_coordinates, idx3, idx2, False)\n        l_w = np.linalg.norm(w)\n        w /= l_w  # Normalized w\n        uw = get_cross_vector(u, w, False)\n        vw = get_cross_vector(v, w, False)\n        cos_phi_u = np.sum(u * w)\n        sin_phi_u = np.sqrt(1 - cos_phi_u**2)\n        cos_phi_v = np.sum(v * w)\n        sin_phi_v = np.sqrt(1 - cos_phi_v**2)\n        cos_q = np.sum(uw * vw) / (sin_phi_u * sin_phi_v)\n        for idx in [idx1, idx2, idx3, idx4]:\n            first_term = sign_factor(idx, idx1, idx2) * uw / (l_u * sin_phi_u**2)\n            second_term = sign_factor(idx, idx3, idx4) * vw / (l_v * sin_phi_v**2)\n            third_term = cos_phi_u * uw / (l_w * sin_phi_u**2) - cos_phi_v * vw / (\n                l_w * sin_phi_v**2\n            )\n            third_term *= sign_factor(idx, idx2, idx3)\n            vector_dict[idx] = first_term + second_term + third_term\n\n    return vector_dict\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.get_xyz_updates","title":"get_xyz_updates","text":"<pre><code>get_xyz_updates(xyz_coordinates, internal_coordinates, delta_q)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def get_xyz_updates(\n    xyz_coordinates, internal_coordinates, delta_q\n):  # Note that here, delta_qs[internal_coordinate] = delta_q\n    B = get_wilsonB_matrix(xyz_coordinates, internal_coordinates)\n    delta_x = solve_equation(B, delta_q)  # 3N x 1 -&gt; N x 3\n    n = len(xyz_coordinates)\n    delta_x = np.reshape(delta_x, (n, 3))\n    return delta_x\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.kronecker_delta","title":"kronecker_delta","text":"<pre><code>kronecker_delta(a, b)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def kronecker_delta(a, b):\n    if a == b:\n        return 1\n    else:\n        return 0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.sign_factor","title":"sign_factor","text":"<pre><code>sign_factor(a, b, c)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def sign_factor(a, b, c):\n    return kronecker_delta(a, b) - kronecker_delta(a, c)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.sin","title":"sin","text":"<pre><code>sin(x)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def sin(x):\n    return np.sin(x)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.solve_equation","title":"solve_equation","text":"<pre><code>solve_equation(B, delta_q)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def solve_equation(B, delta_q):\n    B_inverse = np.linalg.pinv(B)  # N x M\n    delta_x = B_inverse @ delta_q\n    return delta_x\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/ic.html#himatcal.utils.mcd.ic.update_geometry","title":"update_geometry","text":"<pre><code>update_geometry(xyz_coordinates, q_updates, criteria=1e-06, max_iteration=25)\n</code></pre> Source code in <code>himatcal/utils/mcd/ic.py</code> <pre><code>def update_geometry(xyz_coordinates, q_updates, criteria=1e-6, max_iteration=25):\n    internal_coordinates = list(q_updates.keys())\n    delta_q = np.array(list(q_updates.values())).T  # M x 1\n    q = get_q(xyz_coordinates, internal_coordinates)  # q_n or q_0\n    # print ('q: ',q)\n    # print ('internals: ',internal_coordinates)\n    target_q = q + delta_q  # q\n    original_coordinates = np.copy(xyz_coordinates)\n    for i in range(max_iteration):\n        delta_x = get_xyz_updates(xyz_coordinates, internal_coordinates, delta_q)\n        xyz_coordinates += delta_x\n        q = get_q(xyz_coordinates, internal_coordinates)\n        delta_q = target_q - q  # dq = q - q_n\n        x_norm = np.linalg.norm(delta_x)\n        if x_norm &lt; criteria:\n            # print (delta_q,q_updates,q)\n            break\n        elif i == max_iteration - 1:\n            print(\n                f\"Iteration did not converged! The final updated vector has norm: {x_norm}\"\n            )\n            for xyz in original_coordinates:\n                print(xyz)\n            print(\"update: \", q_updates)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html","title":"mcd","text":""},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD","title":"MCD","text":"<pre><code>MCD(num_relaxation=3, calculator=None)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def __init__(self, num_relaxation=3, calculator=None):\n    self.num_relaxation = num_relaxation\n    self.calculator = calculator\n    self.log_directory = \"\"\n    self.energy_unit = \"Hartree\"\n    self.num_force_calls = 0\n    self.num_hessian_calls = 0\n    self.step_size = 0.0\n    self.use_hessian = False\n    self.hessian_update = \"Bofill\"\n    self.num_filter_iteration = 10\n    self.previous_gradient = None\n    self.previous_hessian = None\n    self.previous_geometry = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.calculator","title":"calculator  <code>instance-attribute</code>","text":"<pre><code>calculator = calculator\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.energy_unit","title":"energy_unit  <code>instance-attribute</code>","text":"<pre><code>energy_unit = 'Hartree'\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.hessian_update","title":"hessian_update  <code>instance-attribute</code>","text":"<pre><code>hessian_update = 'Bofill'\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.log_directory","title":"log_directory  <code>instance-attribute</code>","text":"<pre><code>log_directory = ''\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.num_filter_iteration","title":"num_filter_iteration  <code>instance-attribute</code>","text":"<pre><code>num_filter_iteration = 10\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.num_force_calls","title":"num_force_calls  <code>instance-attribute</code>","text":"<pre><code>num_force_calls = 0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.num_hessian_calls","title":"num_hessian_calls  <code>instance-attribute</code>","text":"<pre><code>num_hessian_calls = 0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.num_relaxation","title":"num_relaxation  <code>instance-attribute</code>","text":"<pre><code>num_relaxation = num_relaxation\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.previous_geometry","title":"previous_geometry  <code>instance-attribute</code>","text":"<pre><code>previous_geometry = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.previous_gradient","title":"previous_gradient  <code>instance-attribute</code>","text":"<pre><code>previous_gradient = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.previous_hessian","title":"previous_hessian  <code>instance-attribute</code>","text":"<pre><code>previous_hessian = None\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.step_size","title":"step_size  <code>instance-attribute</code>","text":"<pre><code>step_size = 0.0\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.use_hessian","title":"use_hessian  <code>instance-attribute</code>","text":"<pre><code>use_hessian = False\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def __str__(self):\n    content = \"\"\n    content = content + f\"num relaxation: {self.num_relaxation}\\n\"\n    content = content + f\"step size: {self.step_size}\\n\"\n    # content = content + f'working_directory: {self.working_directory}\\n'\n    # content = content + f'qc inputs\\n\\n{self.content}\\n'\n    return content\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.change_energy_unit","title":"change_energy_unit","text":"<pre><code>change_energy_unit(energy_unit)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def change_energy_unit(self, energy_unit):\n    self.energy_unit = energy_unit\n    if self.calculator is not None:\n        self.calculator.energy_unit = energy_unit\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.change_working_directory","title":"change_working_directory","text":"<pre><code>change_working_directory(working_directory)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def change_working_directory(self, working_directory):\n    if self.calculator is not None:\n        self.calculator.change_working_directory(working_directory)\n    else:\n        print(\"Calculator does not exist!!! Define a calcualtor first!\")\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.find_solution","title":"find_solution","text":"<pre><code>find_solution(grad, hessian, update_size, delta_q, scanning_coordinates)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def find_solution(self, grad, hessian, update_size, delta_q, scanning_coordinates):\n    # grad: n x 1, hessian: n x n\n    # Make constraints\n    x0 = []  # Initial guess\n    lower_bounds = []\n    upper_bounds = []\n    jac = []\n    b = np.squeeze(grad)  # M x 1 -&gt; M\n    H = hessian\n    n = len(scanning_coordinates)\n    constant = 0\n    # Ao -&gt; Bohr\n    for constraint in scanning_coordinates:\n        delta = delta_q[constraint]\n        if delta &gt; 0:\n            # Upper bound\n            upper_bound = min(update_size, delta)\n            lower_bounds.append(0)\n            upper_bounds.append(upper_bound)\n            value = np.random.rand(1)[0]\n            constant += value\n            x0.append(value)\n            jac.append(1.0)\n        else:\n            # Lower bound\n            lower_bound = max(-update_size, delta)\n            lower_bounds.append(lower_bound)\n            upper_bounds.append(0)\n            value = np.random.rand(1)[0]\n            constant += value\n            x0.append(-value)\n            jac.append(-1.0)\n    jac = np.array(jac)\n    x0 = np.array(x0)\n    # print ('cons',constant)\n    x0 /= constant\n    x0 *= update_size\n    # print ('x0',x0)\n    constraints = [\n        {\n            \"type\": \"eq\",\n            \"fun\": lambda x: np.sum(x * jac) - update_size,\n            \"jac\": lambda x: jac,\n        }\n    ]\n    bounds = Bounds(lower_bounds, upper_bounds)\n    energy_function = lambda x: 1 / 2 * x.T @ H @ x + np.sum(x * b)\n    jac_energy_function = lambda x: x @ H + b\n    # hessian_energy_function = lambda x: H\n    res = minimize(\n        energy_function,\n        x0,\n        method=\"SLSQP\",\n        jac=jac_energy_function,\n        constraints=constraints,\n        bounds=bounds,\n    )\n    solution = dict()\n    # print ('energy increase: ',energy_function(res.x))\n    print(H, b, res.x)\n    print(\"Expected energy change:\", energy_function(res.x))\n\n    for i, constraint in enumerate(scanning_coordinates):\n        solution[constraint] = res.x[i]\n    return solution\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.get_corrected_indices","title":"get_corrected_indices","text":"<pre><code>get_corrected_indices(constraint)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def get_corrected_indices(\n    self, constraint\n):  # In general, we use index = 1 as starting point!\n    new_constraint = []\n    for idx in constraint:\n        new_constraint.append(idx + 1)\n    new_constraint = tuple(new_constraint)\n    return new_constraint\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.get_delta_q","title":"get_delta_q","text":"<pre><code>get_delta_q(coordinate_list, constraints)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def get_delta_q(self, coordinate_list, constraints):\n    delta_q = dict()\n    update_q = dict()\n    internal_coordinates = list(constraints.keys())\n    # May consider better reaction coordinate representation later!\n    for constraint in constraints:\n        delta_q[constraint] = constraints[constraint] - ic.get_single_q_element(\n            coordinate_list, constraint\n        )\n        update_q[constraint] = 0\n    return delta_q, update_q\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.get_gradient","title":"get_gradient","text":"<pre><code>get_gradient(molecule, chg=None, multiplicity=None)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def get_gradient(self, molecule, chg=None, multiplicity=None):\n    n = len(molecule.atom_list)\n    force = self.calculator.get_force(molecule, chg, multiplicity)\n    dV_dx = -np.reshape(force, (3 * n, 1))\n    self.num_force_calls += 1\n    return dV_dx\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.get_hessian","title":"get_hessian","text":"<pre><code>get_hessian(molecule, chg=None, multiplicity=None)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def get_hessian(self, molecule, chg=None, multiplicity=None):\n    n = len(molecule.atom_list)\n    if self.previous_hessian is None:\n        force, hessian = self.calculator.get_hessian(molecule, chg, multiplicity)\n        dV_dx = -np.reshape(force, (3 * n, 1))\n        self.num_hessian_calls += 1\n        return dV_dx, hessian\n    else:\n        hessian_update = str.lower(self.hessian_update)\n        if hessian_update == \"bofill\":\n            dV_dx = self.get_gradient(molecule, chg, multiplicity)\n            G_i = self.previous_hessian\n            dg_i = dV_dx - self.previous_gradient\n            x_i = np.reshape(molecule.get_coordinate_list(), (3 * n, 1))\n            x_i_1 = np.reshape(self.previous_geometry, (3 * n, 1))\n            dx_i = x_i - x_i_1\n            # print (np.linalg.norm(dx_i))\n            E_i = dg_i - G_i @ dx_i\n            hessian_MS = G_i + (E_i @ E_i.T) / (E_i.T @ dx_i)\n            hessian_PSB = (\n                G_i\n                + (E_i @ dx_i.T + dx_i @ E_i.T) / (dx_i.T @ dx_i)\n                - (dx_i.T @ E_i) * (dx_i @ dx_i.T) / (dx_i.T @ dx_i) ** 2\n            )\n            gamma = 1 - (dx_i.T @ E_i) ** 2 / ((dx_i.T @ dx_i) * (E_i.T @ E_i))\n            hessian = (1 - gamma) * hessian_MS + gamma * hessian_PSB\n            return dV_dx, hessian\n        elif hessian_update == \"exact\":\n            force, hessian = self.calculator.get_hessian(\n                molecule, chg, multiplicity\n            )\n            dV_dx = -np.reshape(force, (3 * n, 1))\n            self.num_hessian_calls += 1\n            return dV_dx, hessian\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.make_restart_file","title":"make_restart_file","text":"<pre><code>make_restart_file(molecule, constraints, num_scan)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def make_restart_file(self, molecule, constraints, num_scan):\n    save_directory = self.log_directory\n    if save_directory == \"\":\n        print(\"No log directory!!! We do not save the pathway!!!\")\n    else:\n        # Save xyz file\n        with open(os.path.join(save_directory, \"new_R.com\"), \"w\") as f:\n            f.write(\"{molecule.get_chg()} {molecule.get_multiplicity()}\\n\")\n            for atom in molecule.atom_list:\n                f.write(atom.get_content())\n            f.write(\"\\n\")\n            f.flush()\n\n        with open(os.path.join(save_directory, \"new_coordinates\"), \"w\") as f:\n            for i, constraint in enumerate(constraints):\n                value = constraints[constraint]\n                new_constraint = [str(index + 1) for index in constraint]\n                content = \" \".join(new_constraint)\n                if i == len(constraints) - 1:\n                    num_step = num_scan\n                else:\n                    num_step = 0\n                f.write(f\"{content} {value} {num_step}\\n\")\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.print_status","title":"print_status","text":"<pre><code>print_status(molecule, constraints, unit='degree')\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def print_status(self, molecule, constraints, unit=\"degree\"):\n    print(\"########## Current geometry info ############\")\n    print(\"\\t Target \\t Current\")\n    coordinate_list = molecule.get_coordinate_list()\n    for constraint in constraints:\n        new_constraint = self.get_corrected_indices(constraint)\n        target_value = constraints[constraint]\n        current_value = molecule.get_internal_coordinate(constraint, unit)\n        current_value = float(format(current_value, \".4f\"))\n        if len(constraint) &gt; 2:\n            if unit == \"degree\":\n                target_value *= 180 / np.pi\n        print(f\"{new_constraint}   {target_value}  {current_value}\")\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.save_figure","title":"save_figure","text":"<pre><code>save_figure(data, unit='kcal')\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def save_figure(self, data, unit=\"kcal\"):\n    try:\n        import matplotlib.pyplot as plt\n\n        from himatcal.tools import mplstyle_file\n\n        plt.style.use(mplstyle_file)\n    except:\n        return None\n    x = list(range(len(data)))\n    plt.plot(x, np.array(data), \"s-\")\n    plt.xlabel(\"Step\")\n    plt.ylabel(f\"Energy ({unit}/mol)\")\n    plt.savefig(os.path.join(self.log_directory, \"profile.png\"))\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.scan","title":"scan","text":"<pre><code>scan(molecule, constraints, num_steps, chg=None, multiplicity=None, restart=False, reoptimize=True)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def scan(\n    self,\n    molecule,\n    constraints,\n    num_steps,\n    chg=None,\n    multiplicity=None,\n    restart=False,\n    reoptimize=True,\n):  # constraints: given as bond: target_distance\n    if type(num_steps) is int:\n        new_num_steps = dict()\n        for constraint in constraints:\n            new_num_steps[constraint] = num_steps\n        num_steps = new_num_steps  # Make cubic scan coordinates\n    else:\n        num_steps = num_steps.copy()  # It should be dict\n    num_scan = sum(num_steps.values())\n\n    self.calculator.set_error_directory(self.log_directory)\n    constraints = constraints.copy()\n    coordinate_list = molecule.get_coordinate_list()\n    delta_q, update_q = self.get_delta_q(coordinate_list, constraints)\n    # Write reactant info\n    self.write_log(\"###### Reactant information ######\\n\", \"w\")\n    if chg is not None and multiplicity is not None:\n        self.write_log(f\"charge: {chg}    multiplicity: {multiplicity}\\n\")\n    else:\n        self.write_log(\"Default charge and multiplicity values are used !!!\\n\")\n    self.write_log(str(len(molecule.atom_list)) + \"\\n\")\n    for atom in molecule.atom_list:\n        self.write_log(atom.get_content())\n    self.write_log(\"\\n\")\n    self.write_log(\"######### Scanning coordinates #########\\n\")\n\n    # Make updates\n    updates = dict()\n    maximum_delta = -100\n    total_delta = 0\n    digit = 3\n    for coordinate in delta_q:\n        current_value = ic.get_single_q_element(coordinate_list, coordinate)\n        target_value = constraints[coordinate]\n        new_constraint = self.get_corrected_indices(coordinate)\n        if len(coordinate) &gt; 2:\n            current_value *= 180 / np.pi\n            target_value *= 180 / np.pi\n        current_value = float(format(current_value, \".4f\"))\n        target_value = float(format(target_value, \".4f\"))\n        delta = delta_q[coordinate]\n        total_delta += abs(delta)\n        delta /= num_steps[coordinate]\n        updates[coordinate] = delta\n        if abs(delta) &gt; maximum_delta:\n            maximum_delta = abs(delta)\n        self.write_log(f\"{coordinate}: \\t {current_value} -&gt; {target_value}\\n\")\n\n    # Reset updates when hessian is used ...\n    if self.use_hessian:\n        for constraint in constraints:\n            updates[constraint] = total_delta / num_scan\n\n    # Change step size\n\n    self.write_log(\n        \"\\n ################## Update Information ################### \\n\"\n    )\n    self.write_log(f\"Use hessian: {self.use_hessian}\\n\")\n    self.write_log(f\"Hessian update (if used): {self.hessian_update}\\n\")\n\n    original_step_size = self.step_size\n    # Set default step size: (Maximum delta x/num_relaxation * 3)\n    if self.step_size == 0:\n        if self.use_hessian:\n            self.step_size = total_delta / num_scan\n            self.step_size *= 3 / self.num_relaxation\n        else:\n            self.step_size = maximum_delta / self.num_relaxation * 3\n        self.write_log(\n            f\"Step size is set to {round(self.step_size,4)} as the default value!!!\\n\\n\"\n        )\n\n    # Set default step size: (Maximum delta x/num_relaxation * 3)\n    self.write_log(\n        \"########## Scanning information ##########\\n\" + str(self) + \"\\n\"\n    )\n    ###### Write basic informations #####\n    self.write_log(\n        \"##### Calculator information ######\\n\" + str(self.calculator)\n    )  # Calculator information\n    self.write_log(\n        f\"\\nAll electronic energies are written in {self.energy_unit}! \\n\"\n    )\n    self.write_log(\"All distances are written in angstrom! \\n\")\n    self.write_log(\"All angles are written in degree(o)! \\n\\n\")\n\n    st = datetime.datetime.now()\n    self.write_log(f\"Starting time: {st}\\n\")\n    print(\"scanning ...\")\n    list_of_constraints = list(constraints.keys())\n    self.write_log(\"Set up done!!!\\n\")\n    if reoptimize:\n        now = datetime.datetime.now()\n        now = str(now)[:-digit]\n        self.write_log(f\"[{now}] Reoptmizing current geometry ...\\n\")\n        # To start with the geometries of reactants that are near local minima ...\n        relaxing_path = self.calculator.relax_geometry(\n            molecule, constraints, chg, multiplicity, \"Reactant\", None, 1000\n        )\n        if len(relaxing_path) &lt; 1:\n            self.write_log(\n                f\"[{datetime.datetime.now()}] Calculation did not terminate properly !!!\\n\"\n            )\n            file_directory = os.path.join(\n                self.calculator.error_directory, f\"{self.calculator.name}.err\"\n            )\n            self.write_log(f\"Check file {file_directory} !!! \\n\")\n            self.write_log(\"Terminating pyMCD ... \\n\")\n            # self.make_restart_file(molecule,constraints,num_steps)\n            return []\n        try:\n            self.num_force_calls += len(relaxing_path)\n        except:\n            a = 1\n        now = datetime.datetime.now()\n        now = str(now)[:-digit]\n        self.write_log(f\"[{now}] Relaxation finished! Start scanning ....\\n\")\n    else:\n        self.write_log(\"Calculating the energy of current geometry ...\\n\")\n        energy = self.calculator.get_energy(molecule, chg, multiplicity)\n        if energy is None:\n            self.write_log(\n                f\"[{datetime.datetime.now()}] Calculation did not terminate properly !!!\\n\"\n            )\n            file_directory = os.path.join(\n                self.calculator.error_directory, f\"{self.calculator.name}.err\"\n            )\n            self.write_log(f\"Check file {file_directory} !!! \\n\")\n            self.write_log(\"Terminating pyMCD ... \\n\")\n            return []\n        molecule.energy = energy\n    copied_molecule = molecule.copy()\n    copied_molecule.energy = molecule.energy\n    trajectory = [copied_molecule]  # Trajectory is list of coordinates\n    # self.print_status(molecule,constraints)\n    energy_list = [molecule.energy]\n    if restart:\n        self.update_pathway(copied_molecule, \"a\")\n    else:\n        self.update_pathway(copied_molecule, \"w\")\n    for iteration in range(num_scan):\n        starttime = datetime.datetime.now()\n        # self.write_log(f'[{starttime}] Performing one step search ... ({len(trajectory)-1}/{total_num_scans}) completed ... \\n')\n        # Update/Relax geometry\n        self.print_status(molecule, constraints)\n        self.update_geometry(molecule, constraints, updates, chg, multiplicity)\n        tmp_st = str(datetime.datetime.now())[:-digit]\n        content = f\"[{tmp_st}] Progress ({iteration+1}/{num_scan}): \"\n        constraint_contents = []\n        for coordinate in constraints:\n            new_constraint = self.get_corrected_indices(coordinate)\n            constraint_contents.append(\n                f'{new_constraint}: {round(molecule.get_internal_coordinate(coordinate,\"degree\"),5)}'\n            )\n        content = content + \", \".join(constraint_contents)\n        self.write_log(content + \"\\n\")\n        relaxing_path = self.calculator.relax_geometry(\n            molecule,\n            list_of_constraints,\n            chg,\n            multiplicity,\n            \"test\",\n            self.num_relaxation,\n            self.step_size,\n        )\n        # scfenergies = calculated_data.scfenergies[]\n        # print ('relaxation energy: ',scfenergies[0] - molecule.energy)\n        if len(relaxing_path) &lt; 1:\n            self.write_log(\n                f\"[{datetime.datetime.now()}] Calculation did not terminate properly !!!\\n\"\n            )\n            self.write_log(f\"Check file {self.calculator.name}.err ...\\n\")\n            self.write_log(\"Terminating pyMCD ... \\n\")\n            self.make_restart_file(molecule, constraints, num_steps)\n            return []\n\n        try:\n            self.num_force_calls += len(relaxing_path)\n        except:\n            a = 1\n        endtime = datetime.datetime.now()\n        energy = molecule.energy\n        copied_molecule = molecule.copy()\n        copied_molecule.energy = energy\n        # Summary log for a single step\n        delta_e = energy - energy_list[-1]\n        delta_time = endtime - starttime\n        word = \"Increased\"\n        exponent = int(np.log10(np.abs(delta_e)))\n        x = delta_e * 10 ** (-exponent)\n        if x &lt; 0:\n            word = \"Decreased\"\n            x *= -1\n        x = format(x, \".4f\")\n        endtime = str(endtime)[:-digit]\n        delta_time = str(delta_time)[:-digit]\n        self.write_log(\n            f\"[{endtime}] {x}E{exponent} {self.energy_unit} has {word}. {delta_time} Taken ... Total {self.num_force_calls} force calls performed !!!\\n\"\n        )\n        energy_list.append(energy)\n        # Save/Copy new molecule\n        self.update_pathway(copied_molecule, \"a\")\n        trajectory.append(copied_molecule)\n        delta_energy = energy_list[-1] - energy_list[-2]\n        print(\"Energy increase: \", delta_energy)\n        print(\"Energy: \", energy_list)\n    self.write_log(f\"[{datetime.datetime.now()}] Scan completed ...\\n\")\n    self.write_log(\n        f\"Total {self.num_force_calls} force calculations performed ...\\n\"\n    )\n    self.write_log(\n        f\"Total {self.num_hessian_calls} hessian calculations performed ...\\n\"\n    )\n    self.write_profile(trajectory)\n    et = datetime.datetime.now()\n    self.write_log(f\"End time: {et}\\n\")\n    self.write_log(f\"Taken time: {et-st}\\n\")\n    self.calculator.error_directory = None\n    self.step_size = original_step_size\n    self.previous_gradient = None\n    self.previous_hessian = None\n    self.previous_geometry = None\n\n    return trajectory\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.select_coordinate","title":"select_coordinate","text":"<pre><code>select_coordinate(coordinate_list, dV_dx, delta_q, scanning_coordinates)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def select_coordinate(self, coordinate_list, dV_dx, delta_q, scanning_coordinates):\n    # Get inner products (coefficients)\n    constraints = list(delta_q.keys())\n    dV_dq = ic.get_gradient_q(dV_dx, coordinate_list, constraints)\n    minimum = 1000000\n    # print (dV_dq)\n    delta_es = dict()\n    for idx, internal_coordinate in enumerate(constraints):\n        if internal_coordinate not in scanning_coordinates:\n            continue\n        sign = 1\n        if delta_q[internal_coordinate] &lt; 0:\n            sign = -1\n        delta_e = dV_dq[idx][0] * sign\n        delta_es[internal_coordinate] = delta_e\n        if delta_e &lt; minimum:\n            minimum = delta_e\n            selected_coordinate = internal_coordinate\n    # print ('product: ',delta_es,selected_coordinate)\n    print(\"Expected energy change:\", minimum)\n    return selected_coordinate\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.update_geometry","title":"update_geometry","text":"<pre><code>update_geometry(molecule, constraints, updates, chg=None, multiplicity=None)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def update_geometry(\n    self, molecule, constraints, updates, chg=None, multiplicity=None\n):\n    num_relaxation = self.num_relaxation  # N\n    coordinate_list = molecule.get_coordinate_list()\n    delta_q, update_q = self.get_delta_q(\n        coordinate_list, constraints\n    )  # Only scanning coordinates are survived\n    # If you want to put additional redundnat coordinate, activate consider_redundant, and implement your own redundant coordinate (Default: If activated, interatomic distance between bonded atoms are added)\n    scanning_coordinates = []\n    atom_list = molecule.atom_list\n    n = len(atom_list)\n    for constraint in delta_q:\n        if abs(delta_q[constraint]) &gt; 0.001:\n            scanning_coordinates.append(constraint)\n    if len(scanning_coordinates) &gt; 1:\n        update_size = updates[scanning_coordinates[0]]\n        # Make update vector\n        if self.use_hessian:\n            dV_dx, hessian = self.get_hessian(molecule, chg, multiplicity)\n            dV_dq = ic.get_gradient_q(dV_dx, coordinate_list, constraints)\n            H_q = ic.get_hessian_q(dV_dx, hessian, coordinate_list, constraints)\n\n            # Make reduce function\n            reduced_indices = []\n            for idx, internal_coordinate in enumerate(constraints):\n                if internal_coordinate in scanning_coordinates:\n                    reduced_indices.append(idx)\n            reduce_function = np.ix_(reduced_indices, reduced_indices)\n            dV_dq = dV_dq[reduced_indices]\n            H_q = H_q[reduce_function]\n            # print (dV_dq)\n            # print (hessian,H_q)\n            # Make update vector\n            solution = self.find_solution(\n                dV_dq, H_q, update_size, delta_q, scanning_coordinates\n            )\n            for constraint in solution:\n                update_q[constraint] = solution[constraint]\n\n            # After using them, update previous ...\n            self.previous_gradient = dV_dx\n            self.previous_hessian = hessian\n            self.previous_geometry = molecule.get_coordinate_list()\n        else:\n            dV_dx = self.get_gradient(molecule, chg, multiplicity)\n            selected_coordinate = self.select_coordinate(\n                coordinate_list, dV_dx, delta_q, scanning_coordinates\n            )\n            # Update geometry using ic module\n            update_q[selected_coordinate] = updates[selected_coordinate]\n    else:\n        constraint = scanning_coordinates[0]\n        delta = delta_q[constraint]\n        if self.use_hessian:\n            update_size = updates[constraint]\n            if delta &gt; 0:\n                update_q[constraint] = min(delta, update_size)\n            else:\n                update_q[constraint] = max(delta, -update_size)\n        else:\n            update_q[constraint] = updates[constraint]\n        force = None\n    # molecule.print_coordinate_list()\n    ic.update_geometry(coordinate_list, update_q)\n    process.locate_molecule(molecule, coordinate_list)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.update_pathway","title":"update_pathway","text":"<pre><code>update_pathway(calculated_molecule, mode='a')\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def update_pathway(\n    self, calculated_molecule, mode=\"a\"\n):  # Calculated molecule that will be added to the current pathway\n    save_directory = self.log_directory\n    if save_directory == \"\":\n        print(\"No log directory!!! We do not save the pathway!!!\")\n    else:\n        # Save xyz file\n        with open(os.path.join(save_directory, \"pathway.xyz\"), mode) as f:\n            f.write(\n                str(len(calculated_molecule.atom_list))\n                + \"\\n\"\n                + str(calculated_molecule.energy)\n                + \"\\n\"\n            )\n            for atom in calculated_molecule.atom_list:\n                content = atom.get_content()\n                f.write(content)\n            f.flush()\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.write_log","title":"write_log","text":"<pre><code>write_log(content, mode='a')\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def write_log(self, content, mode=\"a\"):\n    if self.log_directory == \"\":\n        print(\"No log directory!!! We write nothing!!!\")\n    else:\n        log_directory = os.path.join(self.log_directory, \"output.log\")\n        with open(log_directory, mode) as f:\n            f.write(content)\n            f.flush()\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/mcd.html#himatcal.utils.mcd.mcd.MCD.write_profile","title":"write_profile","text":"<pre><code>write_profile(trajectory)\n</code></pre> Source code in <code>himatcal/utils/mcd/mcd.py</code> <pre><code>def write_profile(self, trajectory):\n    # Save trajectory with log file and trajectory files (xyz, pkl)\n    save_directory = self.log_directory\n    n = len(trajectory)\n    energy_list = []\n    for i in range(n):\n        molecule = trajectory[i]\n        energy_list.append(molecule.energy)\n    n = len(energy_list)\n    energy_log = open(os.path.join(save_directory, \"profile.log\"), \"w\")\n\n    # Always make it into kcal/mol\n    converter = 1\n    if self.energy_unit == \"Hartree\":\n        converter = 627.5094740631\n    elif self.energy_unit == \"eV\":\n        converter = 23.0605506577\n    energy_log.write(\n        f\"Original Energy ({self.energy_unit}/mol) \\t Relative Energy (kcal/mol)\\n\"\n    )\n    reference_energy = energy_list[0]\n    maximum_index = 0\n    maximum_energy = -100000000\n    relative_energy_list = []\n    for i in range(n):\n        relative_energy = energy_list[i] - reference_energy\n        relative_energy_list.append(relative_energy * converter)\n        energy = energy_list[i]\n        energy_log.write(f\"{energy} \\t {relative_energy*converter}\\n\")\n        if energy &gt; maximum_energy:\n            maximum_energy = energy\n            maximum_index = i\n    # Save figure\n    self.save_figure(relative_energy_list, \"kcal\")\n    # Write maxima point ...\n    trajectory[maximum_index].write_geometry(os.path.join(save_directory, \"ts.xyz\"))\n\n    # Search valley indices with using Golay Filter\n    for i in range(self.num_filter_iteration):\n        window_length = min(\n            9, len(energy_list)\n        )  # Ensure window_length is less than or equal to the size of energy_list\n        energy_list = savgol_filter(energy_list, window_length, 4)\n\n    left_min = None\n    max_index = None\n    ts_indices = []\n    right_min = None\n    max_energy_index = None\n    max_energy = -1000000\n\n    # Assume that curve is now well smoothed ...\n    for i in range(n - 1):\n        # print (left_min,max_index)\n        if left_min is None:\n            if energy_list[i] &lt; energy_list[i + 1]:  # Increasing\n                left_min = i\n        else:\n            if max_index is None:\n                if energy_list[i] &gt; energy_list[i + 1]:  # Decreasing\n                    max_index = i\n            else:\n                if energy_list[i] &lt; energy_list[i + 1]:  # If reincreasing ...\n                    right_min = i\n                    ts_indices.append(max_index)\n                    left_min = i\n                    max_index = None  # Search for the next local maximum\n                elif i == n - 2:\n                    right_min = i\n                    ts_indices.append(max_index)\n\n    # Write maxima points\n    if len(ts_indices) &gt; 0:\n        content = \", \".join([str(ts_index) for ts_index in ts_indices])\n        energy_log.write(\n            f\"\\nLocal maxima around {content}th point(s) are found !!!\\n\\n\"\n        )\n    else:\n        energy_log.write(\n            \"No local maxima points are found !!! May be barrierless reaction ???\\n\\n\"\n        )\n    energy_log.close()\n\n    if len(ts_indices) == 0:\n        self.write_log(\"Caution: Barrierless reaction is found !!!\\n\")\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/process.html","title":"process","text":"<p>---generate_molecule.py--- Generate 2D graph molecule in ACE-Reaction format from xyz files or SMILES</p>"},{"location":"reference/himatcal/utils/mcd/process.html#himatcal.utils.mcd.process.locate_atom","title":"locate_atom","text":"<pre><code>locate_atom(atom, coordinate)\n</code></pre> <p>Locates a single atom to input 'coordinate' Args:     |  atom (): class instance of Atom     |  coordinate (list of float): coordinate in form of [x,y,z] Returns:     |  No return, it directly locates the atom to the given coordinate Source code in <code>himatcal/utils/mcd/process.py</code> <pre><code>def locate_atom(atom, coordinate):\n    \"\"\"Locates a single atom to input 'coordinate'\n    Args:\n        |  atom (&lt;class 'Atom'&gt;): class instance of Atom\n        |  coordinate (list of float): coordinate in form of [x,y,z]\n    Returns:\n        |  No return, it directly locates the atom to the given coordinate\n    \"\"\"\n    atom.x = coordinate[0]\n    atom.y = coordinate[1]\n    atom.z = coordinate[2]\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/process.html#himatcal.utils.mcd.process.locate_molecule","title":"locate_molecule","text":"<pre><code>locate_molecule(ace_molecule, coordinate_list)\n</code></pre> <p>Locates atoms according to coordinate_list, be cautious on ordering of atoms Args:     |  ace_molecule (): class instance of Molecule     |  coordinate_list (list of list (x,y,z)): list of 3d coordinate, where each x,y,z are float type Returns:     |  No return, it direcly modifies the geometry of a given molecule Source code in <code>himatcal/utils/mcd/process.py</code> <pre><code>def locate_molecule(ace_molecule, coordinate_list):\n    \"\"\"Locates atoms according to coordinate_list, be cautious on ordering of atoms\n    Args:\n        |  ace_molecule (&lt;class 'Molecule'&gt;): class instance of Molecule\n        |  coordinate_list (list of list (x,y,z)): list of 3d coordinate, where each x,y,z are float type\n    Returns:\n        |  No return, it direcly modifies the geometry of a given molecule\n    \"\"\"\n    atom_list = ace_molecule.atom_list\n    for i in range(len(atom_list)):\n        atom = atom_list[i]\n        atom.set_coordinate(coordinate_list[i])\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/process.html#himatcal.utils.mcd.process.translate_atom","title":"translate_atom","text":"<pre><code>translate_atom(atom, vector)\n</code></pre> Source code in <code>himatcal/utils/mcd/process.py</code> <pre><code>def translate_atom(atom, vector):\n    atom.x += vector[0]\n    atom.y += vector[1]\n    atom.z += vector[2]\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/process.html#himatcal.utils.mcd.process.translate_molecule","title":"translate_molecule","text":"<pre><code>translate_molecule(ace_molecule, vector)\n</code></pre> Source code in <code>himatcal/utils/mcd/process.py</code> <pre><code>def translate_molecule(ace_molecule, vector):\n    atom_list = ace_molecule.atom_list\n    for atom in atom_list:\n        translate_atom(atom, vector)\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/run.html","title":"run","text":""},{"location":"reference/himatcal/utils/mcd/run.html#himatcal.utils.mcd.run.pathway","title":"pathway  <code>module-attribute</code>","text":"<pre><code>pathway = generate_path()\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/run.html#himatcal.utils.mcd.run.change_option","title":"change_option","text":"<pre><code>change_option(args)\n</code></pre> Source code in <code>himatcal/utils/mcd/run.py</code> <pre><code>def change_option(args):\n    correct = True\n    try:\n        option_directory = os.path.join(args.input_directory, \"option\")\n    except:\n        print(\"Default option is used !!!\")\n        return\n    if os.path.exists(option_directory):\n        wrong_attributes = []\n        with open(option_directory) as f:\n            for line in f:\n                words = line.strip().split(\"=\")\n                attribute = words[0]\n                value = words[1]\n                if attribute == \"working_directory\":\n                    args.working_directory = value\n                elif attribute == \"num_relaxation\":\n                    try:\n                        value = int(value)\n                        if value &lt;= 0:\n                            print(\n                                f\"Wrong num_relaxation (={value}) is given! Check the option file !!!\"\n                            )\n                            print(\"The value must be positive integer !!!\\n\")\n                            correct = False\n                        else:\n                            args.num_relaxation = value\n                    except:\n                        print(\n                            f\"Wrong num_relaxation (={value}) is given! Check the option file !!!\"\n                        )\n                        print(\"The value must be positive integer !!!\\n\")\n                        correct = False\n                elif attribute == \"step_size\":\n                    try:\n                        value = float(value)\n                        if value &lt;= 0.0:\n                            print(\n                                f\"Wrong step_size (={value}) is given! Check the option file !!!\"\n                            )\n                            print(\"The value must be positive !!!\\n\")\n                            correct = False\n                        else:\n                            args.step_size = value\n                    except:\n                        print(\n                            f\"Wrong step_size (={value}) is given! Check the option file !!!\"\n                        )\n                        print(\"The value must be positive !!!\\n\")\n                        correct = False\n                elif attribute == \"unit\":\n                    if value not in [\"eV\", \"Hartree\", \"kcal\"]:\n                        print(\n                            f\"Wrong unit (={value}) is given! Check the option file !!!\"\n                        )\n                        print(\"Only eV, Hartree, kcal are allowed options !!!\\n\")\n                        correct = False\n                    else:\n                        args.unit = value\n                elif attribute == \"calculator\":\n                    args.calculator = value\n                elif attribute == \"command\":\n                    args.command = value\n                elif attribute == \"use_hessian\":\n                    try:\n                        value = int(value)\n                        if value not in [0, 1]:\n                            print(\n                                f\"Wrong use_hessian (={value}) is given! Check the option file !!!\"\n                            )\n                            print(\n                                \"Only 0 or 1 are possible. If the value is zero, hessian is not used. Otherwise, hessian is used ... Default value is 0 \\n\"\n                            )\n                            correct = False\n                        else:\n                            args.use_hessian = value\n                    except:\n                        print(\n                            f\"Wrong use_hessian (={value}) is given! Check the option file !!!\"\n                        )\n                        print(\n                            \"Only 0 or 1 are possible. If the value is zero, hessian is not used. Otherwise, hessian is used ... Default value is 0 \\n\"\n                        )\n                        correct = False\n\n                elif attribute == \"hessian_update\":\n                    if str.lower(value) not in [\"exact\", \"bofill\"]:\n                        print(\n                            f\"Wrong hessian_update (={value}) is given! Check the option file !!!\"\n                        )\n                        print(\n                            \"Only bofill and exact are possible options !!! Default method is bofill\\n\"\n                        )\n                        correct = False\n                    else:\n                        args.hessian_update = value\n\n                elif attribute == \"reoptimize\":\n                    try:\n                        value = int(value)\n                        if value not in [0, 1]:\n                            print(\n                                f\"Wrong reoptimize (={value}) is given! Check the option file !!!\"\n                            )\n                            print(\n                                \"Only 0 or 1 are possible. If the value is zero, given geometry is directly undergone MCD, otherwise, the molecule is reoptimized !!! Default value is 1\\n\"\n                            )\n                            correct = False\n                        else:\n                            args.reoptimize = value\n                    except:\n                        print(\n                            f\"Wrong reoptimize (={value}) is given! Check the option file !!!\"\n                        )\n                        print(\n                            \"Only 0 or 1 are possible. If the value is zero, given geometry is directly undergone MCD, otherwise, the molecule is reoptimized !!! Default value is 1\\n\"\n                        )\n                        correct = False\n                else:\n                    wrong_attributes.append(attribute)\n                    correct = False\n\n            if len(wrong_attributes) &gt; 0:\n                content = \",\".join(wrong_attributes)\n                print(\n                    f\"Wrong attribute(s) (={content}) is given! Check the option file !!!\"\n                )\n                print(\n                    \"Possible attributes are 'working_directory', 'num_relaxation','step_size','unit','calculator','command','use_hessian','hessian_update','reoptimize'\"\n                )\n\n    else:\n        print(\"option directory is not found! Default parameters are used!!!\")\n\n    return correct\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/run.html#himatcal.utils.mcd.run.generate_path","title":"generate_path","text":"<pre><code>generate_path()\n</code></pre> Source code in <code>himatcal/utils/mcd/run.py</code> <pre><code>def generate_path():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--input_directory\", \"-id\", type=str, help=\"directory of inputs\"\n    )\n    parser.add_argument(\n        \"--output_directory\",\n        \"-od\",\n        type=str,\n        help=\"directory for saving outputs\",\n        default=None,\n    )\n    parser.add_argument(\n        \"--working_directory\",\n        \"-wd\",\n        type=str,\n        help=\"scratch directory of QC programs\",\n        default=\"\",\n    )\n    parser.add_argument(\n        \"--num_relaxation\", type=int, help=\"Num relaxation for input\", default=5\n    )\n    parser.add_argument(\n        \"--step_size\", type=float, help=\"Maxmial displacement\", default=0.0\n    )\n    parser.add_argument(\n        \"--calculator\",\n        \"-c\",\n        type=str,\n        help=\"Name of Quantum Calculation software\",\n        default=\"gaussian\",\n    )\n    parser.add_argument(\"--unit\", \"-u\", type=str, help=\"unit\", default=\"Hartree\")\n    parser.add_argument(\n        \"--command\", type=str, help=\"command for running qc package\", default=\"g09\"\n    )\n    parser.add_argument(\"--use_hessian\", type=int, default=0)\n    parser.add_argument(\"--restart\", type=int, default=0)\n    parser.add_argument(\"--hessian_update\", type=str, default=\"bofill\")\n    parser.add_argument(\"--reoptimize\", type=int, default=1)\n\n    args = parser.parse_args()\n\n    input_directory = args.input_directory\n    output_directory = args.output_directory\n    if output_directory is None:\n        output_directory = input_directory\n    # If problem with input, output directory, automatically exit\n    if not os.path.exists(input_directory):\n        print(\"Cannot find the input directory !!!\")\n        exit()\n    elif not os.path.exists(output_directory):\n        print(\"Given output directory is not found !!!\")\n        exit()\n\n    print(f\"\\ninput directory: {input_directory}\")\n    print(f\"output directory: {output_directory}\\n\")\n\n    reactant = read_reactant(input_directory)  # Read geometry of reactant\n    constraints, num_steps = read_bond_info(input_directory)  # bond info\n    correct = change_option(args)  # Read option file and change values in args\n\n    use_hessian = args.use_hessian\n    reoptimize = args.reoptimize\n\n    restart = args.restart\n\n    if use_hessian == 0:\n        use_hessian = False\n    else:\n        use_hessian = True\n\n    if reoptimize == 0:\n        reoptimize = False\n    else:\n        reoptimize = True\n\n    if restart == 0:\n        restart = False\n    else:\n        restart = True\n\n    if not correct:\n        exit()\n    calculator = get_calculator(\n        args\n    )  # Make calculator, you can use your own calculator!\n    if calculator is None:\n        exit()\n    scanner = mcd.MCD(num_relaxation=args.num_relaxation, calculator=calculator)\n    scanner.use_hessian = use_hessian\n    scanner.hessian_update = args.hessian_update\n    scanner.step_size = args.step_size\n    scanner.log_directory = output_directory\n    working_directory = args.working_directory\n    if working_directory != \"\":\n        if os.path.exists(working_directory):\n            scanner.change_working_directory(working_directory)\n        else:\n            print(\n                \"working directory does not exist!!! Using output directory as default ...\"\n            )\n            working_directory = output_directory\n    else:\n        # print ('adfasdfa',output_directory)\n        working_directory = output_directory\n    scanner.change_working_directory(working_directory)\n    print(f\"working directory: {working_directory}\\n\")\n\n    scanner.change_energy_unit(args.unit)\n    # exit()\n    # Also, write constraints information (TODO)\n\n    num_scan = sum(num_steps.values())\n\n    print(\"\\n=======================================================\")\n    print(\"================= MCD RUNNING !!! ===================\")\n    print(\"=======================================================\\n\")\n\n    pathway = scanner.scan(\n        reactant,\n        constraints,\n        num_steps,\n        chg=reactant.chg,\n        multiplicity=reactant.multiplicity,\n    )\n    return pathway\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/run.html#himatcal.utils.mcd.run.get_calculator","title":"get_calculator","text":"<pre><code>get_calculator(args)\n</code></pre> Source code in <code>himatcal/utils/mcd/run.py</code> <pre><code>def get_calculator(args):\n    calculator_name = args.calculator.lower()\n    if calculator_name == \"gaussian\":\n        from himatcal.calculator.gaussian_mcd import Gaussian\n\n        calculator = Gaussian(args.command)\n    elif calculator_name == \"orca\":\n        from himatcal.calculator.orca_mcd import Orca\n\n        calculator = Orca(args.command)\n    else:\n        print(\n            f\"Wrong calculator (={calculator_name}) is given! Check the option file !!!\"\n        )\n        calculator = None\n        return calculator\n    calculator.load_content(os.path.join(args.input_directory, \"qc_input\"))\n    basis_file = os.path.join(\n        args.input_directory, \"basis\"\n    )  # For Effective Core Potential\n    if os.path.exists(basis_file):\n        calculator.load_basis(basis_file)\n    return calculator\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/run.html#himatcal.utils.mcd.run.read_bond_info","title":"read_bond_info","text":"<pre><code>read_bond_info(directory)\n</code></pre> Source code in <code>himatcal/utils/mcd/run.py</code> <pre><code>def read_bond_info(directory):\n    constraints = dict()\n    num_steps = dict()\n    formed_bonds = []\n    broken_bonds = []\n    try:\n        f = open(os.path.join(directory, \"coordinates\"))\n    except:\n        print(\"Cannot find 'coordinates' file! Recheck your input !!!\")\n        exit()\n    for line in f:\n        info = line.strip().split()  # 0: start, 1: end, 2: target length, 3: Num steps\n        if len(info) &gt; 0:\n            try:\n                constraint = tuple([int(idx) - 1 for idx in info[:-2]])\n                target_value = float(info[-2])\n            except:\n                print(\"Wrong coordinate found! Check coordinate file again !!!\")\n                print(f\"Current line: {line.strip()}\")\n                print(\n                    \"Input should be given as: [Coordinate] [target value] [num_step]\"\n                )\n                exit()\n            if len(constraint) &lt; 2:\n                print(\"Wrong coordinate found! Check coordinate file again !!!\")\n                print(f\"Current line: {line.strip()}\")\n                print(\n                    \"Input should be given as: [Coordinate] [target value] [num_step]\"\n                )\n                exit()\n            if len(constraint) &gt; 2:\n                target_value *= np.pi / 180\n            constraints[constraint] = target_value\n            try:\n                num_steps[constraint] = int(info[-1])\n            except:\n                print(\"Num steps are not given! Check coordinate file again !!!\")\n                print(\n                    \"Input should be given as: [Coordinate] [target value] [num_step]\"\n                )\n                exit()\n    return constraints, num_steps\n</code></pre>"},{"location":"reference/himatcal/utils/mcd/run.html#himatcal.utils.mcd.run.read_reactant","title":"read_reactant","text":"<pre><code>read_reactant(directory)\n</code></pre> Source code in <code>himatcal/utils/mcd/run.py</code> <pre><code>def read_reactant(directory):\n    try:\n        f = open(os.path.join(directory, \"R.com\"))\n    except:\n        print(\"Cannot find 'R.com' file! Recheck your input !!!\")\n        exit()\n    state_info = f.readline().strip().split(\" \")\n    chg, multiplicity = int(state_info[0]), int(state_info[1])\n    atom_list = []\n    atom_info = f.readline()\n    while atom_info.strip() != \"\":\n        atom_info = atom_info.strip().split()\n        # print (atom_info)\n        atom_type = atom_info[0]\n        x = float(atom_info[1])\n        y = float(atom_info[2])\n        z = float(atom_info[3])\n        atom = chem.Atom(atom_type)\n        atom.x = x\n        atom.y = y\n        atom.z = z\n        atom_list.append(atom)\n        try:\n            atom_info = f.readline()\n            if atom_info.strip() == \"\":\n                break\n        except:\n            break\n    f.close()\n    reactant = chem.Molecule()\n    reactant.atom_list = atom_list\n    reactant.chg = chg\n    reactant.multiplicity = multiplicity\n    return reactant\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html","title":"cirpy","text":"<p>CIRpy</p> <p>Python interface for the Chemical Identifier Resolver (CIR) by the CADD Group at the NCI/NIH. https://github.com/mcs07/CIRpy</p>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.API_BASE","title":"API_BASE  <code>module-attribute</code>","text":"<pre><code>API_BASE = 'https://cactus.nci.nih.gov/chemical/structure'\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.FILE_FORMATS","title":"FILE_FORMATS  <code>module-attribute</code>","text":"<pre><code>FILE_FORMATS = {'alc', 'cdxml', 'cerius', 'charmm', 'cif', 'cml', 'ctx', 'gjf', 'gromacs', 'hyperchem', 'jme', 'maestro', 'mol', 'mol2', 'mrv', 'pdb', 'sdf3000', 'sln', 'xyz'}\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.__author__","title":"__author__  <code>module-attribute</code>","text":"<pre><code>__author__ = 'Matt Swain'\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.__email__","title":"__email__  <code>module-attribute</code>","text":"<pre><code>__email__ = 'm.swain@me.com'\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.__license__","title":"__license__  <code>module-attribute</code>","text":"<pre><code>__license__ = 'MIT'\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = '1.0.2'\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.log","title":"log  <code>module-attribute</code>","text":"<pre><code>log = getLogger('cirpy')\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule","title":"Molecule","text":"<pre><code>Molecule(input, resolvers=None, get3d=False, **kwargs)\n</code></pre> <p>Class to hold and cache the structure information for a given CIR input.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __init__(self, input, resolvers=None, get3d=False, **kwargs):\n    \"\"\"Initialize with a resolver input.\"\"\"\n    self.input = input\n    self.resolvers = resolvers\n    self.get3d = get3d\n    self.kwargs = kwargs\n    log.debug(\"Instantiated Molecule: %s\" % self)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.get3d","title":"get3d  <code>instance-attribute</code>","text":"<pre><code>get3d = get3d\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.image_url","title":"image_url  <code>property</code>","text":"<pre><code>image_url\n</code></pre> <p>URL of a GIF image.</p>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input = input\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs = kwargs\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.resolvers","title":"resolvers  <code>instance-attribute</code>","text":"<pre><code>resolvers = resolvers\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.twirl_url","title":"twirl_url  <code>property</code>","text":"<pre><code>twirl_url\n</code></pre> <p>Url of a TwirlyMol 3D viewer.</p>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __repr__(self):\n    return \"Molecule(input=%r, resolvers=%r, get3d=%r, kwargs=%r)\" % (\n        self.input,\n        self.resolvers,\n        self.get3d,\n        self.kwargs,\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.cas","title":"cas","text":"<pre><code>cas()\n</code></pre> <p>CAS registry numbers.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef cas(self):\n    \"\"\"CAS registry numbers.\"\"\"\n    return resolve(self.input, \"cas\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.download","title":"download","text":"<pre><code>download(filename, representation, overwrite=False)\n</code></pre> <p>Download the resolved structure as a file.</p> <p>:param string filename: File path to save to :param string representation: Desired output representation :param bool overwrite: (Optional) Whether to allow overwriting of an existing file</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def download(self, filename, representation, overwrite=False):\n    \"\"\"Download the resolved structure as a file.\n\n    :param string filename: File path to save to\n    :param string representation: Desired output representation\n    :param bool overwrite: (Optional) Whether to allow overwriting of an existing file\n    \"\"\"\n    download(\n        self.input,\n        filename,\n        representation,\n        overwrite,\n        self.resolvers,\n        self.get3d,\n        **self.kwargs,\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.effective_rotor_count","title":"effective_rotor_count","text":"<pre><code>effective_rotor_count()\n</code></pre> <p>Effective rotor count.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef effective_rotor_count(self):\n    \"\"\"Effective rotor count.\"\"\"\n    return resolve(\n        self.input, \"effective_rotor_count\", self.resolvers, **self.kwargs\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.ficts","title":"ficts","text":"<pre><code>ficts()\n</code></pre> <p>FICTS NCI/CADD hashed structure identifier.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef ficts(self):\n    \"\"\"FICTS NCI/CADD hashed structure identifier.\"\"\"\n    return resolve(self.input, \"ficts\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.ficus","title":"ficus","text":"<pre><code>ficus()\n</code></pre> <p>FICuS NCI/CADD hashed structure identifier.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef ficus(self):\n    \"\"\"FICuS NCI/CADD hashed structure identifier.\"\"\"\n    return resolve(self.input, \"ficus\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.formula","title":"formula","text":"<pre><code>formula()\n</code></pre> <p>Molecular formula</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef formula(self):\n    \"\"\"Molecular formula\"\"\"\n    return resolve(self.input, \"formula\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.h_bond_acceptor_count","title":"h_bond_acceptor_count","text":"<pre><code>h_bond_acceptor_count()\n</code></pre> <p>Hydrogen bond acceptor count.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef h_bond_acceptor_count(self):\n    \"\"\"Hydrogen bond acceptor count.\"\"\"\n    return resolve(\n        self.input, \"h_bond_acceptor_count\", self.resolvers, **self.kwargs\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.h_bond_center_count","title":"h_bond_center_count","text":"<pre><code>h_bond_center_count()\n</code></pre> <p>Hydrogen bond center count.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef h_bond_center_count(self):\n    \"\"\"Hydrogen bond center count.\"\"\"\n    return resolve(self.input, \"h_bond_center_count\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.h_bond_donor_count","title":"h_bond_donor_count","text":"<pre><code>h_bond_donor_count()\n</code></pre> <p>Hydrogen bond donor count.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef h_bond_donor_count(self):\n    \"\"\"Hydrogen bond donor count.\"\"\"\n    return resolve(self.input, \"h_bond_donor_count\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.hashisy","title":"hashisy","text":"<pre><code>hashisy()\n</code></pre> <p>CACTVS HASHISY identifier.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef hashisy(self):\n    \"\"\"CACTVS HASHISY identifier.\"\"\"\n    return resolve(self.input, \"hashisy\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.image","title":"image","text":"<pre><code>image()\n</code></pre> <p>2D image depiction.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef image(self):\n    \"\"\"2D image depiction.\"\"\"\n    return resolve_image(self.input, self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.inchi","title":"inchi","text":"<pre><code>inchi()\n</code></pre> <p>Non-standard InChI. (Uses options DONOTADDH W0 FIXEDH RECMET NEWPS SPXYZ SAsXYZ Fb Fnud).</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef inchi(self):\n    \"\"\"Non-standard InChI. (Uses options DONOTADDH W0 FIXEDH RECMET NEWPS SPXYZ SAsXYZ Fb Fnud).\"\"\"\n    return resolve(self.input, \"inchi\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.iupac_name","title":"iupac_name","text":"<pre><code>iupac_name()\n</code></pre> <p>IUPAC approved name.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef iupac_name(self):\n    \"\"\"IUPAC approved name.\"\"\"\n    return resolve(self.input, \"iupac_name\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.mw","title":"mw","text":"<pre><code>mw()\n</code></pre> <p>Molecular weight.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef mw(self):\n    \"\"\"Molecular weight.\"\"\"\n    return resolve(self.input, \"mw\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.names","title":"names","text":"<pre><code>names()\n</code></pre> <p>List of chemical names.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef names(self):\n    \"\"\"List of chemical names.\"\"\"\n    return resolve(self.input, \"names\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.ring_count","title":"ring_count","text":"<pre><code>ring_count()\n</code></pre> <p>Ring count.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef ring_count(self):\n    \"\"\"Ring count.\"\"\"\n    return resolve(self.input, \"ring_count\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.ringsys_count","title":"ringsys_count","text":"<pre><code>ringsys_count()\n</code></pre> <p>Ring system count.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef ringsys_count(self):\n    \"\"\"Ring system count.\"\"\"\n    return resolve(self.input, \"ringsys_count\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.rotor_count","title":"rotor_count","text":"<pre><code>rotor_count()\n</code></pre> <p>Rotor count.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef rotor_count(self):\n    \"\"\"Rotor count.\"\"\"\n    return resolve(self.input, \"rotor_count\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.rule_of_5_violation_count","title":"rule_of_5_violation_count","text":"<pre><code>rule_of_5_violation_count()\n</code></pre> <p>Rule of 5 violation count.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef rule_of_5_violation_count(self):\n    \"\"\"Rule of 5 violation count.\"\"\"\n    return resolve(\n        self.input, \"rule_of_5_violation_count\", self.resolvers, **self.kwargs\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.sdf","title":"sdf","text":"<pre><code>sdf()\n</code></pre> <p>SDF file.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef sdf(self):\n    \"\"\"SDF file.\"\"\"\n    return resolve(self.input, \"sdf\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.smiles","title":"smiles","text":"<pre><code>smiles()\n</code></pre> <p>SMILES string.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef smiles(self):\n    \"\"\"SMILES string.\"\"\"\n    return resolve(self.input, \"smiles\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.stdinchi","title":"stdinchi","text":"<pre><code>stdinchi()\n</code></pre> <p>Standard InChI.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef stdinchi(self):\n    \"\"\"Standard InChI.\"\"\"\n    return resolve(self.input, \"stdinchi\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.stdinchikey","title":"stdinchikey","text":"<pre><code>stdinchikey()\n</code></pre> <p>Standard InChIKey.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef stdinchikey(self):\n    \"\"\"Standard InChIKey.\"\"\"\n    return resolve(self.input, \"stdinchikey\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Molecule.uuuuu","title":"uuuuu","text":"<pre><code>uuuuu()\n</code></pre> <p>uuuuu NCI/CADD hashed structure identifier.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>@memoized_property\ndef uuuuu(self):\n    \"\"\"uuuuu NCI/CADD hashed structure identifier.\"\"\"\n    return resolve(self.input, \"uuuuu\", self.resolvers, **self.kwargs)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result","title":"Result","text":"<pre><code>Result(input, notation, input_format, resolver, representation, value)\n</code></pre> <p>A single result returned by CIR.</p> <p>:param string input_format: Format of the input as interpreted by the resolver :param string resolver: Resolver used to produce this result :param string representation: Requested output representation :param value: Actual result value :type value: string or list(string)</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __init__(self, input, notation, input_format, resolver, representation, value):\n    \"\"\"\n\n    :param string input: Originally supplied input identifier that produced this result\n    :param string notation: Identifier matched by the resolver or tautomer ID\n    :param string input_format: Format of the input as interpreted by the resolver\n    :param string resolver: Resolver used to produce this result\n    :param string representation: Requested output representation\n    :param value: Actual result value\n    :type value: string or list(string)\n    \"\"\"\n    self.input = input\n    self.representation = representation\n    self.resolver = resolver\n    self.input_format = input_format\n    self.notation = notation\n    self.value = value\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input = input\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.input_format","title":"input_format  <code>instance-attribute</code>","text":"<pre><code>input_format = input_format\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.notation","title":"notation  <code>instance-attribute</code>","text":"<pre><code>notation = notation\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.representation","title":"representation  <code>instance-attribute</code>","text":"<pre><code>representation = representation\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.resolver","title":"resolver  <code>instance-attribute</code>","text":"<pre><code>resolver = resolver\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value = value\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.__contains__","title":"__contains__","text":"<pre><code>__contains__(prop)\n</code></pre> <p>Allow dict-style checking of attributes to ease transition from when results were dicts.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __contains__(self, prop):\n    \"\"\"Allow dict-style checking of attributes to ease transition from when results were dicts.\"\"\"\n    return prop in self.__dict__\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __eq__(self, other):\n    return isinstance(other, type(self)) and self.__dict__ == other.__dict__\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(prop)\n</code></pre> <p>Allow dict-style access to attributes to ease transition from when results were dicts.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __getitem__(self, prop):\n    \"\"\"Allow dict-style access to attributes to ease transition from when results were dicts.\"\"\"\n    if prop in self.__dict__:\n        return getattr(self, prop)\n    raise KeyError(prop)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __repr__(self):\n    return (\n        \"Result(input=%r, representation=%r, resolver=%r, input_format=%r, notation=%r, value=%r)\"\n        % (\n            self.input,\n            self.representation,\n            self.resolver,\n            self.input_format,\n            self.notation,\n            self.value,\n        )\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(prop, val)\n</code></pre> <p>Allow dict-style setting of attributes to ease transition from when results were dicts.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __setitem__(self, prop, val):\n    \"\"\"Allow dict-style setting of attributes to ease transition from when results were dicts.\"\"\"\n    setattr(self, prop, val)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def __str__(self):\n    return self.value\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.Result.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Return a dictionary containing Result data.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def to_dict(self):\n    \"\"\"Return a dictionary containing Result data.\"\"\"\n    return self.__dict__\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.construct_api_url","title":"construct_api_url","text":"<pre><code>construct_api_url(input, representation, resolvers=None, get3d=False, tautomers=False, xml=True, **kwargs)\n</code></pre> <p>Return the URL for the desired API endpoint.</p> <p>:param string input: Chemical identifier to resolve :param string representation: Desired output representation :param list(str) resolvers: (Optional) Ordered list of resolvers to use :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable) :param bool tautomers: (Optional) Whether to return all tautomers :param bool xml: (Optional) Whether to return full XML response :returns: CIR API URL :rtype: str</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def construct_api_url(\n    input,\n    representation,\n    resolvers=None,\n    get3d=False,\n    tautomers=False,\n    xml=True,\n    **kwargs,\n):\n    \"\"\"Return the URL for the desired API endpoint.\n\n    :param string input: Chemical identifier to resolve\n    :param string representation: Desired output representation\n    :param list(str) resolvers: (Optional) Ordered list of resolvers to use\n    :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable)\n    :param bool tautomers: (Optional) Whether to return all tautomers\n    :param bool xml: (Optional) Whether to return full XML response\n    :returns: CIR API URL\n    :rtype: str\n    \"\"\"\n    # File formats require representation=file and the format in the querystring\n    if representation in FILE_FORMATS:\n        kwargs[\"format\"] = representation\n        representation = \"file\"\n    # Prepend input with 'tautomers:' to return all tautomers\n    if tautomers:\n        input = \"tautomers:%s\" % input\n    url = \"%s/%s/%s\" % (API_BASE, quote(input), representation)\n    if xml:\n        url += \"/xml\"\n    if resolvers:\n        kwargs[\"resolver\"] = \",\".join(resolvers)\n    if get3d:\n        kwargs[\"get3d\"] = True\n    if kwargs:\n        url += \"?%s\" % urlencode(kwargs)\n    return url\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.download","title":"download","text":"<pre><code>download(input, filename, representation, overwrite=False, resolvers=None, get3d=False, **kwargs)\n</code></pre> <p>Convenience function to save a CIR response as a file.</p> <p>This is just a simple wrapper around the resolve function.</p> <p>:param string input: Chemical identifier to resolve :param string filename: File path to save to :param string representation: Desired output representation :param bool overwrite: (Optional) Whether to allow overwriting of an existing file :param list(string) resolvers: (Optional) Ordered list of resolvers to use :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable) :raises HTTPError: if CIR returns an error code :raises ParseError: if CIR response is uninterpretable :raises IOError: if overwrite is False and file already exists</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def download(\n    input,\n    filename,\n    representation,\n    overwrite=False,\n    resolvers=None,\n    get3d=False,\n    **kwargs,\n):\n    \"\"\"Convenience function to save a CIR response as a file.\n\n    This is just a simple wrapper around the resolve function.\n\n    :param string input: Chemical identifier to resolve\n    :param string filename: File path to save to\n    :param string representation: Desired output representation\n    :param bool overwrite: (Optional) Whether to allow overwriting of an existing file\n    :param list(string) resolvers: (Optional) Ordered list of resolvers to use\n    :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable)\n    :raises HTTPError: if CIR returns an error code\n    :raises ParseError: if CIR response is uninterpretable\n    :raises IOError: if overwrite is False and file already exists\n    \"\"\"\n    result = resolve(input, representation, resolvers, get3d, **kwargs)\n    # Just log and return if nothing resolved\n    if not result:\n        log.debug(\"No file to download.\")\n        return\n    # Only overwrite an existing file if explicitly instructed to.\n    if not overwrite and os.path.isfile(filename):\n        raise OSError(\n            \"%s already exists. Use 'overwrite=True' to overwrite it.\" % filename\n        )\n    # Ensure file ends with a newline\n    if not result.endswith(\"\\n\"):\n        result += \"\\n\"\n    with open(filename, \"w\") as f:\n        f.write(result)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.memoized_property","title":"memoized_property","text":"<pre><code>memoized_property(fget)\n</code></pre> <p>Decorator to create memoized properties.</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def memoized_property(fget):\n    \"\"\"Decorator to create memoized properties.\"\"\"\n    attr_name = f\"_{fget.__name__}\"\n\n    @functools.wraps(fget)\n    def fget_memoized(self):\n        if not hasattr(self, attr_name):\n            setattr(self, attr_name, fget(self))\n        return getattr(self, attr_name)\n\n    return property(fget_memoized)\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.query","title":"query","text":"<pre><code>query(input, representation, resolvers=None, get3d=False, tautomers=False, **kwargs)\n</code></pre> <p>Get all results for resolving input to the specified output representation.</p> <p>:param string input: Chemical identifier to resolve :param string representation: Desired output representation :param list(string) resolvers: (Optional) Ordered list of resolvers to use :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable) :param bool tautomers: (Optional) Whether to return all tautomers :returns: List of resolved results :rtype: list(Result) :raises HTTPError: if CIR returns an error code :raises ParseError: if CIR response is uninterpretable</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def query(\n    input, representation, resolvers=None, get3d=False, tautomers=False, **kwargs\n):\n    \"\"\"Get all results for resolving input to the specified output representation.\n\n    :param string input: Chemical identifier to resolve\n    :param string representation: Desired output representation\n    :param list(string) resolvers: (Optional) Ordered list of resolvers to use\n    :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable)\n    :param bool tautomers: (Optional) Whether to return all tautomers\n    :returns: List of resolved results\n    :rtype: list(Result)\n    :raises HTTPError: if CIR returns an error code\n    :raises ParseError: if CIR response is uninterpretable\n    \"\"\"\n    tree = request(input, representation, resolvers, get3d, tautomers, **kwargs)\n    results = []\n    for data in tree.findall(\".//data\"):\n        value = [item.text for item in data.findall(\"item\")]\n        result = Result(\n            input=tree.attrib[\"string\"],\n            representation=tree.attrib[\"representation\"],\n            resolver=data.attrib[\"resolver\"],\n            input_format=data.attrib[\"string_class\"],\n            notation=data.attrib[\"notation\"],\n            value=value[0] if len(value) == 1 else value,\n        )\n        results.append(result)\n    log.debug(\"Received %s query results\", len(results))\n    return results\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.request","title":"request","text":"<pre><code>request(input, representation, resolvers=None, get3d=False, tautomers=False, **kwargs)\n</code></pre> <p>Make a request to CIR and return the XML response.</p> <p>:param string input: Chemical identifier to resolve :param string representation: Desired output representation :param list(string) resolvers: (Optional) Ordered list of resolvers to use :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable) :param bool tautomers: (Optional) Whether to return all tautomers :returns: XML response from CIR :rtype: Element :raises HTTPError: if CIR returns an error code :raises ParseError: if CIR response is uninterpretable</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def request(\n    input, representation, resolvers=None, get3d=False, tautomers=False, **kwargs\n):\n    \"\"\"Make a request to CIR and return the XML response.\n\n    :param string input: Chemical identifier to resolve\n    :param string representation: Desired output representation\n    :param list(string) resolvers: (Optional) Ordered list of resolvers to use\n    :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable)\n    :param bool tautomers: (Optional) Whether to return all tautomers\n    :returns: XML response from CIR\n    :rtype: Element\n    :raises HTTPError: if CIR returns an error code\n    :raises ParseError: if CIR response is uninterpretable\n    \"\"\"\n    url = construct_api_url(\n        input, representation, resolvers, get3d, tautomers, **kwargs\n    )\n    log.debug(\"Making request: %s\", url)\n    response = urlopen(url)\n    return etree.parse(response).getroot()\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.resolve","title":"resolve","text":"<pre><code>resolve(input, representation, resolvers=None, get3d=False, **kwargs)\n</code></pre> <p>Resolve input to the specified output representation.</p> <p>:param string input: Chemical identifier to resolve :param string representation: Desired output representation :param list(string) resolvers: (Optional) Ordered list of resolvers to use :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable) :returns: Output representation or None :rtype: string or None :raises HTTPError: if CIR returns an error code :raises ParseError: if CIR response is uninterpretable</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def resolve(input, representation, resolvers=None, get3d=False, **kwargs):\n    \"\"\"Resolve input to the specified output representation.\n\n    :param string input: Chemical identifier to resolve\n    :param string representation: Desired output representation\n    :param list(string) resolvers: (Optional) Ordered list of resolvers to use\n    :param bool get3d: (Optional) Whether to return 3D coordinates (where applicable)\n    :returns: Output representation or None\n    :rtype: string or None\n    :raises HTTPError: if CIR returns an error code\n    :raises ParseError: if CIR response is uninterpretable\n    \"\"\"\n    # Take first result from XML query\n    results = query(input, representation, resolvers, False, get3d, **kwargs)\n    result = results[0].value if results else None\n    return result\n</code></pre>"},{"location":"reference/himatcal/utils/mol/cirpy.html#himatcal.utils.mol.cirpy.resolve_image","title":"resolve_image","text":"<pre><code>resolve_image(input, resolvers=None, fmt='png', width=300, height=300, frame=False, crop=None, bgcolor=None, atomcolor=None, hcolor=None, bondcolor=None, framecolor=None, symbolfontsize=11, linewidth=2, hsymbol='special', csymbol='special', stereolabels=False, stereowedges=True, header=None, footer=None, **kwargs)\n</code></pre> <p>Resolve input to a 2D image depiction.</p> <p>:param string input: Chemical identifier to resolve :param list(string) resolvers: (Optional) Ordered list of resolvers to use :param string fmt: (Optional) gif or png image format (default png)</p> <p>:param int width: (Optional) Image width in pixels (default 300) :param int height: (Optional) Image height in pixels (default 300) :param bool frame: (Optional) Whether to show border frame (default False) :param int crop: (Optional) Crop image with specified padding</p> <p>:param int symbolfontsize: (Optional) Atom label font size (default 11) :param int linewidth: (Optional) Bond line width (default 2)</p> <p>:param string bgcolor: (Optional) Background color :param string atomcolor: (Optional) Atom label color :param string hcolor: (Optional) Hydrogen atom label color :param string bondcolor: (Optional) Bond color :param string framecolor: (Optional) Border frame color</p> <p>:param bool hsymbol: (Optional) Hydrogens: all, special or none (default special) :param bool csymbol: (Optional) Carbons: all, special or none (default special) :param bool stereolabels: (Optional) Whether to show stereochemistry labels (default False) :param bool stereowedges: (Optional) Whether to show wedge/dash bonds (default True) :param string header: (Optional) Header text above structure :param string footer: (Optional) Footer text below structure</p> Source code in <code>himatcal/utils/mol/cirpy.py</code> <pre><code>def resolve_image(\n    input,\n    resolvers=None,\n    fmt=\"png\",\n    width=300,\n    height=300,\n    frame=False,\n    crop=None,\n    bgcolor=None,\n    atomcolor=None,\n    hcolor=None,\n    bondcolor=None,\n    framecolor=None,\n    symbolfontsize=11,\n    linewidth=2,\n    hsymbol=\"special\",\n    csymbol=\"special\",\n    stereolabels=False,\n    stereowedges=True,\n    header=None,\n    footer=None,\n    **kwargs,\n):\n    \"\"\"Resolve input to a 2D image depiction.\n\n    :param string input: Chemical identifier to resolve\n    :param list(string) resolvers: (Optional) Ordered list of resolvers to use\n    :param string fmt: (Optional) gif or png image format (default png)\n\n    :param int width: (Optional) Image width in pixels (default 300)\n    :param int height: (Optional) Image height in pixels (default 300)\n    :param bool frame: (Optional) Whether to show border frame (default False)\n    :param int crop: (Optional) Crop image with specified padding\n\n    :param int symbolfontsize: (Optional) Atom label font size (default 11)\n    :param int linewidth: (Optional) Bond line width (default 2)\n\n    :param string bgcolor: (Optional) Background color\n    :param string atomcolor: (Optional) Atom label color\n    :param string hcolor: (Optional) Hydrogen atom label color\n    :param string bondcolor: (Optional) Bond color\n    :param string framecolor: (Optional) Border frame color\n\n    :param bool hsymbol: (Optional) Hydrogens: all, special or none (default special)\n    :param bool csymbol: (Optional) Carbons: all, special or none (default special)\n    :param bool stereolabels: (Optional) Whether to show stereochemistry labels (default False)\n    :param bool stereowedges: (Optional) Whether to show wedge/dash bonds (default True)\n    :param string header: (Optional) Header text above structure\n    :param string footer: (Optional) Footer text below structure\n\n    \"\"\"\n    # Aggregate all arguments into kwargs\n    frame = inspect.currentframe()\n    if frame:\n        args, _, _, values = inspect.getargvalues(frame)\n        for arg in args:\n            if values[arg] is not None:\n                kwargs[arg] = values[arg]\n    else:\n        print(\"Could not get the current frame. Performing alternative action...\")\n    # Turn off anti-aliasing for transparent background\n    if kwargs.get(\"bgcolor\") == \"transparent\":\n        kwargs[\"antialiasing\"] = False\n    # Renamed parameters\n    if \"stereolabels\" in kwargs:\n        kwargs[\"showstereo\"] = kwargs.pop(\"stereolabels\")\n    if \"fmt\" in kwargs:\n        kwargs[\"format\"] = kwargs.pop(\"fmt\")\n    # Toggle stereo wedges\n    if \"stereowedges\" in kwargs:\n        status = kwargs.pop(\"stereowedges\")\n        kwargs.update({\"wedges\": status, \"dashes\": status})\n    # Constant values\n    kwargs.update({\"representation\": \"image\", \"xml\": False})\n    url = construct_api_url(**kwargs)\n    log.debug(\"Making image request: %s\", url)\n    response = urlopen(url)\n    return response.read()\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html","title":"coord_utils","text":"<p>https://github.com/virtualzx-nad/geodesic-interpolate/blob/master/geodesic_interpolate/coord_utils.py Coordinate utilities used by the interpolation program</p>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.ATOMIC_RADIUS","title":"ATOMIC_RADIUS  <code>module-attribute</code>","text":"<pre><code>ATOMIC_RADIUS = dict(H=0.31, He=0.28, Li=1.28, Be=0.96, B=0.84, C=0.76, N=0.71, O=0.66, F=0.57, Ne=0.58, Na=1.66, Mg=1.41, Al=1.21, Si=1.11, P=1.07, S=1.05, Cl=1.02, Ar=1.06)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.align_geom","title":"align_geom","text":"<pre><code>align_geom(refgeom, geom)\n</code></pre> <p>Find translation/rotation that moves a given geometry to maximally overlap with a reference geometry. Implemented with Kabsch algorithm.</p> <p>Args:     refgeom:    The reference geometry to be rotated to     geom:       The geometry to be rotated and shifted</p> <p>Returns:     RMSD:       Root-mean-squared difference between the rotated geometry                 and the reference     new_geom:   The rotated geometry that maximumally overal with the reference</p> Source code in <code>himatcal/utils/neb/coord_utils.py</code> <pre><code>def align_geom(refgeom, geom):\n    \"\"\"Find translation/rotation that moves a given geometry to maximally overlap\n    with a reference geometry. Implemented with Kabsch algorithm.\n\n    Args:\n        refgeom:    The reference geometry to be rotated to\n        geom:       The geometry to be rotated and shifted\n\n    Returns:\n        RMSD:       Root-mean-squared difference between the rotated geometry\n                    and the reference\n        new_geom:   The rotated geometry that maximumally overal with the reference\n    \"\"\"\n    center = np.mean(refgeom, axis=0)  # Find the geometric center\n    ref2 = refgeom - center\n    geom2 = geom - np.mean(geom, axis=0)\n    cov = np.dot(geom2.T, ref2)\n    v, sv, w = np.linalg.svd(cov)\n    if np.linalg.det(v) * np.linalg.det(w) &lt; 0:\n        sv[-1] = -sv[-1]\n        v[:, -1] = -v[:, -1]\n    u = np.dot(v, w)\n    new_geom = np.dot(geom2, u) + center\n    rmsd = np.sqrt(np.mean((new_geom - refgeom) ** 2))\n    return rmsd, new_geom\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.align_path","title":"align_path","text":"<pre><code>align_path(path)\n</code></pre> <p>Rotate and translate images to minimize RMSD movements along the path. Also moves the geometric center of all images to the origin.</p> Source code in <code>himatcal/utils/neb/coord_utils.py</code> <pre><code>def align_path(path):\n    \"\"\"Rotate and translate images to minimize RMSD movements along the path.\n    Also moves the geometric center of all images to the origin.\n    \"\"\"\n    path = np.array(path)\n    path[0] -= np.mean(path[0], axis=0)\n    max_rmsd = 0\n    for g, nextg in zip(path, path[1:]):\n        rmsd, nextg[:] = align_geom(g, nextg)\n        max_rmsd = max(max_rmsd, rmsd)\n    return max_rmsd, path\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.compute_rij","title":"compute_rij","text":"<pre><code>compute_rij(geom, rij_list)\n</code></pre> <p>Calculate a list of distances and their derivatives</p> <p>Takes a set of cartesian geometries then calculate selected distances and their cartesian gradients given a list of atom pairs.</p> <p>Args:     geom: Cartesian geometry of all the points.  Must be 2d numpy array or list         with shape (natoms, 3)     rij_list: list of indexes of all the atom pairs</p> <p>Returns:     rij (array): Array of all the distances.     bmat (3d array): Cartesian gradients of all the distances.</p> Source code in <code>himatcal/utils/neb/coord_utils.py</code> <pre><code>def compute_rij(geom, rij_list):\n    \"\"\"Calculate a list of distances and their derivatives\n\n    Takes a set of cartesian geometries then calculate selected distances and their\n    cartesian gradients given a list of atom pairs.\n\n    Args:\n        geom: Cartesian geometry of all the points.  Must be 2d numpy array or list\n            with shape (natoms, 3)\n        rij_list: list of indexes of all the atom pairs\n\n    Returns:\n        rij (array): Array of all the distances.\n        bmat (3d array): Cartesian gradients of all the distances.\"\"\"\n    nrij = len(rij_list)\n    rij = np.zeros(nrij)\n    bmat = np.zeros((nrij, len(geom), 3))\n    for idx, (i, j) in enumerate(rij_list):\n        dvec = geom[i] - geom[j]\n        rij[idx] = r = np.sqrt(\n            dvec[0] * dvec[0] + dvec[1] * dvec[1] + dvec[2] * dvec[2]\n        )\n        grad = dvec / r\n        bmat[idx, i] = grad\n        bmat[idx, j] = -grad\n    return rij, bmat\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.compute_wij","title":"compute_wij","text":"<pre><code>compute_wij(geom, rij_list, func)\n</code></pre> <p>Calculate a list of scaled distances and their derivatives</p> <p>Takes a set of cartesian geometries then calculate selected distances and their cartesian gradients given a list of atom pairs.  The distances are scaled with a given scaling function.</p> <p>Args:     geom: Cartesian geometry of all the points.  Must be 2d numpy array or list         with shape (natoms, 3)     rij_list: 2d numpy array of indexes of all the atom pairs     func: A scaling function, which returns both the value and derivative.  Must         qualify as a numpy Ufunc in order to be broadcasted to array elements.</p> <p>Returns:     wij (array): Array of all the scaled distances.     bmat (2d array): Cartesian gradients of all the scaled distances, with the         second dimension flattened (need this to be used in scipy.optimize).</p> Source code in <code>himatcal/utils/neb/coord_utils.py</code> <pre><code>def compute_wij(geom, rij_list, func):\n    \"\"\"Calculate a list of scaled distances and their derivatives\n\n    Takes a set of cartesian geometries then calculate selected distances and their\n    cartesian gradients given a list of atom pairs.  The distances are scaled with\n    a given scaling function.\n\n    Args:\n        geom: Cartesian geometry of all the points.  Must be 2d numpy array or list\n            with shape (natoms, 3)\n        rij_list: 2d numpy array of indexes of all the atom pairs\n        func: A scaling function, which returns both the value and derivative.  Must\n            qualify as a numpy Ufunc in order to be broadcasted to array elements.\n\n    Returns:\n        wij (array): Array of all the scaled distances.\n        bmat (2d array): Cartesian gradients of all the scaled distances, with the\n            second dimension flattened (need this to be used in scipy.optimize).\"\"\"\n    geom = np.asarray(geom).reshape(-1, 3)\n    nrij = len(rij_list)\n    rij, bmat = compute_rij(geom, rij_list)\n    wij, dwdr = func(rij)\n    for idx, grad in enumerate(dwdr):\n        bmat[idx] *= grad\n    return wij, bmat.reshape(nrij, -1)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.elu_scaler","title":"elu_scaler","text":"<pre><code>elu_scaler(re=2, alpha=2, beta=0.01)\n</code></pre> <p>Returns a scaling function that determines the metric of the internal coordinates using morse potential</p> <p>Takes an internuclear distance, returns the scaled distance, and the derivative of the scaled distance with respect to the unscaled one.</p> Source code in <code>himatcal/utils/neb/coord_utils.py</code> <pre><code>def elu_scaler(re=2, alpha=2, beta=0.01):\n    \"\"\"Returns a scaling function that determines the metric of the internal\n    coordinates using morse potential\n\n    Takes an internuclear distance, returns the scaled distance, and the\n    derivative of the scaled distance with respect to the unscaled one.\n    \"\"\"\n\n    def scaler(x):\n        val1 = (1 - x / re) * alpha + 1\n        dval = np.full(x.shape, -alpha / re)\n        large = x &gt; re\n        v1l = np.exp(alpha * (1 - x[large] / re))\n        val1[large] = v1l\n        dval[large] = -alpha / re * v1l\n        val2 = beta * re / x\n        return val1 + val2, dval - val2 / x\n\n    return scaler\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.get_bond_list","title":"get_bond_list","text":"<pre><code>get_bond_list(geom, atoms=None, threshold=4, min_neighbors=4, snapshots=30, bond_threshold=1.8, enforce=())\n</code></pre> <p>Get the list of all the important atom pairs. Samples a number of snapshots from a list of geometries to generate all distances that are below a given threshold in any of them.</p> <p>Args:     atoms:      Symbols for each atoms.     geom:       One or a list of geometries to check for pairs     threshold:  Threshold for including a bond in the bond list     min_neighbors: Minimum number of neighbors to include for each atom.                 If an atom has smaller than this number of bonds, additional                 distances will be added to reach this number.     snapshots:  Number of snapshots to be used in the generation, useful                 for speeding up the process if the path is long and                 atoms numerous.</p> <p>Returns:     List of all the included interatomic distance pairs.</p> Source code in <code>himatcal/utils/neb/coord_utils.py</code> <pre><code>def get_bond_list(\n    geom,\n    atoms=None,\n    threshold=4,\n    min_neighbors=4,\n    snapshots=30,\n    bond_threshold=1.8,\n    enforce=(),\n):\n    \"\"\"Get the list of all the important atom pairs.\n    Samples a number of snapshots from a list of geometries to generate all\n    distances that are below a given threshold in any of them.\n\n    Args:\n        atoms:      Symbols for each atoms.\n        geom:       One or a list of geometries to check for pairs\n        threshold:  Threshold for including a bond in the bond list\n        min_neighbors: Minimum number of neighbors to include for each atom.\n                    If an atom has smaller than this number of bonds, additional\n                    distances will be added to reach this number.\n        snapshots:  Number of snapshots to be used in the generation, useful\n                    for speeding up the process if the path is long and\n                    atoms numerous.\n\n    Returns:\n        List of all the included interatomic distance pairs.\n    \"\"\"\n    # Type casting and value checks on input parameters\n    geom = np.asarray(geom)\n    if len(geom.shape) &lt; 3:\n        # If there is only one geometry or it is flattened, promote to 3d\n        geom = geom.reshape(1, -1, 3)\n    min_neighbors = min(min_neighbors, geom.shape[1] - 1)\n\n    # Determine which images to be used to determine distances\n    snapshots = min(len(geom), snapshots)\n    images = [0, len(geom) - 1]\n    if snapshots &gt; 2:\n        images.extend(\n            np.random.choice(range(1, snapshots - 1), snapshots - 2, replace=False)\n        )\n    # Get neighbor list for included geometry and merge them\n    rijset = set(enforce)\n    for image in images:\n        tree = KDTree(geom[image])\n        pairs = tree.query_pairs(threshold)\n        rijset.update(pairs)\n        bonded = tree.query_pairs(bond_threshold)\n        neighbors = {i: {i} for i in range(geom.shape[1])}\n        for i, j in bonded:\n            neighbors[i].add(j)\n            neighbors[j].add(i)\n        for i, j in bonded:\n            for ni in neighbors[i]:\n                for nj in neighbors[j]:\n                    if ni != nj:\n                        pair = tuple(sorted([ni, nj]))\n                        if pair not in rijset:\n                            rijset.add(pair)\n    rijlist = sorted(rijset)\n    # Check neighbor count to make sure `min_neighbors` is satisfied\n    count = np.zeros(geom.shape[1], dtype=int)\n    for i, j in rijlist:\n        count[i] += 1\n        count[j] += 1\n    for idx, ct in enumerate(count):\n        if ct &lt; min_neighbors:\n            _, neighbors = tree.query(geom[-1, idx], k=min_neighbors + 1)\n            for i in neighbors:\n                if i == idx:\n                    continue\n                pair = tuple(sorted([i, idx]))\n                if pair in rijset:\n                    continue\n                else:\n                    rijset.add(pair)\n                    rijlist.append(pair)\n                    count[i] += 1\n                    count[idx] += 1\n    if atoms is None:\n        re = np.full(len(rijlist), 2.0)\n    else:\n        radius = np.array([ATOMIC_RADIUS.get(atom.capitalize(), 1.5) for atom in atoms])\n        re = np.array([radius[i] + radius[j] for i, j in rijlist])\n    logger.debug(\"Pair list contain %d pairs\", len(rijlist))\n    return rijlist, re\n</code></pre>"},{"location":"reference/himatcal/utils/neb/coord_utils.html#himatcal.utils.neb.coord_utils.morse_scaler","title":"morse_scaler","text":"<pre><code>morse_scaler(re=1.5, alpha=1.7, beta=0.01)\n</code></pre> <p>Returns a scaling function that determines the metric of the internal coordinates using morse potential</p> <p>Takes an internuclear distance, returns the scaled distance, and the derivative of the scaled distance with respect to the unscaled one.</p> Source code in <code>himatcal/utils/neb/coord_utils.py</code> <pre><code>def morse_scaler(re=1.5, alpha=1.7, beta=0.01):\n    \"\"\"Returns a scaling function that determines the metric of the internal\n    coordinates using morse potential\n\n    Takes an internuclear distance, returns the scaled distance, and the\n    derivative of the scaled distance with respect to the unscaled one.\n    \"\"\"\n\n    def scaler(x):\n        ratio = x / re\n        val1 = np.exp(alpha * (1 - ratio))\n        val2 = beta / ratio\n        dval = -alpha / re * val1 - val2 / x\n        return val1 + val2, dval\n\n    return scaler\n</code></pre>"},{"location":"reference/himatcal/utils/neb/core.html","title":"core","text":""},{"location":"reference/himatcal/utils/neb/core.html#himatcal.utils.neb.core._geodesic_interpolate_wrapper","title":"_geodesic_interpolate_wrapper","text":"<pre><code>_geodesic_interpolate_wrapper(reactant: Atoms, product: Atoms, n_images: int = 20, perform_sweep: bool | None = None, convergence_tolerance: float = 0.002, max_iterations: int = 15, max_micro_iterations: int = 20, morse_scaling: float = 1.7, geometry_friction: float = 0.01, distance_cutoff: float = 3.0) -&gt; list[Atoms]\n</code></pre> <p>Interpolates between two geometries and optimizes the path with the geodesic method.</p> <p>Parameters:</p> <ul> <li> <code>reactant</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object representing the initial geometry.</p> </li> <li> <code>product</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object representing the final geometry.</p> </li> <li> <code>n_images</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Number of images for interpolation. Default is 20.</p> </li> <li> <code>perform_sweep</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether to sweep across the path optimizing one image at a time. Default is to perform sweeping updates if there are more than 35 atoms.</p> </li> <li> <code>convergence_tolerance</code>               (<code>float</code>, default:                   <code>0.002</code> )           \u2013            <p>Convergence tolerance. Default is 2e-3.</p> </li> <li> <code>max_iterations</code>               (<code>int</code>, default:                   <code>15</code> )           \u2013            <p>Maximum number of minimization iterations. Default is 15.</p> </li> <li> <code>max_micro_iterations</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Maximum number of micro iterations for the sweeping algorithm. Default is 20.</p> </li> <li> <code>morse_scaling</code>               (<code>float</code>, default:                   <code>1.7</code> )           \u2013            <p>Exponential parameter for the Morse potential. Default is 1.7.</p> </li> <li> <code>geometry_friction</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Size of friction term used to prevent very large changes in geometry. Default is 1e-2.</p> </li> <li> <code>distance_cutoff</code>               (<code>float</code>, default:                   <code>3.0</code> )           \u2013            <p>Cut-off value for the distance between a pair of atoms to be included in the coordinate system. Default is 3.0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Atoms]</code>           \u2013            <p>A list of ASE Atoms objects representing the smoothed path between the reactant and product geometries.</p> </li> </ul> Source code in <code>himatcal/utils/neb/core.py</code> <pre><code>def _geodesic_interpolate_wrapper(\n    reactant: Atoms,\n    product: Atoms,\n    n_images: int = 20,\n    perform_sweep: bool | None = None,\n    convergence_tolerance: float = 2e-3,\n    max_iterations: int = 15,\n    max_micro_iterations: int = 20,\n    morse_scaling: float = 1.7,\n    geometry_friction: float = 1e-2,\n    distance_cutoff: float = 3.0,\n) -&gt; list[Atoms]:\n    \"\"\"\n    Interpolates between two geometries and optimizes the path with the geodesic method.\n\n    Parameters\n    ----------\n    reactant\n        The ASE Atoms object representing the initial geometry.\n    product\n        The ASE Atoms object representing the final geometry.\n    n_images\n        Number of images for interpolation. Default is 20.\n    perform_sweep\n        Whether to sweep across the path optimizing one image at a time.\n        Default is to perform sweeping updates if there are more than 35 atoms.\n    convergence_tolerance\n        Convergence tolerance. Default is 2e-3.\n    max_iterations\n        Maximum number of minimization iterations. Default is 15.\n    max_micro_iterations\n        Maximum number of micro iterations for the sweeping algorithm. Default is 20.\n    morse_scaling\n        Exponential parameter for the Morse potential. Default is 1.7.\n    geometry_friction\n        Size of friction term used to prevent very large changes in geometry. Default is 1e-2.\n    distance_cutoff\n        Cut-off value for the distance between a pair of atoms to be included in the coordinate system. Default is 3.0.\n\n    Returns\n    -------\n    list[Atoms]\n        A list of ASE Atoms objects representing the smoothed path between the reactant and product geometries.\n    \"\"\"\n    reactant = copy_atoms(reactant)\n    product = copy_atoms(product)\n\n    # Read the initial geometries.\n    chemical_symbols = reactant.get_chemical_symbols()\n\n    # First redistribute number of images. Perform interpolation if too few and subsampling if too many images are given\n    raw_interpolated_positions = redistribute(\n        chemical_symbols,\n        [reactant.positions, product.positions],\n        n_images,\n        tol=convergence_tolerance * 5,\n    )\n\n    # Perform smoothing by minimizing distance in Cartesian coordinates with redundant internal metric\n    # to find the appropriate geodesic curve on the hyperspace.\n    geodesic_smoother = Geodesic(\n        chemical_symbols,\n        raw_interpolated_positions,\n        morse_scaling,\n        threshold=distance_cutoff,\n        friction=geometry_friction,\n    )\n    if perform_sweep is None:\n        perform_sweep = len(chemical_symbols) &gt; 35\n    if perform_sweep:\n        geodesic_smoother.sweep(\n            tol=convergence_tolerance,\n            max_iter=max_iterations,\n            micro_iter=max_micro_iterations,\n        )\n    else:\n        geodesic_smoother.smooth(tol=convergence_tolerance, max_iter=max_iterations)\n    return [\n        Atoms(symbols=chemical_symbols, positions=geom)\n        for geom in geodesic_smoother.path\n    ]\n</code></pre>"},{"location":"reference/himatcal/utils/neb/core.html#himatcal.utils.neb.core.run_neb","title":"run_neb","text":"<pre><code>run_neb(images: list[Atoms], relax_cell: bool = False, fmax: float = 0.01, max_steps: int | None = 1000, optimizer: NEBOptimizer | Optimizer = MDMin, optimizer_kwargs: dict[str, Any] | None = None, run_kwargs: dict[str, Any] | None = None, neb_kwargs: dict[str, Any] | None = None, copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None) -&gt; Optimizer\n</code></pre> <p>Run NEB optimization.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>list[Atoms]</code>)           \u2013            <p>List of images representing the initial path.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to relax the unit cell shape and volume.</p> </li> <li> <code>fmax</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Tolerance for the force convergence (in eV/A).</p> </li> <li> <code>max_steps</code>               (<code>int | None</code>, default:                   <code>1000</code> )           \u2013            <p>Maximum number of steps to take.</p> </li> <li> <code>optimizer</code>               (<code>NEBOptimizer | Optimizer</code>, default:                   <code>MDMin</code> )           \u2013            <p>Optimizer class to use. All Optimizers except BFGSLineSearch</p> </li> <li> <code>optimizer_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the optimizer.</p> </li> <li> <code>run_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the run() method of the optimizer.</p> </li> <li> <code>neb_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of kwargs for the NEB.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy before running the calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optimizer</code>           \u2013            <p>The ASE Optimizer object.</p> </li> </ul> Source code in <code>himatcal/utils/neb/core.py</code> <pre><code>def run_neb(\n    images: list[Atoms],\n    relax_cell: bool = False,\n    fmax: float = 0.01,\n    max_steps: int | None = 1000,\n    optimizer: NEBOptimizer | Optimizer = MDMin,\n    optimizer_kwargs: dict[str, Any] | None = None,\n    run_kwargs: dict[str, Any] | None = None,\n    neb_kwargs: dict[str, Any] | None = None,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n) -&gt; Optimizer:\n    \"\"\"\n    Run NEB optimization.\n\n    Parameters\n    ----------\n    images\n        List of images representing the initial path.\n    relax_cell\n        Whether to relax the unit cell shape and volume.\n    fmax\n        Tolerance for the force convergence (in eV/A).\n    max_steps\n        Maximum number of steps to take.\n    optimizer\n        Optimizer class to use. All Optimizers except BFGSLineSearch\n    optimizer_kwargs\n        Dictionary of kwargs for the optimizer.\n    run_kwargs\n        Dictionary of kwargs for the run() method of the optimizer.\n    neb_kwargs\n        Dictionary of kwargs for the NEB.\n    copy_files\n        Files to copy before running the calculation.\n\n    Returns\n    -------\n    Optimizer\n        The ASE Optimizer object.\n    \"\"\"\n    if optimizer.__name__ == \"BFGSLineSearch\":\n        raise ValueError(\"BFGSLineSearch is not allowed as optimizer with NEB.\")\n    # Copy atoms so we don't modify it in-place\n    images = copy_atoms(images)\n    # settings = get_settings()\n\n    neb = NEB(images, **neb_kwargs)\n\n    dir_lists = []\n    # Perform staging operations\n    # this calc_setup function is not suited for multiple Atoms objects\n    for image in images:\n        tmpdir_i, job_results_dir_i = calc_setup(image, copy_files=copy_files)\n        dir_lists.append([tmpdir_i, job_results_dir_i])\n\n    # Set defaults\n    optimizer_kwargs = recursive_dict_merge(\n        {\n            \"logfile\": dir_lists[0][0] / \"opt.log\",\n            \"restart\": dir_lists[0][0] / \"opt.json\",\n        },\n        optimizer_kwargs,\n    )\n    run_kwargs = run_kwargs or {}\n    traj_filename = \"opt.traj\"\n    # Check if trajectory kwarg is specified\n    if \"trajectory\" in optimizer_kwargs:\n        msg = \"Quacc does not support setting the `trajectory` kwarg.\"\n        raise ValueError(msg)\n\n    # Define the Trajectory object\n    traj_file = dir_lists[0][0] / traj_filename\n    traj = Trajectory(traj_file, \"w\", atoms=neb)\n\n    # Set volume relaxation constraints, if relevant\n    for i in range(len(images)):\n        if relax_cell and images[i].pbc.any():\n            images[i] = FrechetCellFilter(images[i])\n\n    # Run optimization\n    dyn = optimizer(neb, **optimizer_kwargs)\n    dyn.attach(traj.write)\n\n    dyn.run(fmax, max_steps)\n    traj.close()\n\n    traj.filename = traj_file\n    dyn.trajectory = traj\n\n    # Perform cleanup operations skipping the first images's directory\n    # because that is where the trajectory is stored. It will get deleted\n    # eventually.\n    for i, image in enumerate(images[1:], start=1):\n        calc_cleanup(image, dir_lists[i][0], dir_lists[i][1])\n\n    return dyn\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html","title":"geodesic","text":"<p>https://github.com/virtualzx-nad/geodesic-interpolate/blob/master/geodesic_interpolate/geodesic.py Geodesic smoothing.   Minimize the path length using redundant internal coordinate metric to find geodesics directly in Cartesian, to avoid feasibility problems associated with redundant internals.</p>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic","title":"Geodesic","text":"<pre><code>Geodesic(atoms, path, scaler=1.7, threshold=3, min_neighbors=4, log_level=INFO, friction=0.001)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Optimizer to obtain geodesic in redundant internal coordinates.  Core part is the calculation of the path length in the internal metric.</p> <pre><code>atoms:      Atom symbols, used to lookup radii\npath:       Initial geometries of the path, must be of dimension `nimage * natoms * 3`\nscaler:     Either the alpha parameter for morse potential, or an explicit scaling function.\n            It is easier to get smoother paths with small number of data points using small\n            scaling factors, as they have large range, but larger values usually give\n            better energetics because they better represent the (sharp) energy landscape.\nthreshold:  Distance cut-off for constructing inter-nuclear distance coordinates.  Note that\n            any atoms linked by three or less bonds will also be added.\nmin_neighbors:  Minimum number of neighbors an atom must have in the atom pair list.\nlog_level:  Logging level to use.\nfriction:   Friction term in the target function which regularizes the optimization step\n            size to prevent explosion.\n</code></pre> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def __init__(\n    self,\n    atoms,\n    path,\n    scaler=1.7,\n    threshold=3,\n    min_neighbors=4,\n    log_level=logging.INFO,\n    friction=1e-3,\n):\n    \"\"\"Initialize the interpolater\n    Args:\n        atoms:      Atom symbols, used to lookup radii\n        path:       Initial geometries of the path, must be of dimension `nimage * natoms * 3`\n        scaler:     Either the alpha parameter for morse potential, or an explicit scaling function.\n                    It is easier to get smoother paths with small number of data points using small\n                    scaling factors, as they have large range, but larger values usually give\n                    better energetics because they better represent the (sharp) energy landscape.\n        threshold:  Distance cut-off for constructing inter-nuclear distance coordinates.  Note that\n                    any atoms linked by three or less bonds will also be added.\n        min_neighbors:  Minimum number of neighbors an atom must have in the atom pair list.\n        log_level:  Logging level to use.\n        friction:   Friction term in the target function which regularizes the optimization step\n                    size to prevent explosion.\n    \"\"\"\n    rmsd0, self.path = align_path(path)\n    logger.log(log_level, \"Maximum RMSD change in initial path: %10.2f\", rmsd0)\n    if self.path.ndim != 3:\n        raise ValueError(\"The path to be interpolated must have 3 dimensions\")\n    self.nimages, self.natoms, _ = self.path.shape\n    # Construct coordinates\n    self.rij_list, self.re = get_bond_list(\n        path, atoms, threshold=threshold, min_neighbors=min_neighbors\n    )\n    if isinstance(scaler, float):\n        self.scaler = morse_scaler(re=self.re, alpha=1.7)\n    else:\n        self.scaler = scaler\n    self.nrij = len(self.rij_list)\n    self.friction = friction\n    # Initalize interal storages for mid points, internal coordinates and B matrices\n    logger.log(log_level, \"Performing geodesic smoothing\")\n    logger.log(\n        log_level,\n        \"  Images: %4d  Atoms %4d Rijs %6d\",\n        self.nimages,\n        self.natoms,\n        len(self.rij_list),\n    )\n    self.neval = 0\n    self.w = [None] * len(path)\n    self.dwdR = [None] * len(path)\n    self.X_mid = [None] * (len(path) - 1)\n    self.w_mid = [None] * (len(path) - 1)\n    self.dwdR_mid = [None] * (len(path) - 1)\n    self.disps = self.grad = self.segment = None\n    self.conv_path = []\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.X_mid","title":"X_mid  <code>instance-attribute</code>","text":"<pre><code>X_mid = [None] * len(path) - 1\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.conv_path","title":"conv_path  <code>instance-attribute</code>","text":"<pre><code>conv_path = []\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.disps","title":"disps  <code>instance-attribute</code>","text":"<pre><code>disps = None\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.dwdR","title":"dwdR  <code>instance-attribute</code>","text":"<pre><code>dwdR = [None] * len(path)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.dwdR_mid","title":"dwdR_mid  <code>instance-attribute</code>","text":"<pre><code>dwdR_mid = [None] * len(path) - 1\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.friction","title":"friction  <code>instance-attribute</code>","text":"<pre><code>friction = friction\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.grad","title":"grad  <code>instance-attribute</code>","text":"<pre><code>grad = None\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.neval","title":"neval  <code>instance-attribute</code>","text":"<pre><code>neval = 0\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.nrij","title":"nrij  <code>instance-attribute</code>","text":"<pre><code>nrij = len(rij_list)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.scaler","title":"scaler  <code>instance-attribute</code>","text":"<pre><code>scaler = morse_scaler(re=re, alpha=1.7)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.segment","title":"segment  <code>instance-attribute</code>","text":"<pre><code>segment = None\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.w","title":"w  <code>instance-attribute</code>","text":"<pre><code>w = [None] * len(path)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.w_mid","title":"w_mid  <code>instance-attribute</code>","text":"<pre><code>w_mid = [None] * len(path) - 1\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.compute_disp_grad","title":"compute_disp_grad","text":"<pre><code>compute_disp_grad(start, end, friction=0.001)\n</code></pre> <p>Compute derivatives of the displacement vectors with respect to the Cartesian coordinates</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def compute_disp_grad(self, start, end, friction=1e-3):\n    \"\"\"Compute derivatives of the displacement vectors with respect to the Cartesian coordinates\"\"\"\n    # Calculate derivatives of displacement vectors with respect to image Cartesians\n    l = end - start + 1\n    self.grad = np.zeros(\n        (\n            l * 2 * self.nrij + 3 * (end - start) * self.natoms,\n            (end - start) * 3 * self.natoms,\n        )\n    )\n    self.grad0 = self.grad[: l * 2 * self.nrij]\n    grad_shape = (l, self.nrij, end - start, 3 * self.natoms)\n    grad_l = self.grad[: l * self.nrij].reshape(grad_shape)\n    grad_r = self.grad[l * self.nrij : l * self.nrij * 2].reshape(grad_shape)\n    for i, image in enumerate(range(start, end)):\n        dmid1 = self.dwdR_mid[image - 1] / 2\n        dmid2 = self.dwdR_mid[image] / 2\n        grad_l[i + 1, :, i, :] = dmid2 - self.dwdR[image]\n        grad_l[i, :, i, :] = dmid1\n        grad_r[i + 1, :, i, :] = -dmid2\n        grad_r[i, :, i, :] = self.dwdR[image] - dmid1\n    for idx in range((end - start) * 3 * self.natoms):\n        self.grad[l * self.nrij * 2 + idx, idx] = friction\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.compute_disps","title":"compute_disps","text":"<pre><code>compute_disps(start=1, end=-1, dx=None, friction=0.001)\n</code></pre> <p>Compute displacement vectors and total length between two images. Only recalculate internal coordinates if they are unknown.</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def compute_disps(self, start=1, end=-1, dx=None, friction=1e-3):\n    \"\"\"Compute displacement vectors and total length between two images.\n    Only recalculate internal coordinates if they are unknown.\"\"\"\n    if end &lt; 0:\n        end += self.nimages\n    self.update_intc()\n    # Calculate displacement vectors in each segment, and the total length\n    vecs_l = [\n        wm - wl\n        for wl, wm in zip(self.w[start - 1 : end], self.w_mid[start - 1 : end])\n    ]\n    vecs_r = [\n        wr - wm\n        for wr, wm in zip(self.w[start : end + 1], self.w_mid[start - 1 : end])\n    ]\n    self.length = np.sum(np.linalg.norm(vecs_l, axis=1)) + np.sum(\n        np.linalg.norm(vecs_r, axis=1)\n    )\n    if dx is None:\n        trans = np.zeros(self.path[start:end].size)\n    else:\n        trans = friction * dx  # Translation from initial geometry.  friction term\n    self.disps = np.concatenate(vecs_l + vecs_r + [trans])\n    self.disps0 = self.disps[: len(vecs_l) * 2]\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.compute_target_func","title":"compute_target_func","text":"<pre><code>compute_target_func(X=None, start=1, end=-1, log_level=INFO, x0=None, friction=0.001)\n</code></pre> <p>Compute the vectorized target function, which is then used for least squares minimization.</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def compute_target_func(\n    self, X=None, start=1, end=-1, log_level=logging.INFO, x0=None, friction=1e-3\n):\n    \"\"\"Compute the vectorized target function, which is then used for least\n    squares minimization.\"\"\"\n    if end &lt; 0:\n        end += self.nimages\n    if (\n        X is not None\n        and not self.update_geometry(X, start, end)\n        and self.segment == (start, end)\n    ):\n        return\n    self.segment = start, end\n    dx = (\n        np.zeros(self.path[start:end].size)\n        if x0 is None\n        else self.path[start:end].ravel() - x0.ravel()\n    )\n    self.compute_disps(start, end, dx=dx, friction=friction)\n    self.compute_disp_grad(start, end, friction=friction)\n    self.optimality = np.linalg.norm(\n        np.einsum(\"i,i...\", self.disps, self.grad), ord=np.inf\n    )\n    logger.log(\n        log_level,\n        \"  Iteration %3d: Length %10.3f |dL|=%7.3e\",\n        self.neval,\n        self.length,\n        self.optimality,\n    )\n    self.conv_path.append(self.path[1].copy())\n    self.neval += 1\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.smooth","title":"smooth","text":"<pre><code>smooth(tol=0.001, max_iter=50, start=1, end=-1, log_level=INFO, friction=None, xref=None)\n</code></pre> <p>Minimize the path length as an overall function of the coordinates of all the images. This should in principle be very efficient, but may be quite costly for large systems with many images.</p> <p>Args:     tol:        Convergence tolerance of the optimality. (.i.e uniform gradient of target func)     max_iter:   Maximum number of iterations to run.     start, end: Specify which section of the path to optimize.     log_level:  Logging level during the optimization</p> <p>Returns:     The optimized path.  This is also stored in self.path</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def smooth(\n    self,\n    tol=1e-3,\n    max_iter=50,\n    start=1,\n    end=-1,\n    log_level=logging.INFO,\n    friction=None,\n    xref=None,\n):\n    \"\"\"Minimize the path length as an overall function of the coordinates of all the images.\n    This should in principle be very efficient, but may be quite costly for large systems with\n    many images.\n\n    Args:\n        tol:        Convergence tolerance of the optimality. (.i.e uniform gradient of target func)\n        max_iter:   Maximum number of iterations to run.\n        start, end: Specify which section of the path to optimize.\n        log_level:  Logging level during the optimization\n\n    Returns:\n        The optimized path.  This is also stored in self.path\n    \"\"\"\n    X0 = np.array(self.path[start:end]).ravel()\n    if xref is None:\n        xref = X0\n    self.disps = self.grad = self.segment = None\n    logger.log(log_level, \"  Degree of freedoms %6d: \", len(X0))\n    if friction is None:\n        friction = self.friction\n    # Configure the keyword arguments that will be sent to the target function.\n    kwargs = dict(\n        start=start, end=end, log_level=log_level, x0=xref, friction=friction\n    )\n    self.compute_target_func(**kwargs)  # Compute length and optimality\n    if self.optimality &gt; tol:\n        result = least_squares(\n            self.target_func,\n            X0,\n            self.target_deriv,\n            ftol=tol,\n            gtol=tol,\n            max_nfev=max_iter,\n            kwargs=kwargs,\n            loss=\"soft_l1\",\n        )\n        self.update_geometry(result[\"x\"], start, end)\n        logger.log(\n            log_level, \"Smoothing converged after %d iterations\", result[\"nfev\"]\n        )\n    else:\n        logger.log(log_level, \"Skipping smoothing: path already optimal.\")\n    rmsd, self.path = align_path(self.path)\n    logger.log(\n        log_level,\n        \"Final path length: %12.5f  Max RMSD in path: %10.2f\",\n        self.length,\n        rmsd,\n    )\n    return self.path\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.sweep","title":"sweep","text":"<pre><code>sweep(tol=0.001, max_iter=50, micro_iter=20, start=1, end=-1)\n</code></pre> <p>Minimize the path length by adjusting one image at a time and sweeping the optimization side across the chain.  This is not as efficient, but scales much more friendly with the size of the system given the slowness of scipy's optimizers.  Also allows more detailed control and easy way of skipping nearly optimal points than the overall case.</p> <p>Args:     tol:        Convergence tolerance of the optimality. (.i.e uniform gradient of target func)     max_iter:   Maximum number of sweeps through the path.     micro_iter: Number of micro-iterations to be performed when optimizing each image.     start, end: Specify which section of the path to optimize.     log_level:  Logging level during the optimization</p> <p>Returns:     The optimized path.  This is also stored in self.path</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def sweep(self, tol=1e-3, max_iter=50, micro_iter=20, start=1, end=-1):\n    \"\"\"Minimize the path length by adjusting one image at a time and sweeping the optimization\n    side across the chain.  This is not as efficient, but scales much more friendly with the\n    size of the system given the slowness of scipy's optimizers.  Also allows more detailed\n    control and easy way of skipping nearly optimal points than the overall case.\n\n    Args:\n        tol:        Convergence tolerance of the optimality. (.i.e uniform gradient of target func)\n        max_iter:   Maximum number of sweeps through the path.\n        micro_iter: Number of micro-iterations to be performed when optimizing each image.\n        start, end: Specify which section of the path to optimize.\n        log_level:  Logging level during the optimization\n\n    Returns:\n        The optimized path.  This is also stored in self.path\n    \"\"\"\n    if end &lt; 0:\n        end = self.nimages + end\n    self.neval = 0\n    images = range(start, end)\n    logger.info(\"  Degree of freedoms %6d: \", (end - start) * 3 * self.natoms)\n    # Microiteration convergence tolerances are adjusted on the fly based on level of convergence.\n    curr_tol = tol * 10\n    self.compute_disps()  # Compute and print the initial path length\n    logger.info(\"  Initial length: %8.3f\", self.length)\n    for iteration in range(max_iter):\n        max_dL = 0\n        X0 = self.path.copy()\n        for i in images[:-1]:  # Use self.smooth() to optimize individual images\n            xmid = (self.path[i - 1] + self.path[i + 1]) * 0.5\n            self.smooth(\n                curr_tol,\n                max_iter=min(micro_iter, iteration + 6),\n                start=i,\n                end=i + 1,\n                log_level=logging.DEBUG,\n                friction=self.friction if iteration else 0.1,\n                xref=xmid,\n            )\n            max_dL = max(max_dL, self.optimality)\n        self.compute_disps()  # Compute final length after sweep\n        logger.info(\n            \"Sweep %3d: L=%7.2f dX=%7.2e tol=%7.3e dL=%7.3e\",\n            iteration,\n            self.length,\n            np.linalg.norm(self.path - X0),\n            curr_tol,\n            max_dL,\n        )\n        if max_dL &lt; tol:  # Check for convergence.\n            logger.info(\"Optimization converged after %d iteartions\", iteration)\n            break\n        curr_tol = max(tol * 0.5, max_dL * 0.2)  # Adjust micro-iteration threshold\n        images = list(reversed(images))  # Alternate sweeping direction.\n    else:\n        logger.info(\"Optimization not converged after %d iteartions\", iteration)\n    rmsd, self.path = align_path(self.path)\n    logger.info(\n        \"Final path length: %12.5f  Max RMSD in path: %10.2f\", self.length, rmsd\n    )\n    return self.path\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.target_deriv","title":"target_deriv","text":"<pre><code>target_deriv(X, **kwargs)\n</code></pre> <p>Wrapper around <code>compute_target_func</code> to prevent repeated evaluation at the same geometry</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def target_deriv(self, X, **kwargs):\n    \"\"\"Wrapper around `compute_target_func` to prevent repeated evaluation at\n    the same geometry\"\"\"\n    self.compute_target_func(X, **kwargs)\n    return self.grad\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.target_func","title":"target_func","text":"<pre><code>target_func(X, **kwargs)\n</code></pre> <p>Wrapper around <code>compute_target_func</code> to prevent repeated evaluation at the same geometry</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def target_func(self, X, **kwargs):\n    \"\"\"Wrapper around `compute_target_func` to prevent repeated evaluation at\n    the same geometry\"\"\"\n    self.compute_target_func(X, **kwargs)\n    return self.disps\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.update_geometry","title":"update_geometry","text":"<pre><code>update_geometry(X, start, end)\n</code></pre> <p>Update the geometry of a segment of the path, then set the corresponding internal coordinate, derivatives and midpoint locations to unknown</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def update_geometry(self, X, start, end):\n    \"\"\"Update the geometry of a segment of the path, then set the corresponding internal\n    coordinate, derivatives and midpoint locations to unknown\"\"\"\n    X = X.reshape(self.path[start:end].shape)\n    if np.array_equal(X, self.path[start:end]):\n        return False\n    self.path[start:end] = X\n    for i in range(start, end):\n        self.w_mid[i] = self.w[i] = None\n    self.w_mid[start - 1] = None\n    return True\n</code></pre>"},{"location":"reference/himatcal/utils/neb/geodesic.html#himatcal.utils.neb.geodesic.Geodesic.update_intc","title":"update_intc","text":"<pre><code>update_intc()\n</code></pre> <p>Adjust unknown locations of mid points and compute missing values of internal coordinates and their derivatives.  Any missing values will be marked with None values in internal storage, and this routine finds and calculates them.  This is to avoid redundant evaluation of value and gradients of internal coordinates.</p> Source code in <code>himatcal/utils/neb/geodesic.py</code> <pre><code>def update_intc(self):\n    \"\"\"Adjust unknown locations of mid points and compute missing values of internal coordinates\n    and their derivatives.  Any missing values will be marked with None values in internal storage,\n    and this routine finds and calculates them.  This is to avoid redundant evaluation of value and\n    gradients of internal coordinates.\"\"\"\n    for i, (X, w, dwdR) in enumerate(zip(self.path, self.w, self.dwdR)):\n        if w is None:\n            self.w[i], self.dwdR[i] = compute_wij(X, self.rij_list, self.scaler)\n    for i, (X0, X1, w) in enumerate(zip(self.path, self.path[1:], self.w_mid)):\n        if w is None:\n            self.X_mid[i] = Xm = (X0 + X1) / 2\n            self.w_mid[i], self.dwdR_mid[i] = compute_wij(\n                Xm, self.rij_list, self.scaler\n            )\n</code></pre>"},{"location":"reference/himatcal/utils/neb/interpolation.html","title":"interpolation","text":"<p>https://github.com/virtualzx-nad/geodesic-interpolate/blob/master/geodesic_interpolate/interpolation.py Simplified geodesic interpolations module, which uses geodesic lengths as criteria to add bisection points until point count meet desired number. Will need another following geodesic smoothing to get final path.</p>"},{"location":"reference/himatcal/utils/neb/interpolation.html#himatcal.utils.neb.interpolation.logger","title":"logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/himatcal/utils/neb/interpolation.html#himatcal.utils.neb.interpolation.mid_point","title":"mid_point","text":"<pre><code>mid_point(atoms, geom1, geom2, tol=0.01, nudge=0.01, threshold=4)\n</code></pre> <p>Find the Cartesian geometry that has internal coordinate values closest to the average of two geometries.</p> <p>Simply perform a least-squares minimization on the difference between the current internal and the average of the two end points.  This is done twice, using either end point as the starting guess.  DON'T USE THE CARTESIAN AVERAGE AS GUESS, THINGS WILL BLOW UP.</p> <p>This is used to generate an initial guess path for the later smoothing routine. Genenrally, the added point may not be continuous with the both end points, but provides a good enough starting guess.</p> <p>Random nudges are added to the initial geometry, so running multiple times may not yield the same converged geometry. For larger systems, one will never get the same geometry twice.  So one may want to perform multiple runs and check which yields the best result.</p> <p>Args:     geom1, geom2:   Cartesian geometry of the end points     tol:    Convergence tolarnce for the least-squares minimization process     nudge:  Random nudges added to the initial geometry, which helps to discover different             solutions.  Also helps in cases where optimal paths break the symmetry.     threshold:  Threshold for including an atom-pair in the coordinate system</p> <p>Returns:     Optimized mid-point which bisects the two endpoints in internal coordinates</p> Source code in <code>himatcal/utils/neb/interpolation.py</code> <pre><code>def mid_point(atoms, geom1, geom2, tol=1e-2, nudge=0.01, threshold=4):\n    \"\"\"Find the Cartesian geometry that has internal coordinate values closest to the average of\n    two geometries.\n\n    Simply perform a least-squares minimization on the difference between the current internal\n    and the average of the two end points.  This is done twice, using either end point as the\n    starting guess.  DON'T USE THE CARTESIAN AVERAGE AS GUESS, THINGS WILL BLOW UP.\n\n    This is used to generate an initial guess path for the later smoothing routine.\n    Genenrally, the added point may not be continuous with the both end points, but\n    provides a good enough starting guess.\n\n    Random nudges are added to the initial geometry, so running multiple times may not yield\n    the same converged geometry. For larger systems, one will never get the same geometry\n    twice.  So one may want to perform multiple runs and check which yields the best result.\n\n    Args:\n        geom1, geom2:   Cartesian geometry of the end points\n        tol:    Convergence tolarnce for the least-squares minimization process\n        nudge:  Random nudges added to the initial geometry, which helps to discover different\n                solutions.  Also helps in cases where optimal paths break the symmetry.\n        threshold:  Threshold for including an atom-pair in the coordinate system\n\n    Returns:\n        Optimized mid-point which bisects the two endpoints in internal coordinates\n    \"\"\"\n    # Process the initial geometries, construct coordinate system and obtain average internals\n    geom1, geom2 = np.array(geom1), np.array(geom2)\n    add_pair = set()\n    geom_list = [geom1, geom2]\n    # This loop is for ensuring a sufficient large coordinate system.  The interpolated point may\n    # have atom pairs in contact that are far away at both end-points, which may cause collision.\n    # One can include all atom pairs, but this may blow up for large molecules.  Here the compromise\n    # is to use a screened list of atom pairs first, then add more if additional atoms come into\n    # contant, then rerun the minimization until the coordinate system is consistant with the\n    # interpolated geometry\n    while True:\n        rijlist, re = get_bond_list(\n            geom_list, threshold=threshold + 1, enforce=add_pair\n        )\n        scaler = morse_scaler(alpha=0.7, re=re)\n        w1, _ = compute_wij(geom1, rijlist, scaler)\n        w2, _ = compute_wij(geom2, rijlist, scaler)\n        w = (w1 + w2) / 2\n        d_min, x_min = np.inf, None\n        friction = 0.1 / np.sqrt(geom1.shape[0])\n\n        def target_func(X):\n            \"\"\"Squared difference with reference w0\"\"\"\n            wx, dwdR = compute_wij(X, rijlist, scaler)\n            delta_w = wx - w\n            val, grad = (\n                0.5 * np.dot(delta_w, delta_w),\n                np.einsum(\"i,ij-&gt;j\", delta_w, dwdR),\n            )\n            logger.info(\"val=%10.3f  \", val)\n            return val, grad\n\n        # The inner loop performs minimization using either end-point as the starting guess.\n        for coef in [0.02, 0.98]:\n            x0 = (geom1 * coef + (1 - coef) * geom2).ravel()\n            x0 += nudge * np.random.random_sample(x0.shape)\n            logger.debug(\n                \"Starting least-squares minimization of bisection point at %7.2f.\", coef\n            )\n            result = least_squares(\n                lambda x: np.concatenate(\n                    [compute_wij(x, rijlist, scaler)[0] - w, (x - x0) * friction]\n                ),\n                x0,\n                lambda x: np.vstack(\n                    [compute_wij(x, rijlist, scaler)[1], np.identity(x.size) * friction]\n                ),\n                ftol=tol,\n                gtol=tol,\n            )\n            x_mid = result[\"x\"].reshape(-1, 3)\n            # Take the interpolated geometry, construct new pair list and check for new contacts\n            new_list = geom_list + [x_mid]\n            new_rij, _ = get_bond_list(new_list, threshold=threshold, min_neighbors=0)\n            extras = set(new_rij) - set(rijlist)\n            if extras:\n                logger.info(\n                    \"  Screened pairs came into contact. Adding reference point.\"\n                )\n                # Update pair list then go back to the minimization loop if new contacts are found\n                geom_list = new_list\n                add_pair |= extras\n                break\n            # Perform local geodesic optimization for the new image.\n            smoother = Geodesic(\n                atoms,\n                [geom1, x_mid, geom2],\n                0.7,\n                threshold=threshold,\n                log_level=logging.DEBUG,\n                friction=1,\n            )\n            smoother.compute_disps()\n            width = max(\n                [np.sqrt(np.mean((g - smoother.path[1]) ** 2)) for g in [geom1, geom2]]\n            )\n            dist, x_mid = width + smoother.length, smoother.path[1]\n            logger.debug(\n                \"  Trial path length: %8.3f after %d iterations\", dist, result[\"nfev\"]\n            )\n            if dist &lt; d_min:\n                d_min, x_min = dist, x_mid\n        else:  # Both starting guesses finished without new atom pairs.  Minimization successful\n            break\n    return x_min\n</code></pre>"},{"location":"reference/himatcal/utils/neb/interpolation.html#himatcal.utils.neb.interpolation.redistribute","title":"redistribute","text":"<pre><code>redistribute(atoms, geoms, nimages, tol=0.01)\n</code></pre> <p>Add or remove images so that the path length matches the desired number.</p> <p>If the number is too few, new points are added by bisecting the largest RMSD. If too numerous, one image is removed at a time so that the new merged segment has the shortest RMSD.</p> <p>Args:     geoms:      Geometry of the original path.     nimages:    The desired number of images     tol:        Convergence tolerance for bisection.</p> <p>Returns:     An aligned and redistributed path with has the correct number of images.</p> Source code in <code>himatcal/utils/neb/interpolation.py</code> <pre><code>def redistribute(atoms, geoms, nimages, tol=1e-2):\n    \"\"\"Add or remove images so that the path length matches the desired number.\n\n    If the number is too few, new points are added by bisecting the largest RMSD. If too numerous,\n    one image is removed at a time so that the new merged segment has the shortest RMSD.\n\n    Args:\n        geoms:      Geometry of the original path.\n        nimages:    The desired number of images\n        tol:        Convergence tolerance for bisection.\n\n    Returns:\n        An aligned and redistributed path with has the correct number of images.\n    \"\"\"\n    _, geoms = align_path(geoms)\n    geoms = list(geoms)\n    # If there are too few images, add bisection points\n    while len(geoms) &lt; nimages:\n        dists = [np.sqrt(np.mean((g1 - g2) ** 2)) for g1, g2 in zip(geoms[1:], geoms)]\n        max_i = np.argmax(dists)\n        logger.info(\n            \"Inserting image between %d and %d with Cartesian RMSD %10.3f.  New length:%d\",\n            max_i,\n            max_i + 1,\n            dists[max_i],\n            len(geoms) + 1,\n        )\n        insertion = mid_point(atoms, geoms[max_i], geoms[max_i + 1], tol)\n        _, insertion = align_geom(geoms[max_i], insertion)\n        geoms.insert(max_i + 1, insertion)\n        geoms = list(align_path(geoms)[1])\n    # If there are too many images, remove points\n    while len(geoms) &gt; nimages:\n        dists = [np.sqrt(np.mean((g1 - g2) ** 2)) for g1, g2 in zip(geoms[2:], geoms)]\n        min_i = np.argmin(dists)\n        logger.info(\n            \"Removing image %d.  Cartesian RMSD of merged section %10.3f\",\n            min_i + 1,\n            dists[min_i],\n        )\n        del geoms[min_i + 1]\n        geoms = list(align_path(geoms)[1])\n    return geoms\n</code></pre>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html","title":"quacc_schemas","text":"<p>Schemas for storing ASE-based data. https://github.com/kumaranu/quacc/blob/mace_recipe/src/quacc/schemas/ase.py</p>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html#himatcal.utils.neb.quacc_schemas._summarize_ideal_gas_thermo","title":"_summarize_ideal_gas_thermo","text":"<pre><code>_summarize_ideal_gas_thermo(igt: IdealGasThermo, temperature: float = 298.15, pressure: float = 1.0, charge_and_multiplicity: tuple[int, int] | None = None) -&gt; ThermoSchema\n</code></pre> <p>Get tabulated results from an ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>igt</code>               (<code>IdealGasThermo</code>)           \u2013            <p>ASE IdealGasThermo object.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure in bar.</p> </li> <li> <code>charge_and_multiplicity</code>               (<code>tuple[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ThermoSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>himatcal/utils/neb/quacc_schemas.py</code> <pre><code>def _summarize_ideal_gas_thermo(\n    igt: IdealGasThermo,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n) -&gt; ThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE IdealGasThermo object and store them in a\n    database-friendly format.\n\n    Parameters\n    ----------\n    igt\n        ASE IdealGasThermo object.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n\n    Returns\n    -------\n    ThermoSchema\n        Dictionary representation of the task document\n    \"\"\"\n    spin_multiplicity = round(2 * igt.spin + 1)\n    settings = get_settings()\n\n    inputs = {\n        \"parameters_thermo\": {\n            \"temperature\": temperature,\n            \"pressure\": pressure,\n            \"sigma\": igt.sigma,\n            \"spin_multiplicity\": spin_multiplicity,\n            \"vib_freqs\": [e / units.invcm for e in igt.vib_energies],\n            \"vib_energies\": igt.vib_energies.tolist(),\n            \"n_imag\": igt.n_imag,\n        }\n    }\n\n    results = {\n        \"results\": {\n            \"energy\": igt.potentialenergy,\n            \"enthalpy\": igt.get_enthalpy(temperature, verbose=settings.DEBUG),\n            \"entropy\": igt.get_entropy(\n                temperature, pressure * 10**5, verbose=settings.DEBUG\n            ),\n            \"gibbs_energy\": igt.get_gibbs_energy(\n                temperature, pressure * 10**5, verbose=settings.DEBUG\n            ),\n            \"zpe\": igt.get_ZPE_correction(),\n        }\n    }\n\n    if charge_and_multiplicity and spin_multiplicity != charge_and_multiplicity[1]:\n        msg = (\n            \"The IdealGasThermo spin multiplicity does not match the user-specified multiplicity.\",\n        )\n        raise ValueError(msg)\n\n    atoms_metadata = atoms_to_metadata(\n        igt.atoms, charge_and_multiplicity=charge_and_multiplicity\n    )\n\n    return atoms_metadata | inputs | results\n</code></pre>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html#himatcal.utils.neb.quacc_schemas._summarize_vib_run","title":"_summarize_vib_run","text":"<pre><code>_summarize_vib_run(vib: Vibrations | VibrationsData, charge_and_multiplicity: tuple[int, int] | None = None) -&gt; VibSchema\n</code></pre> <p>Get tabulated results from an ASE Vibrations object and store them in a database- friendly format.</p> <p>Parameters:</p> <ul> <li> <code>vib</code>               (<code>Vibrations | VibrationsData</code>)           \u2013            <p>ASE Vibrations object.</p> </li> <li> <code>charge_and_multiplicity</code>               (<code>tuple[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>himatcal/utils/neb/quacc_schemas.py</code> <pre><code>def _summarize_vib_run(\n    vib: Vibrations | VibrationsData,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n) -&gt; VibSchema:\n    \"\"\"\n    Get tabulated results from an ASE Vibrations object and store them in a database-\n    friendly format.\n\n    Parameters\n    ----------\n    vib\n        ASE Vibrations object.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n\n    Returns\n    -------\n    VibSchema\n        Dictionary representation of the task document\n    \"\"\"\n    vib_freqs_raw = vib.get_frequencies().tolist()\n    vib_energies_raw = vib.get_energies().tolist()\n\n    # Convert imaginary modes to negative values for DB storage\n    for i, f in enumerate(vib_freqs_raw):\n        if np.imag(f) &gt; 0:\n            vib_freqs_raw[i] = -np.abs(f)\n            vib_energies_raw[i] = -np.abs(vib_energies_raw[i])\n        else:\n            vib_freqs_raw[i] = np.abs(f)\n            vib_energies_raw[i] = np.abs(vib_energies_raw[i])\n\n    if isinstance(vib, VibrationsData):\n        atoms = vib._atoms\n        inputs = {}\n    else:\n        atoms = vib.atoms\n        directory = atoms.calc.directory\n        uri = get_uri(directory)\n\n        inputs = {\n            \"parameters\": atoms.calc.parameters,\n            \"parameters_vib\": {\n                \"delta\": vib.delta,\n                \"direction\": vib.direction,\n                \"method\": vib.method,\n                \"ndof\": vib.ndof,\n                \"nfree\": vib.nfree,\n            },\n            \"nid\": uri.split(\":\")[0],\n            \"dir_name\": directory,\n        }\n\n    atoms_metadata = atoms_to_metadata(\n        atoms, charge_and_multiplicity=charge_and_multiplicity\n    )\n\n    # Get the true vibrational modes\n    natoms = len(atoms)\n    if natoms == 1:\n        vib_freqs = []\n        vib_energies = []\n    elif atoms.pbc.any():\n        vib_freqs = vib_freqs_raw\n        vib_energies = vib_energies_raw\n    else:\n        # Sort by absolute value\n        vib_freqs_raw_sorted = vib_freqs_raw.copy()\n        vib_energies_raw_sorted = vib_energies_raw.copy()\n        vib_freqs_raw_sorted.sort(key=np.abs)\n        vib_energies_raw_sorted.sort(key=np.abs)\n\n        # Cut the 3N-5 or 3N-6 modes based on their absolute value\n        n_modes = (\n            3 * natoms - 5 if atoms_metadata[\"symmetry\"][\"linear\"] else 3 * natoms - 6\n        )\n        vib_freqs = vib_freqs_raw_sorted[-n_modes:]\n        vib_energies = vib_energies_raw_sorted[-n_modes:]\n\n    imag_vib_freqs = [f for f in vib_freqs if f &lt; 0]\n\n    results = {\n        \"results\": {\n            \"imag_vib_freqs\": imag_vib_freqs,\n            \"n_imag\": len(imag_vib_freqs),\n            \"vib_energies\": vib_energies,\n            \"vib_freqs\": vib_freqs,\n            \"vib_energies_raw\": vib_energies_raw,\n            \"vib_freqs_raw\": vib_freqs_raw,\n        }\n    }\n\n    return atoms_metadata | inputs | results\n</code></pre>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html#himatcal.utils.neb.quacc_schemas.summarize_md_run","title":"summarize_md_run","text":"<pre><code>summarize_md_run(dyn: MolecularDynamics, trajectory: Trajectory | list[Atoms] | None = None, charge_and_multiplicity: tuple[int, int] | None = None, move_magmoms: bool = True, additional_fields: dict[str, Any] | None = None, store: Store | bool | None = None) -&gt; DynSchema\n</code></pre> <p>Get tabulated results from an ASE Atoms trajectory and store them in a database- friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> <code>dyn</code>               (<code>MolecularDynamics</code>)           \u2013            <p>ASE MolecularDynamics object.</p> </li> <li> <code>trajectory</code>               (<code>Trajectory | list[Atoms] | None</code>, default:                   <code>None</code> )           \u2013            <p>ASE Trajectory object or list[Atoms] from reading a trajectory file. If None, the trajectory must be found in <code>dyn.trajectory.filename</code>.</p> </li> <li> <code>charge_and_multiplicity</code>               (<code>tuple[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>move_magmoms</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to move the final magmoms of the original Atoms object to the initial magmoms of the returned Atoms object.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>               (<code>Store | bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Maggma Store object to store the results in. If None, <code>QuaccSettings.STORE</code> will be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DynSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>himatcal/utils/neb/quacc_schemas.py</code> <pre><code>def summarize_md_run(\n    dyn: MolecularDynamics,\n    trajectory: Trajectory | list[Atoms] | None = None,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    move_magmoms: bool = True,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | bool | None = None,\n) -&gt; DynSchema:\n    \"\"\"\n    Get tabulated results from an ASE Atoms trajectory and store them in a database-\n    friendly format. This is meant to be compatible with all calculator types.\n\n    Parameters\n    ----------\n    dyn\n        ASE MolecularDynamics object.\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file. If\n        None, the trajectory must be found in `dyn.trajectory.filename`.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    move_magmoms\n        Whether to move the final magmoms of the original Atoms object to the\n        initial magmoms of the returned Atoms object.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. If None,\n        `QuaccSettings.STORE` will be used.\n\n    Returns\n    -------\n    DynSchema\n        Dictionary representation of the task document\n    \"\"\"\n    settings = get_settings()\n    base_task_doc = summarize_opt_run(\n        dyn,\n        trajectory=trajectory,\n        check_convergence=False,\n        charge_and_multiplicity=charge_and_multiplicity,\n        move_magmoms=move_magmoms,\n        store=None,\n    )\n    del base_task_doc[\"converged\"]\n\n    # Clean up the opt parameters\n    parameters_md = base_task_doc.pop(\"parameters_opt\")\n    parameters_md.pop(\"logfile\", None)\n\n    trajectory_log = []\n    for t, atoms in enumerate(base_task_doc[\"trajectory\"]):\n        trajectory_log.append(\n            {\n                \"kinetic_energy\": atoms.get_kinetic_energy(),\n                \"temperature\": atoms.get_temperature(),\n                \"time\": t * parameters_md[\"timestep\"],\n            }\n        )\n\n    md_fields = {\"parameters_md\": parameters_md, \"trajectory_log\": trajectory_log}\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = base_task_doc | md_fields | additional_fields\n\n    return finalize_dict(\n        unsorted_task_doc,\n        base_task_doc[\"dir_name\"],\n        gzip_file=settings.GZIP_FILES,\n        store=store,\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html#himatcal.utils.neb.quacc_schemas.summarize_neb_run","title":"summarize_neb_run","text":"<pre><code>summarize_neb_run(dyn: Optimizer, trajectory: Trajectory | list[Atoms] | None = None, charge_and_multiplicity: tuple[int, int] | None = None, additional_fields: dict[str, Any] | None = None, store: Store | None | DefaultSetting = QuaccDefault) -&gt; OptSchema\n</code></pre> <p>Summarize the NEB run results and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>dyn</code>               (<code>Optimizer</code>)           \u2013            <p>ASE Optimizer object used for the NEB run.</p> </li> <li> <code>trajectory</code>               (<code>Trajectory | list[Atoms] | None</code>, default:                   <code>None</code> )           \u2013            <p>Trajectory of the NEB run, either as a Trajectory object or a list of Atoms objects.</p> </li> <li> <code>charge_and_multiplicity</code>               (<code>tuple[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Charge and spin multiplicity of the Atoms object.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>               (<code>Store | None | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Maggma Store object to store the results in. Defaults to <code>QuaccSettings.STORE</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>A dictionary containing the summarized NEB run results.</p> </li> </ul> Source code in <code>himatcal/utils/neb/quacc_schemas.py</code> <pre><code>def summarize_neb_run(\n    dyn: Optimizer,\n    trajectory: Trajectory | list[Atoms] | None = None,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | None | DefaultSetting = QuaccDefault,\n) -&gt; OptSchema:\n    \"\"\"\n    Summarize the NEB run results and store them in a database-friendly format.\n\n    Parameters\n    ----------\n    dyn\n        ASE Optimizer object used for the NEB run.\n    trajectory\n        Trajectory of the NEB run, either as a Trajectory object or a list of Atoms objects.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. Defaults to `QuaccSettings.STORE`.\n\n    Returns\n    -------\n    OptSchema\n        A dictionary containing the summarized NEB run results.\n    \"\"\"\n    settings = get_settings()\n    store = settings.STORE if store == QuaccDefault else store\n    additional_fields = additional_fields or {}\n\n    # Get trajectory\n    if not trajectory:\n        trajectory = read(dyn.trajectory.filename, index=\":\")\n\n    n_images = additional_fields[\"geodesic_interpolate_flags\"][\"n_images\"]\n    trajectory_results = [atoms.calc.results for atoms in trajectory]\n    trajectory = trajectory[-(n_images):]\n    trajectory_results = trajectory_results[-(n_images):]\n    try:\n        ts_index = np.argmax([i[\"energy\"] for i in trajectory_results[1:-1]]) + 1\n    except:\n        ts_index = (\n            np.argmax([i.get_potential_energy() for i in trajectory_results[1:-1]]) + 1\n        )\n    ts_atoms = trajectory[ts_index]\n\n    for traj_atoms in trajectory:\n        traj_atoms.calc = None\n\n    initial_atoms = trajectory[0]\n    get_final_atoms_from_dynamics(dyn)\n\n    # Base task doc\n    base_task_doc = summarize_run_neb2(\n        initial_atoms, charge_and_multiplicity=charge_and_multiplicity, store=None\n    )\n\n    # Clean up the opt parameters\n    parameters_opt = dyn.todict()\n    parameters_opt.pop(\"logfile\", None)\n    parameters_opt.pop(\"restart\", None)\n\n    opt_fields = {\n        \"highest_e_atoms\": ts_atoms,\n        \"parameters_opt\": parameters_opt,\n        \"trajectory\": trajectory,\n        \"trajectory_results\": trajectory_results,\n    }\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = base_task_doc | opt_fields | additional_fields\n\n    return finalize_dict(\n        unsorted_task_doc, \"\", gzip_file=settings.GZIP_FILES, store=store\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html#himatcal.utils.neb.quacc_schemas.summarize_opt_run","title":"summarize_opt_run","text":"<pre><code>summarize_opt_run(dyn: Optimizer, trajectory: Trajectory | list[Atoms] | None = None, check_convergence: bool | DefaultSetting = QuaccDefault, charge_and_multiplicity: tuple[int, int] | None = None, move_magmoms: bool = False, additional_fields: dict[str, Any] | None = None, store: Store | None | DefaultSetting = QuaccDefault) -&gt; OptSchema\n</code></pre> <p>Get tabulated results from an ASE Atoms trajectory and store them in a database- friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> <code>dyn</code>               (<code>Optimizer</code>)           \u2013            <p>ASE Optimizer object.</p> </li> <li> <code>trajectory</code>               (<code>Trajectory | list[Atoms] | None</code>, default:                   <code>None</code> )           \u2013            <p>ASE Trajectory object or list[Atoms] from reading a trajectory file. If None, the trajectory must be found in <code>dyn.trajectory.filename</code>.</p> </li> <li> <code>check_convergence</code>               (<code>bool | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Whether to check the convergence of the calculation. Defaults to True in settings.</p> </li> <li> <code>charge_and_multiplicity</code>               (<code>tuple[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>move_magmoms</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to move the final magmoms of the original Atoms object to the initial magmoms of the returned Atoms object.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>               (<code>Store | None | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Maggma Store object to store the results in. Defaults to <code>QuaccSettings.STORE</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OptSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>himatcal/utils/neb/quacc_schemas.py</code> <pre><code>def summarize_opt_run(\n    dyn: Optimizer,\n    trajectory: Trajectory | list[Atoms] | None = None,\n    check_convergence: bool | DefaultSetting = QuaccDefault,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    move_magmoms: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | None | DefaultSetting = QuaccDefault,\n) -&gt; OptSchema:\n    \"\"\"\n    Get tabulated results from an ASE Atoms trajectory and store them in a database-\n    friendly format. This is meant to be compatible with all calculator types.\n\n    Parameters\n    ----------\n    dyn\n        ASE Optimizer object.\n    trajectory\n        ASE Trajectory object or list[Atoms] from reading a trajectory file. If\n        None, the trajectory must be found in `dyn.trajectory.filename`.\n    check_convergence\n        Whether to check the convergence of the calculation. Defaults to True in\n        settings.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    move_magmoms\n        Whether to move the final magmoms of the original Atoms object to the\n        initial magmoms of the returned Atoms object.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. Defaults to `QuaccSettings.STORE`.\n\n    Returns\n    -------\n    OptSchema\n        Dictionary representation of the task document\n    \"\"\"\n    settings = get_settings()\n    check_convergence = (\n        settings.CHECK_CONVERGENCE\n        if check_convergence == QuaccDefault\n        else check_convergence\n    )\n    store = settings.STORE if store == QuaccDefault else store\n    additional_fields = additional_fields or {}\n\n    # Get trajectory\n    if not trajectory:\n        trajectory = read(dyn.trajectory.filename, index=\":\")\n    trajectory_results = [atoms.calc.results for atoms in trajectory]\n\n    initial_atoms = trajectory[0]\n    final_atoms = get_final_atoms_from_dynamics(dyn)\n    directory = final_atoms.calc.directory\n\n    # Check convergence\n    is_converged = dyn.converged()\n    if check_convergence and not is_converged:\n        msg = f\"Optimization did not converge. Refer to {directory}\"\n        raise RuntimeError(msg)\n\n    # Base task doc\n    base_task_doc = summarize_run(\n        final_atoms,\n        initial_atoms,\n        charge_and_multiplicity=charge_and_multiplicity,\n        move_magmoms=move_magmoms,\n        store=None,\n    )\n\n    # Clean up the opt parameters\n    parameters_opt = dyn.todict()\n    parameters_opt.pop(\"logfile\", None)\n    parameters_opt.pop(\"restart\", None)\n\n    opt_fields = {\n        \"parameters_opt\": parameters_opt,\n        \"converged\": is_converged,\n        \"trajectory\": trajectory,\n        \"trajectory_results\": trajectory_results,\n    }\n\n    # Create a dictionary of the inputs/outputs\n    unsorted_task_doc = base_task_doc | opt_fields | additional_fields\n\n    return finalize_dict(\n        unsorted_task_doc, directory, gzip_file=settings.GZIP_FILES, store=store\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html#himatcal.utils.neb.quacc_schemas.summarize_run","title":"summarize_run","text":"<pre><code>summarize_run(final_atoms: Atoms, input_atoms: Atoms, charge_and_multiplicity: tuple[int, int] | None = None, move_magmoms: bool = False, additional_fields: dict[str, Any] | None = None, store: Store | None | DefaultSetting = QuaccDefault) -&gt; RunSchema\n</code></pre> <p>Get tabulated results from an Atoms object and calculator and store them in a database-friendly format. This is meant to be compatible with all calculator types.</p> <p>Parameters:</p> <ul> <li> <code>final_atoms</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms following a calculation. A calculator must be attached.</p> </li> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>Input ASE Atoms object to store.</p> </li> <li> <code>charge_and_multiplicity</code>               (<code>tuple[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>move_magmoms</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to move the final magmoms of the original Atoms object to the initial magmoms of the returned Atoms object.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>               (<code>Store | None | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Maggma Store object to store the results in. Defaults to <code>QuaccSettings.STORE</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary representation of the task document</p> </li> </ul> Source code in <code>himatcal/utils/neb/quacc_schemas.py</code> <pre><code>def summarize_run(\n    final_atoms: Atoms,\n    input_atoms: Atoms,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    move_magmoms: bool = False,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | None | DefaultSetting = QuaccDefault,\n) -&gt; RunSchema:\n    \"\"\"\n    Get tabulated results from an Atoms object and calculator and store them in a\n    database-friendly format. This is meant to be compatible with all calculator types.\n\n    Parameters\n    ----------\n    final_atoms\n        ASE Atoms following a calculation. A calculator must be attached.\n    input_atoms\n        Input ASE Atoms object to store.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    move_magmoms\n        Whether to move the final magmoms of the original Atoms object to the\n        initial magmoms of the returned Atoms object.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. Defaults to `QuaccSettings.STORE`\n\n    Returns\n    -------\n    RunSchema\n        Dictionary representation of the task document\n    \"\"\"\n    additional_fields = additional_fields or {}\n    settings = get_settings()\n    store = settings.STORE if store == QuaccDefault else store\n\n    if not final_atoms.calc:\n        msg = \"ASE Atoms object has no attached calculator.\"\n        raise ValueError(msg)\n    if not final_atoms.calc.results:\n        msg = \"ASE Atoms object's calculator has no results.\"\n        raise ValueError(msg)\n\n    directory = final_atoms.calc.directory\n    uri = get_uri(directory)\n\n    if input_atoms:\n        input_atoms_metadata = atoms_to_metadata(\n            input_atoms,\n            charge_and_multiplicity=charge_and_multiplicity,\n            store_pmg=False,\n        )\n    else:\n        input_atoms_metadata = {}\n\n    inputs = {\n        \"parameters\": final_atoms.calc.parameters,\n        \"nid\": uri.split(\":\")[0],\n        \"dir_name\": directory,\n        \"input_atoms\": input_atoms_metadata,\n        \"quacc_version\": __version__,\n    }\n    results = {\"results\": final_atoms.calc.results}\n\n    atoms_to_store = prep_next_run(final_atoms, move_magmoms=move_magmoms)\n\n    if final_atoms:\n        final_atoms_metadata = atoms_to_metadata(\n            atoms_to_store, charge_and_multiplicity=charge_and_multiplicity\n        )\n    else:\n        final_atoms_metadata = {}\n\n    unsorted_task_doc = final_atoms_metadata | inputs | results | additional_fields\n\n    return finalize_dict(\n        unsorted_task_doc, directory, gzip_file=settings.GZIP_FILES, store=store\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html#himatcal.utils.neb.quacc_schemas.summarize_run_neb2","title":"summarize_run_neb2","text":"<pre><code>summarize_run_neb2(input_atoms: Atoms, charge_and_multiplicity: tuple[int, int] | None = None, additional_fields: dict[str, Any] | None = None, store: Store | None | DefaultSetting = QuaccDefault) -&gt; RunSchema\n</code></pre> <p>Summarize the NEB run results and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>input_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The input Atoms object used for the NEB run.</p> </li> <li> <code>charge_and_multiplicity</code>               (<code>tuple[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Charge and spin multiplicity of the Atoms object.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>               (<code>Store | None | DefaultSetting</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Maggma Store object to store the results in. Defaults to <code>QuaccSettings.STORE</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>A dictionary containing the summarized NEB run results.</p> </li> </ul> Source code in <code>himatcal/utils/neb/quacc_schemas.py</code> <pre><code>def summarize_run_neb2(\n    input_atoms: Atoms,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | None | DefaultSetting = QuaccDefault,\n) -&gt; RunSchema:\n    \"\"\"\n    Summarize the NEB run results and store them in a database-friendly format.\n\n    Parameters\n    ----------\n    input_atoms\n        The input Atoms object used for the NEB run.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. Defaults to `QuaccSettings.STORE`.\n\n    Returns\n    -------\n    RunSchema\n        A dictionary containing the summarized NEB run results.\n    \"\"\"\n    additional_fields = additional_fields or {}\n    settings = get_settings()\n    store = settings.STORE if store == QuaccDefault else store\n\n    if input_atoms:\n        input_atoms_metadata = atoms_to_metadata(\n            input_atoms,\n            charge_and_multiplicity=charge_and_multiplicity,\n            store_pmg=False,\n        )\n    else:\n        input_atoms_metadata = {}\n\n    inputs = {\"input_atoms\": input_atoms_metadata, \"quacc_version\": __version__}\n    results = {}\n    final_atoms_metadata = {}\n\n    unsorted_task_doc = final_atoms_metadata | inputs | results | additional_fields\n\n    return finalize_dict(\n        unsorted_task_doc, \"\", gzip_file=settings.GZIP_FILES, store=store\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/neb/quacc_schemas.html#himatcal.utils.neb.quacc_schemas.summarize_vib_and_thermo","title":"summarize_vib_and_thermo","text":"<pre><code>summarize_vib_and_thermo(vib: Vibrations, igt: IdealGasThermo, temperature: float = 298.15, pressure: float = 1.0, charge_and_multiplicity: tuple[int, int] | None = None, additional_fields: dict[str, Any] | None = None, store: Store | None = QuaccDefault) -&gt; VibThermoSchema\n</code></pre> <p>Get tabulated results from an ASE Vibrations run and ASE IdealGasThermo object and store them in a database-friendly format.</p> <p>Parameters:</p> <ul> <li> <code>vib</code>               (<code>Vibrations</code>)           \u2013            <p>ASE Vibrations object.</p> </li> <li> <code>igt</code>               (<code>IdealGasThermo</code>)           \u2013            <p>ASE IdealGasThermo object.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature in Kelvins.</p> </li> <li> <code>pressure</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Pressure in bar.</p> </li> <li> <code>charge_and_multiplicity</code>               (<code>tuple[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Charge and spin multiplicity of the Atoms object, only used for Molecule metadata.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the task document.</p> </li> <li> <code>store</code>               (<code>Store | None</code>, default:                   <code>QuaccDefault</code> )           \u2013            <p>Maggma Store object to store the results in. Defaults to  <code>QuaccSettings.STORE</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VibThermoSchema</code>           \u2013            <p>A dictionary that merges the <code>VibSchema</code> and <code>ThermoSchema</code>.</p> </li> </ul> Source code in <code>himatcal/utils/neb/quacc_schemas.py</code> <pre><code>def summarize_vib_and_thermo(\n    vib: Vibrations,\n    igt: IdealGasThermo,\n    temperature: float = 298.15,\n    pressure: float = 1.0,\n    charge_and_multiplicity: tuple[int, int] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    store: Store | None = QuaccDefault,\n) -&gt; VibThermoSchema:\n    \"\"\"\n    Get tabulated results from an ASE Vibrations run and ASE IdealGasThermo object and\n    store them in a database-friendly format.\n\n    Parameters\n    ----------\n    vib\n        ASE Vibrations object.\n    igt\n        ASE IdealGasThermo object.\n    temperature\n        Temperature in Kelvins.\n    pressure\n        Pressure in bar.\n    charge_and_multiplicity\n        Charge and spin multiplicity of the Atoms object, only used for Molecule\n        metadata.\n    additional_fields\n        Additional fields to add to the task document.\n    store\n        Maggma Store object to store the results in. Defaults to  `QuaccSettings.STORE`.\n\n    Returns\n    -------\n    VibThermoSchema\n        A dictionary that merges the `VibSchema` and `ThermoSchema`.\n    \"\"\"\n    settings = get_settings()\n    store = settings.STORE if store == QuaccDefault else store\n\n    vib_task_doc = _summarize_vib_run(\n        vib, charge_and_multiplicity=charge_and_multiplicity\n    )\n    thermo_task_doc = _summarize_ideal_gas_thermo(\n        igt,\n        temperature=temperature,\n        pressure=pressure,\n        charge_and_multiplicity=charge_and_multiplicity,\n    )\n\n    unsorted_task_doc = recursive_dict_merge(\n        vib_task_doc, thermo_task_doc, additional_fields\n    )\n\n    return finalize_dict(\n        unsorted_task_doc,\n        vib.atoms.calc.directory if isinstance(vib, Vibrations) else None,\n        gzip_file=settings.GZIP_FILES,\n        store=store,\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html","title":"core","text":"<p>https://github.com/zincware/rdkit2ase/tree/main</p>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.OBJ_OR_STR","title":"OBJ_OR_STR  <code>module-attribute</code>","text":"<pre><code>OBJ_OR_STR = Union[str, Mol, Atoms]\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.OBJ_OR_STR_OR_LIST","title":"OBJ_OR_STR_OR_LIST  <code>module-attribute</code>","text":"<pre><code>OBJ_OR_STR_OR_LIST = Union[OBJ_OR_STR, list[tuple[OBJ_OR_STR, float]]]\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core._get_cell_vectors","title":"_get_cell_vectors","text":"<pre><code>_get_cell_vectors(images: list[Atoms], density: float) -&gt; list[float]\n</code></pre> <p>Get the box size from the molar volume.</p> <p>Attributes:</p> <ul> <li> <code>images</code>               (<code>list[Atoms]</code>)           \u2013            <p>All the atoms that should be packed.</p> </li> <li> <code>density</code>               (<code>float</code>)           \u2013            <p>Density of the system in kg/m^3.</p> </li> </ul> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def _get_cell_vectors(images: list[Atoms], density: float) -&gt; list[float]:\n    \"\"\"Get the box size from the molar volume.\n\n    Attributes\n    ----------\n    images : list[Atoms]\n        All the atoms that should be packed.\n    density: float\n        Density of the system in kg/m^3.\n    \"\"\"\n    molar_mass = sum(sum(atoms.get_masses()) for atoms in images)\n    molar_volume = molar_mass / density / 1000  # m^3 / mol\n\n    # convert to particles / A^3\n    volume = molar_volume * units.m**3 / units.mol\n\n    return [volume ** (1 / 3) for _ in range(3)]\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.ase2rdkit","title":"ase2rdkit","text":"<pre><code>ase2rdkit(atoms: Atoms, charge: int | None = None) -&gt; Mol\n</code></pre> <p>Convert an ASE Atoms object to an RDKit molecule.</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def ase2rdkit(atoms: Atoms, charge: int | None = None) -&gt; Chem.Mol:\n    \"\"\"Convert an ASE Atoms object to an RDKit molecule.\"\"\"\n    with io.StringIO() as f:\n        write(f, atoms, format=\"xyz\")\n        f.seek(0)\n        xyz = f.read()\n        raw_mol = Chem.rdmolfiles.MolFromXYZBlock(xyz)\n\n    mol = Chem.Mol(raw_mol)\n    # * Using a range of charges to determine the correct one, a lazy way to avoid errors\n    if charge is None:\n        for chg in [-2, -1, 0, 1, 2]:\n            try:\n                rdDetermineBonds.DetermineBonds(mol, charge=chg)\n                break\n            except ValueError:\n                continue\n    else:\n        rdDetermineBonds.DetermineBonds(mol, charge=charge)\n    return mol\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.atoms2smiles","title":"atoms2smiles","text":"<pre><code>atoms2smiles(atoms: Atoms) -&gt; str\n</code></pre> <p>Convert an ASE Atoms object to a SMILES string.</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def atoms2smiles(atoms: Atoms) -&gt; str:\n    \"\"\"Convert an ASE Atoms object to a SMILES string.\"\"\"\n    mol = ase2rdkit(atoms)\n    return Chem.MolToSmiles(mol)\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.merge_equivalent_smiles","title":"merge_equivalent_smiles","text":"<pre><code>merge_equivalent_smiles(smiles_list)\n</code></pre> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def merge_equivalent_smiles(smiles_list):\n    from rdkit.Chem import rdMolHash\n\n    unique_mols = {}\n    for smile in smiles_list:\n        mol = Chem.MolFromSmiles(smile)\n        mol_hash = rdMolHash.MolHash(mol, rdMolHash.HashFunction.CanonicalSmiles)\n        if mol_hash in unique_mols:\n            continue\n        unique_mols[mol_hash] = smile\n    return list(unique_mols.values())\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.mol_with_atom_and_bond_indices","title":"mol_with_atom_and_bond_indices","text":"<pre><code>mol_with_atom_and_bond_indices(smiles, output_file: str | None = None)\n</code></pre> <p>Draw molecule structure with atom and bond indices.</p> <p>Args:     smiles (str): SMILES string of the molecule     output_file (str | None, optional): File path to save the PNG image. Defaults to None.</p> <p>Returns:     RDKit.Mol: RDKit molecule object with atom indices</p> <p>Raises:     ValueError: If the SMILES string is invalid</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def mol_with_atom_and_bond_indices(smiles, output_file: str | None = None):\n    \"\"\"Draw molecule structure with atom and bond indices.\n\n    Args:\n        smiles (str): SMILES string of the molecule\n        output_file (str | None, optional): File path to save the PNG image. Defaults to None.\n\n    Returns:\n        RDKit.Mol: RDKit molecule object with atom indices\n\n    Raises:\n        ValueError: If the SMILES string is invalid\n    \"\"\"\n    from rdkit import Chem\n    from rdkit.Chem.Draw import IPythonConsole\n\n    mol = Chem.MolFromSmiles(smiles)\n    if mol is None:\n        raise ValueError(\"Invalid SMILES string\")\n\n    # Add atom indices\n    for atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx() + 1)\n\n    # Configure drawing options\n    IPythonConsole.drawOptions.addBondIndices = True\n    IPythonConsole.molSize = (350, 300)\n\n    # Generate and save image\n    if output_file:\n        with pathlib.Path(output_file).open(\"wb\") as f:\n            f.write(mol._repr_png_())\n\n    return mol\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.pack","title":"pack","text":"<pre><code>pack(data: list[list[Atoms] | Atoms], counts: list[int], density: float, seed: int = 42, tolerance: float = 2, logging: bool = False) -&gt; Atoms\n</code></pre> <p>Pack the given molecules into a box with the specified density.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>list[list[Atoms]]</code>)           \u2013            <p>A list of lists of ASE Atoms objects representing the molecules to be packed.</p> </li> <li> <code>counts</code>               (<code>list[int]</code>)           \u2013            <p>A list of integers representing the number of each type of molecule.</p> </li> <li> <code>density</code>               (<code>float</code>)           \u2013            <p>The target density of the packed system in kg/m^3.</p> </li> <li> <code>seed</code>               (<code>int</code>, default:                   <code>42</code> )           \u2013            <p>The random seed for reproducibility, by default 42.</p> </li> <li> <code>tolerance</code>               (<code>float</code>, default:                   <code>2</code> )           \u2013            <p>The tolerance for the packing algorithm, by default 2.</p> </li> <li> <code>logging</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables logging of the packing process, by default False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>An ASE Atoms object representing the packed system.</p> </li> </ul> Example <p>from rdkit2ase import pack, smiles2conformers water = smiles2conformers(\"O\", 1) ethanol = smiles2conformers(\"CCO\", 1) density = 1000  # kg/m^3 packed_system = pack([water, ethanol], [7, 5], density) print(packed_system) Atoms(symbols='C10H44O12', pbc=True, cell=[8.4, 8.4, 8.4])</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def pack(\n    data: list[list[Atoms] | Atoms],\n    counts: list[int],\n    density: float,\n    seed: int = 42,\n    tolerance: float = 2,\n    logging: bool = False,\n) -&gt; Atoms:\n    \"\"\"\n    Pack the given molecules into a box with the specified density.\n\n    Parameters\n    ----------\n    data : list[list[Atoms]]\n        A list of lists of ASE Atoms objects representing the molecules to be packed.\n    counts : list[int]\n        A list of integers representing the number of each type of molecule.\n    density : float\n        The target density of the packed system in kg/m^3.\n    seed : int, optional\n        The random seed for reproducibility, by default 42.\n    tolerance : float, optional\n        The tolerance for the packing algorithm, by default 2.\n    logging : bool, optional\n        If True, enables logging of the packing process, by default False.\n\n    Returns\n    -------\n    Atoms\n        An ASE Atoms object representing the packed system.\n\n    Example\n    -------\n    &gt;&gt;&gt; from rdkit2ase import pack, smiles2conformers\n    &gt;&gt;&gt; water = smiles2conformers(\"O\", 1)\n    &gt;&gt;&gt; ethanol = smiles2conformers(\"CCO\", 1)\n    &gt;&gt;&gt; density = 1000  # kg/m^3\n    &gt;&gt;&gt; packed_system = pack([water, ethanol], [7, 5], density)\n    &gt;&gt;&gt; print(packed_system)\n    Atoms(symbols='C10H44O12', pbc=True, cell=[8.4, 8.4, 8.4])\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    selected_idx: list[np.ndarray] = []\n\n    for images, count in zip(data, counts):\n        selected_idx.append(\n            rng.choice(range(len(images)), count, replace=len(images) &lt; count)\n        )\n\n    images = [\n        [data[category][idx] for idx in indices]\n        for category, indices in enumerate(selected_idx)\n    ]\n    images = functools.reduce(operator.iadd, images, [])\n\n    cell = _get_cell_vectors(images=images, density=density)\n\n    file = f\"\"\"\ntolerance {tolerance}\nfiletype xyz\noutput mixture.xyz\npbc 0 0 0 {\" \".join([f\"{x:.6f}\" for x in cell])}\n    \"\"\"\n    for category, indices in enumerate(selected_idx):\n        for idx in indices:\n            file += f\"\"\"\nstructure struct_{category}_{idx}.xyz\n    filetype xyz\n\nend structure\n                     \"\"\"\n\n    with tempfile.TemporaryDirectory() as tmpdir:\n        tmpdir_path = pathlib.Path(tmpdir)\n        for category, indices in enumerate(selected_idx):\n            for idx in set(indices):\n                atoms = data[category][idx]\n                write(tmpdir_path / f\"struct_{category}_{idx}.xyz\", atoms, format=\"xyz\")\n        (tmpdir_path / \"pack.inp\").write_text(file)\n        subprocess.run(\n            \"packmol &lt; pack.inp\",\n            cwd=tmpdir_path,\n            shell=True,\n            check=True,\n            capture_output=not logging,\n        )\n        atoms: Atoms = read(tmpdir_path / \"mixture.xyz\")\n\n    atoms.cell = cell\n    atoms.pbc = True\n    return atoms\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.plot_gasteiger_charges","title":"plot_gasteiger_charges","text":"<pre><code>plot_gasteiger_charges(mol)\n</code></pre> <p>Plot Gasteiger charges on a molecule.</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def plot_gasteiger_charges(mol):\n    \"\"\"\n    Plot Gasteiger charges on a molecule.\n    \"\"\"\n    from rdkit.Chem.Draw import SimilarityMaps\n\n    AllChem.ComputeGasteigerCharges(mol)\n    contribs = [\n        float(mol.GetAtomWithIdx(i).GetProp(\"_GasteigerCharge\"))\n        for i in range(mol.GetNumAtoms())\n    ]\n    SimilarityMaps.GetSimilarityMapFromWeights(\n        mol, contribs, colorMap=\"jet\", contourLines=10\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.rdkit2ase","title":"rdkit2ase","text":"<pre><code>rdkit2ase(mol) -&gt; Atoms\n</code></pre> <p>Convert an RDKit molecule to an ASE atoms object.</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def rdkit2ase(mol) -&gt; Atoms:\n    \"\"\"Convert an RDKit molecule to an ASE atoms object.\"\"\"\n    mol = Chem.AddHs(mol)\n    AllChem.EmbedMolecule(mol)\n    AllChem.UFFOptimizeMolecule(mol)\n\n    return Atoms(\n        positions=mol.GetConformer().GetPositions(),\n        numbers=[atom.GetAtomicNum() for atom in mol.GetAtoms()],\n    )\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.smiles2atoms","title":"smiles2atoms","text":"<pre><code>smiles2atoms(smiles: str) -&gt; Atoms\n</code></pre> <p>Convert a SMILES string to an ASE Atoms object.</p> <p>Args:     smiles (str): The SMILES string.</p> <p>Returns:     atoms (Atoms): The Atoms object.</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def smiles2atoms(smiles: str) -&gt; Atoms:\n    \"\"\"\n    Convert a SMILES string to an ASE Atoms object.\n\n    Args:\n        smiles (str): The SMILES string.\n\n    Returns:\n        atoms (Atoms): The Atoms object.\n    \"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    return rdkit2ase(mol)\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.smiles2conformers","title":"smiles2conformers","text":"<pre><code>smiles2conformers(smiles: str, numConfs: int, randomSeed: int = 42, maxAttempts: int = 1000) -&gt; list[Atoms]\n</code></pre> <p>Create multiple conformers for a SMILES string.</p> <p>Args:     smiles (str): The SMILES string.     numConfs (int): The number of conformers to generate.     randomSeed (int): The random seed.     maxAttempts (int): The maximum number of attempts.</p> <p>Returns:     images (list[Atoms]): The list of conformers.</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def smiles2conformers(\n    smiles: str,\n    numConfs: int,\n    randomSeed: int = 42,\n    maxAttempts: int = 1000,\n) -&gt; list[Atoms]:\n    \"\"\"Create multiple conformers for a SMILES string.\n\n    Args:\n        smiles (str): The SMILES string.\n        numConfs (int): The number of conformers to generate.\n        randomSeed (int): The random seed.\n        maxAttempts (int): The maximum number of attempts.\n\n    Returns:\n        images (list[Atoms]): The list of conformers.\n    \"\"\"\n    mol = Chem.MolFromSmiles(smiles)\n    mol = Chem.AddHs(mol)\n    rdDistGeom.EmbedMultipleConfs(\n        mol,\n        numConfs=numConfs,\n        randomSeed=randomSeed,\n        maxAttempts=maxAttempts,\n    )\n\n    images: list[Atoms] = []\n\n    for conf in mol.GetConformers():\n        atoms = Atoms(\n            positions=conf.GetPositions(),\n            numbers=[atom.GetAtomicNum() for atom in mol.GetAtoms()],\n        )\n        images.append(atoms)\n\n    return images\n</code></pre>"},{"location":"reference/himatcal/utils/rdkit/core.html#himatcal.utils.rdkit.core.smiles_to_rdkit","title":"smiles_to_rdkit","text":"<pre><code>smiles_to_rdkit(smi, gen_3d=True, nconf=100)\n</code></pre> <p>Convert smiles to RDKit molecule. Tries to generate the lowest-energy conformer.</p> Source code in <code>himatcal/utils/rdkit/core.py</code> <pre><code>def smiles_to_rdkit(smi, gen_3d=True, nconf=100):\n    \"\"\"\n    Convert smiles to RDKit molecule.\n    Tries to generate the lowest-energy conformer.\n    \"\"\"\n    mol = Chem.MolFromSmiles(smi)\n    mol = Chem.AddHs(mol)\n\n    if gen_3d:\n        cids = AllChem.EmbedMultipleConfs(mol, nconf, AllChem.ETKDG())\n\n        AllChem.MMFFSanitizeMolecule(mol)\n        mmff_props = AllChem.MMFFGetMoleculeProperties(mol)\n\n        energies = []\n        for cid in cids:\n            ff = AllChem.MMFFGetMoleculeForceField(mol, mmff_props, confId=cid)\n            ff.Minimize()\n            energy = ff.CalcEnergy()\n            energies.append(energy)\n\n        energies = np.asarray(energies)\n        min_energy_idx = np.argsort(energies)[0]\n\n        new_mol = Chem.Mol(mol)\n        new_mol.RemoveAllConformers()\n        min_conf = mol.GetConformer(cids[min_energy_idx])\n        new_mol.AddConformer(min_conf, assignId=True)\n        mol = new_mol\n\n    return mol\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html","title":"molbokeh","text":"<p>https://github.com/jeffrichardchemistry/molbokeh/blob/main/MolBokeh/MolBokeh.py</p>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html#himatcal.utils.visualizer.molbokeh.MolBokeh","title":"MolBokeh","text":"<pre><code>MolBokeh()\n</code></pre> Source code in <code>himatcal/utils/visualizer/molbokeh.py</code> <pre><code>def __init__(self):\n    self._dfwithimg = None\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html#himatcal.utils.visualizer.molbokeh.MolBokeh._dfwithimg","title":"_dfwithimg  <code>instance-attribute</code>","text":"<pre><code>_dfwithimg = None\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html#himatcal.utils.visualizer.molbokeh.MolBokeh.__applyHover2fig","title":"__applyHover2fig","text":"<pre><code>__applyHover2fig(fig, hoverhtml: str)\n</code></pre> <p>Apply hover inside bokeh charts.</p> Source code in <code>himatcal/utils/visualizer/molbokeh.py</code> <pre><code>def __applyHover2fig(self, fig, hoverhtml: str):\n    \"\"\"\n    Apply hover inside bokeh charts.\n    \"\"\"\n    fig_ = fig\n    hover = HoverTool(tooltips=hoverhtml)\n    fig_.add_tools(hover)\n    return fig_\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html#himatcal.utils.visualizer.molbokeh.MolBokeh.__cleanOriginalHover","title":"__cleanOriginalHover","text":"<pre><code>__cleanOriginalHover(fig)\n</code></pre> <p>This function deletes the original hover if it exists.</p> Source code in <code>himatcal/utils/visualizer/molbokeh.py</code> <pre><code>def __cleanOriginalHover(self, fig):\n    \"\"\"\n    This function deletes the original hover if it exists.\n    \"\"\"\n    fig_ = fig\n    for tool in fig_.tools:\n        if isinstance(tool, HoverTool):\n            fig_.tools.remove(tool)\n\n    return fig_\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html#himatcal.utils.visualizer.molbokeh.MolBokeh.__makingHTML2hover","title":"__makingHTML2hover","text":"<pre><code>__makingHTML2hover(molimgColName: str, hoverAdditionalInfo: Union[None, int] = None, molSize: tuple = (150, 150))\n</code></pre> <p>This function creates the HTML code that will be used as the bokeh hover.</p> Source code in <code>himatcal/utils/visualizer/molbokeh.py</code> <pre><code>def __makingHTML2hover(\n    self,\n    molimgColName: str,\n    hoverAdditionalInfo: Union[None, int] = None,\n    molSize: tuple = (150, 150),\n):\n    \"\"\"\n    This function creates the HTML code that will be used as the bokeh hover.\n    \"\"\"\n    if hoverAdditionalInfo == None:\n        tooltips = f\"\"\"\n        &lt;div&gt;\n            &lt;img src=\"@{molimgColName}\" alt=\"Imagem\" style=\"width: {molSize[0]}px; height: {molSize[0]}px;\"&gt;\n        &lt;/div&gt;\n        \"\"\"\n    else:\n        tagsinfo2html = \"\\n\".join(\n            [\n                f'&lt;p style=\"text-align: center;\"&gt;&lt;strong&gt;{colnames}:&lt;/strong&gt; @openbrac{colnames}closebrac&lt;/p&gt;'\n                for colnames in hoverAdditionalInfo\n            ]\n        )\n        tooltips = f\"\"\"\n        &lt;div&gt;\n            &lt;img src=\"@{molimgColName}\" alt=\"Imagem\" style=\"width: {molSize[0]}px; height: {molSize[0]}px;\"&gt;\n            {tagsinfo2html}                \n        &lt;/div&gt;\n        \"\"\".replace(\"openbrac\", \"{\").replace(\"closebrac\", \"}\")\n\n    return tooltips\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html#himatcal.utils.visualizer.molbokeh.MolBokeh.__makingMoleculesImg","title":"__makingMoleculesImg","text":"<pre><code>__makingMoleculesImg(df: DataFrame, smilesColName: str, molSize: tuple)\n</code></pre> <p>This function creates the images and encodes them as a base64 string, it is added as a new column of the dataframe.</p> Source code in <code>himatcal/utils/visualizer/molbokeh.py</code> <pre><code>def __makingMoleculesImg(\n    self, df: pd.DataFrame, smilesColName: str, molSize: tuple\n):\n    \"\"\"\n    This function creates the images and encodes them as a base64 string, it is added as a new column of the dataframe.\n    \"\"\"\n    df_ = df.copy()\n    df_[\"Mol_IMGSVG\"] = df_[smilesColName].apply(\n        lambda x: MolBokeh.smiTosvg(x, toHTMLformat=False, molSize=molSize)\n    )\n    return df_\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html#himatcal.utils.visualizer.molbokeh.MolBokeh.add_molecule","title":"add_molecule","text":"<pre><code>add_molecule(fig, source: ColumnDataSource, smilesColName: str, hoverAdditionalInfo: Union[None, list] = None, molSize: tuple = (150, 150))\n</code></pre> <p>Add molecules images inside bokeh charts.</p> <p>Args:     fig (bokeh object): Bokeh chart.     source (ColumnDataSource): Bokehs data type used to built chart.     smilesColName (str): Columns name that contain smiles.     hoverAdditionalInfo (None | list): List of colnames that will show in hover.     molSize (tuple): Size of molecules img.</p> Source code in <code>himatcal/utils/visualizer/molbokeh.py</code> <pre><code>def add_molecule(\n    self,\n    fig,\n    source: ColumnDataSource,\n    smilesColName: str,\n    hoverAdditionalInfo: Union[None, list] = None,\n    molSize: tuple = (150, 150),\n):\n    \"\"\"\n    Add molecules images inside bokeh charts.\n\n    Args:\n        fig (bokeh object): Bokeh chart.\n        source (ColumnDataSource): Bokehs data type used to built chart.\n        smilesColName (str): Columns name that contain smiles.\n        hoverAdditionalInfo (None | list): List of colnames that will show in hover.\n        molSize (tuple): Size of molecules img.\n    \"\"\"\n\n    UsersDF = pd.DataFrame(source.data)  # geting users df as dataframe\n    dfwithMolImg = self.__makingMoleculesImg(\n        df=UsersDF, smilesColName=smilesColName, molSize=molSize\n    )\n    fig_ = self.__cleanOriginalHover(fig=fig)\n    source.data = dfwithMolImg.copy()  # update original data with base64 imgs\n    hoverhtml = self.__makingHTML2hover(\n        molimgColName=\"Mol_IMGSVG\",\n        hoverAdditionalInfo=hoverAdditionalInfo,\n        molSize=molSize,\n    )\n    fig_ = self.__applyHover2fig(fig=fig_, hoverhtml=hoverhtml)\n\n    self._dfwithimg = dfwithMolImg.copy()\n    return fig_\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molbokeh.html#himatcal.utils.visualizer.molbokeh.MolBokeh.smiTosvg","title":"smiTosvg  <code>staticmethod</code>","text":"<pre><code>smiTosvg(smi, molSize=(320, 320), kekulize=True, toHTMLformat: bool = False)\n</code></pre> <p>This function generate a molecule img from smiles and return as html tag or pure base64 format.</p> Source code in <code>himatcal/utils/visualizer/molbokeh.py</code> <pre><code>@staticmethod\ndef smiTosvg(smi, molSize=(320, 320), kekulize=True, toHTMLformat: bool = False):\n    \"\"\"\n    This function generate a molecule img from smiles and return as html tag or pure base64 format.\n    \"\"\"\n    mol = Chem.MolFromSmiles(smi)\n    mc = Chem.Mol(mol.ToBinary())\n    if kekulize:\n        try:\n            Chem.Kekulize(mc)\n        except:\n            mc = Chem.Mol(mol.ToBinary())\n    if not mc.GetNumConformers():\n        rdDepictor.Compute2DCoords(mc)\n    drawer = rdMolDraw2D.MolDraw2DSVG(molSize[0], molSize[1])\n    drawer.DrawMolecule(mc)\n    drawer.FinishDrawing()\n    svg = drawer.GetDrawingText().replace(\"svg:\", \"\")\n\n    b64 = base64.b64encode(svg.encode(\"utf-8\")).decode(\"utf-8\")\n    if toHTMLformat:\n        html = r'&lt;img src=\"data:image/svg+xml;base64,%s\"/&gt;' % b64\n    else:\n        html = f\"data:image/svg+xml;base64,{b64}\"\n\n    return html\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molplotly.html","title":"molplotly","text":"<p>https://github.com/wjm41/molplotly/blob/main/molplotly/main.py</p>"},{"location":"reference/himatcal/utils/visualizer/molplotly.html#himatcal.utils.visualizer.molplotly.add_molecules","title":"add_molecules","text":"<pre><code>add_molecules(fig: Figure, df: DataFrame, smiles_col: str | list[str] = 'SMILES', mol_col: Mol | list[Mol] = None, show_img: bool = True, svg_size: int = 200, svg_height: int | None = None, svg_width: int | None = None, alpha: float = 0.75, mol_alpha: float = 0.7, title_col: str = None, show_coords: bool = True, caption_cols: list[str] = None, caption_transform: dict[str, Callable] = {}, color_col: str = None, symbol_col: str = None, facet_col: str = None, wrap: bool = True, wraplen: int = 20, width: int = 150, fontfamily: str = 'Arial', fontsize: int = 12, reaction: bool = False) -&gt; JupyterDash\n</code></pre> <p>A function that takes a plotly figure and a dataframe with molecular SMILES and returns a dash app that dynamically generates an image of molecules in the hover box when hovering the mouse over datapoints. ...</p> <p>Attributes:</p> <ul> <li> <code>fig</code>               (<code>plotly.graph_objects.Figure object</code>)           \u2013            <p>a plotly figure object containing datapoints plotted from df.</p> </li> <li> <code>df</code>               (<code>pandas.DataFrame object</code>)           \u2013            <p>a pandas dataframe that contains the data plotted in fig.</p> </li> <li> <code>smiles_col</code>               (<code>(str | list[str], optional)</code>)           \u2013            <p>name of the column in df containing the smiles plotted in fig (default 'SMILES'). If provided as a list, will add a slider to choose which column is used for rendering the structures.</p> </li> <li> <code>mol_col</code>               (<code>(Mol | list[Mol], optional)</code>)           \u2013            <p>name of the column in df containing RDKit Mol objects of the molecules plotted in fig (default None). If not None, the structures will be drawn using the coordinates of the Mol objects. If provided as a list, will add a slider to choose which column is used for rendering the structures.</p> </li> <li> <code>show_img</code>               (<code>(bool, optional)</code>)           \u2013            <p>whether or not to generate the molecule image in the dash app (default True).</p> </li> <li> <code>svg_size</code>               (<code>(int, optional)</code>)           \u2013            <p>the size in pixels of the height and width of the drawing. Is overridden by svg_height or svg_width (default 200)</p> </li> <li> <code>svg_height</code>               (<code>(int, optional)</code>)           \u2013            <p>the svg_height in pixels of the molecule drawing (default None).</p> </li> <li> <code>svg_width</code>               (<code>(int, optional)</code>)           \u2013            <p>the svg_width in pixels of the molecule drawing (default None).</p> </li> <li> <code>alpha</code>               (<code>(float, optional)</code>)           \u2013            <p>the transparency of the hoverbox, 0 for full transparency 1 for full opaqueness (default 0.7).</p> </li> <li> <code>mol_alpha</code>               (<code>(float, optional)</code>)           \u2013            <p>the transparency of the SVG molecule image, 0 for full transparency 1 for full opaqueness (default 0.7).</p> </li> <li> <code>title_col</code>               (<code>(str, optional)</code>)           \u2013            <p>name of the column in df to be used as the title entry in the hover box (default None).</p> </li> <li> <code>show_coords</code>               (<code>(bool, optional)</code>)           \u2013            <p>whether or not to show the coordinates of the data point in the hover box (default True).</p> </li> <li> <code>caption_cols</code>               (<code>(list[str], optional)</code>)           \u2013            <p>list of column names in df to be included in the hover box (default None).</p> </li> <li> <code>caption_transform</code>               (<code>(dict[str, callable], optional)</code>)           \u2013            <p>Functions applied to specific items in all cells. The dict must follow a key: function structure where the key must correspond to one of the columns in subset or tooltip (default {}).</p> </li> <li> <code>color_col</code>               (<code>(str, optional)</code>)           \u2013            <p>name of the column in df that is used to color the datapoints in df - necessary when there is discrete conditional coloring (default None).</p> </li> <li> <code>symbol_col</code>               (<code>(str, optional)</code>)           \u2013            <p>name of the column in df that is used to determine the symbols of the datapoints in df (default None).</p> </li> <li> <code>facet_col</code>               (<code>(str, optional)</code>)           \u2013            <p>name of the column in df that is used to facet the data to multiple plots (default None).</p> </li> <li> <code>wrap</code>               (<code>(bool, optional)</code>)           \u2013            <p>whether or not to wrap the title text to multiple lines if the length of the text is too long (default True).</p> </li> <li> <code>wraplen</code>               (<code>(int, optional)</code>)           \u2013            <p>the threshold length of the title text before wrapping begins - adjust when changing the width of the hover box (default 20).</p> </li> <li> <code>width</code>               (<code>(int, optional)</code>)           \u2013            <p>the width in pixels of the hover box (default 150).</p> </li> <li> <code>fontfamily</code>               (<code>(str, optional)</code>)           \u2013            <p>the font family used in the hover box (default 'Arial').</p> </li> <li> <code>fontsize</code>               (<code>(int, optional)</code>)           \u2013            <p>the font size used in the hover box - the font of the title line is fontsize+2 (default 12).</p> </li> <li> <code>reaction</code>               (<code>(bool, optional)</code>)           \u2013            <p>toggles rdkit to process the image like a reaction</p> </li> </ul> Source code in <code>himatcal/utils/visualizer/molplotly.py</code> <pre><code>def add_molecules(\n    fig: Figure,\n    df: pd.DataFrame,\n    smiles_col: str | list[str] = \"SMILES\",\n    mol_col: Mol | list[Mol] = None,\n    show_img: bool = True,\n    svg_size: int = 200,\n    svg_height: int | None = None,\n    svg_width: int | None = None,\n    alpha: float = 0.75,\n    mol_alpha: float = 0.7,\n    title_col: str = None,\n    show_coords: bool = True,\n    caption_cols: list[str] = None,\n    caption_transform: dict[str, Callable] = {},\n    color_col: str = None,\n    symbol_col: str = None,\n    facet_col: str = None,\n    wrap: bool = True,\n    wraplen: int = 20,\n    width: int = 150,\n    fontfamily: str = \"Arial\",\n    fontsize: int = 12,\n    reaction: bool = False,\n) -&gt; JupyterDash:\n    \"\"\"\n    A function that takes a plotly figure and a dataframe with molecular SMILES\n    and returns a dash app that dynamically generates an image of molecules in the hover box\n    when hovering the mouse over datapoints.\n    ...\n\n    Attributes\n    ----------\n    fig : plotly.graph_objects.Figure object\n        a plotly figure object containing datapoints plotted from df.\n    df : pandas.DataFrame object\n        a pandas dataframe that contains the data plotted in fig.\n    smiles_col : str | list[str], optional\n        name of the column in df containing the smiles plotted in fig (default 'SMILES').\n        If provided as a list, will add a slider to choose which column is used for rendering the structures.\n    mol_col : Mol | list[Mol], optional\n        name of the column in df containing RDKit Mol objects of the molecules plotted in fig (default None).\n        If not None, the structures will be drawn using the coordinates of the Mol objects.\n        If provided as a list, will add a slider to choose which column is used for rendering the structures.\n    show_img : bool, optional\n        whether or not to generate the molecule image in the dash app (default True).\n    svg_size: int, optional\n        the size in pixels of the height and width of the drawing. Is overridden by svg_height or svg_width (default 200)\n    svg_height : int, optional\n        the svg_height in pixels of the molecule drawing (default None).\n    svg_width : int, optional\n        the svg_width in pixels of the molecule drawing (default None).\n    alpha : float, optional\n        the transparency of the hoverbox, 0 for full transparency 1 for full opaqueness (default 0.7).\n    mol_alpha : float, optional\n        the transparency of the SVG molecule image, 0 for full transparency 1 for full opaqueness (default 0.7).\n    title_col : str, optional\n        name of the column in df to be used as the title entry in the hover box (default None).\n    show_coords : bool, optional\n        whether or not to show the coordinates of the data point in the hover box (default True).\n    caption_cols : list[str], optional\n        list of column names in df to be included in the hover box (default None).\n    caption_transform : dict[str, callable], optional\n        Functions applied to specific items in all cells. The dict must follow a key: function structure where\n        the key must correspond to one of the columns in subset or tooltip (default {}).\n    color_col : str, optional\n        name of the column in df that is used to color the datapoints in df - necessary when there is discrete conditional coloring (default None).\n    symbol_col : str, optional\n        name of the column in df that is used to determine the symbols of the datapoints in df (default None).\n    facet_col : str, optional\n        name of the column in df that is used to facet the data to multiple plots (default None).\n    wrap : bool, optional\n        whether or not to wrap the title text to multiple lines if the length of the text is too long (default True).\n    wraplen : int, optional\n        the threshold length of the title text before wrapping begins - adjust when changing the width of the hover box (default 20).\n    width : int, optional\n        the width in pixels of the hover box (default 150).\n    fontfamily : str, optional\n        the font family used in the hover box (default 'Arial').\n    fontsize : int, optional\n        the font size used in the hover box - the font of the title line is fontsize+2 (default 12).\n    reaction: bool, optional\n        toggles rdkit to process the image like a reaction\n    \"\"\"\n    df_data = df.copy()\n    if color_col is not None:\n        df_data[color_col] = df_data[color_col].astype(str)\n    if symbol_col is not None:\n        df_data[symbol_col] = df_data[symbol_col].astype(str)\n    if facet_col is not None:\n        df_data[facet_col] = df_data[facet_col].astype(str)\n\n    if len(fig.data) != 1:\n        colors = {index: x.marker[\"color\"] for index, x in enumerate(fig.data)}\n\n        cols = []\n\n        if color_col is not None:\n            cols.append(color_col)\n        if symbol_col is not None:\n            cols.append(symbol_col)\n        if facet_col is not None:\n            cols.append(facet_col)\n        cols = list(set(cols))\n        _, curve_dict = find_grouping(fig, df_data, cols)\n    else:\n        colors = {0: \"black\"}\n\n    if not svg_height:\n        svg_height = svg_size\n    if not svg_width:\n        svg_width = svg_size\n\n    app = JupyterDash(__name__)\n    if smiles_col is None and mol_col is None:\n        raise ValueError(\"Either smiles_col or mol_col has to be specified!\")\n\n    if isinstance(smiles_col, str):\n        smiles_col = [smiles_col]\n    if isinstance(mol_col, str):\n        mol_col = [mol_col]\n\n    if mol_col is not None:\n        if len(mol_col) &gt; 1:\n            menu = dcc.Dropdown(\n                options=[{\"label\": x, \"value\": x} for x in mol_col],\n                value=mol_col[0],\n                multi=True,\n                id=\"smiles-menu\",\n                placeholder=\"Select a mol column to display\",\n            )\n        else:\n            menu = dcc.Dropdown(\n                options=[{\"label\": mol_col, \"value\": mol_col}],\n                value=mol_col,\n                multi=False,\n                id=\"smiles-menu\",\n                disabled=True,\n            )\n    elif smiles_col is not None:\n        if len(smiles_col) &gt; 1:\n            menu = dcc.Dropdown(\n                options=[{\"label\": x, \"value\": x} for x in smiles_col],\n                value=smiles_col[0],\n                multi=True,\n                id=\"smiles-menu\",\n                placeholder=\"Select a SMILES column to display\",\n                searchable=True,\n            )\n        else:\n            menu = dcc.Dropdown(\n                options=[{\"label\": smiles_col, \"value\": smiles_col}],\n                value=smiles_col,\n                multi=False,\n                id=\"smiles-menu\",\n                disabled=True,\n            )\n    else:\n        menu = dcc.Dropdown(\n            options=None,\n            value=None,\n            id=\"smiles-menu\",\n            placeholder=\"Select a mol column to display\",\n            disabled=True,\n        )\n\n    fig_copy = go.Figure(fig)\n    fig_copy.update_traces(hoverinfo=\"none\", hovertemplate=None)\n\n    app.layout = html.Div(\n        [\n            menu,\n            dcc.Graph(id=\"graph-basic-2\", figure=fig_copy, clear_on_unhover=True),\n            dcc.Tooltip(\n                id=\"graph-tooltip\", background_color=f\"rgba(255,255,255,{alpha})\"\n            ),\n        ]\n    )\n\n    @app.callback(\n        output=[\n            Output(\"graph-tooltip\", \"show\"),\n            Output(\"graph-tooltip\", \"bbox\"),\n            Output(\"graph-tooltip\", \"children\"),\n        ],\n        inputs=[\n            Input(\"graph-basic-2\", \"hoverData\"),\n            Input(\"smiles-menu\", \"value\"),\n        ],\n    )\n    def display_hover(hoverData, value):\n        if hoverData is None:\n            return False, no_update, no_update\n\n        if value is None:\n            if mol_col is not None:\n                value = mol_col\n            elif smiles_col is not None:\n                value = smiles_col\n        if isinstance(value, str):\n            chosen_smiles = [value]\n        else:\n            chosen_smiles = value\n\n        pt = hoverData[\"points\"][0]\n        bbox = pt[\"bbox\"]\n        num = pt[\"pointNumber\"]\n        curve_num = pt[\"curveNumber\"]\n\n        if len(fig.data) != 1:\n            df_curve = curve_dict[curve_num].reset_index(drop=True)\n            df_row = df_curve.iloc[num]\n        else:\n            df_row = df.iloc[num]\n\n        hoverbox_elements = []\n\n        if show_img:\n            for col in chosen_smiles:\n                smiles = df_row[col]\n                buffered = BytesIO()\n                if isinstance(smiles, str):\n                    # Generate 2D SVG if smiles column is a string\n\n                    d2d = rdMolDraw2D.MolDraw2DSVG(svg_width, svg_height)\n                    opts = d2d.drawOptions()\n                    opts.clearBackground = False\n                    if reaction:\n                        try:\n                            d2d.DrawReaction(ReactionFromSmarts(smiles, useSmiles=True))\n                        except:\n                            d2d.DrawMolecule(Chem.MolFromSmiles(smiles))\n                    else:\n                        d2d.DrawMolecule(Chem.MolFromSmiles(smiles))\n                    d2d.FinishDrawing()\n                    img_str = d2d.GetDrawingText()\n                    buffered.write(str.encode(img_str))\n                    img_str = base64.b64encode(buffered.getvalue())\n                    img_str = f\"data:image/svg+xml;base64,{repr(img_str)[2:-1]}\"\n\n                elif isinstance(smiles, Mol):\n                    # if smiles column is a Mol object, use the 3D coordinates of the mol object\n                    img = Chem.Draw.MolToImage(smiles)\n                    img.save(buffered, format=\"PNG\")\n                    img_str = base64.b64encode(buffered.getvalue())\n                    img_str = f\"data:image/png;base64,{repr(img_str)[2:-1]}\"\n\n                else:\n                    raise TypeError(\n                        \"smiles_col or mol_col not specified with the correct type.\"\n                    )\n                if len(smiles_col) &gt; 1:\n                    hoverbox_elements.append(\n                        html.H2(\n                            f\"{col}\",\n                            style={\n                                \"color\": colors[curve_num],\n                                \"font-family\": fontfamily,\n                                \"fontSize\": fontsize + 2,\n                            },\n                        )\n                    )\n                hoverbox_elements.append(\n                    html.Img(\n                        src=img_str,\n                        style={\n                            \"width\": \"100%\",\n                            \"background-color\": f\"rgba(255,255,255,{mol_alpha})\",\n                        },\n                    )\n                )\n\n        if title_col is not None:\n            title = str(df_row[title_col])\n            if title_col in caption_transform:\n                title = caption_transform[title_col](title)\n\n            if len(title) &gt; wraplen:\n                if wrap:\n                    title = textwrap.fill(title, width=wraplen)\n                else:\n                    title = title[:wraplen] + \"...\"\n\n            # TODO colorbar color titles\n            hoverbox_elements.append(\n                html.H4(\n                    f\"{title}\",\n                    style={\n                        \"color\": colors[curve_num],\n                        \"font-family\": fontfamily,\n                        \"fontSize\": fontsize,\n                    },\n                )\n            )\n        if show_coords:\n            x_label = fig.layout.xaxis.title.text\n            y_label = fig.layout.yaxis.title.text\n            if x_label in caption_transform:\n                style_str = caption_transform[x_label](pt[\"x\"])\n                hoverbox_elements.append(\n                    html.P(\n                        f\"{x_label} : {style_str}\",\n                        style={\n                            \"color\": \"black\",\n                            \"font-family\": fontfamily,\n                            \"fontSize\": fontsize,\n                        },\n                    )\n                )\n            else:\n                hoverbox_elements.append(\n                    html.P(\n                        f\"{x_label}: {pt['x']}\",\n                        style={\n                            \"color\": \"black\",\n                            \"font-family\": fontfamily,\n                            \"fontSize\": fontsize,\n                        },\n                    )\n                )\n            if y_label in caption_transform:\n                style_str = caption_transform[y_label](pt[\"y\"])\n                hoverbox_elements.append(\n                    html.P(\n                        f\"{y_label} : {style_str}\",\n                        style={\n                            \"color\": \"black\",\n                            \"font-family\": fontfamily,\n                            \"fontSize\": fontsize,\n                        },\n                    )\n                )\n            else:\n                hoverbox_elements.append(\n                    html.P(\n                        f\"{y_label} : {pt['y']}\",\n                        style={\n                            \"color\": \"black\",\n                            \"font-family\": fontfamily,\n                            \"fontSize\": fontsize,\n                        },\n                    )\n                )\n        if caption_cols is not None:\n            for caption in caption_cols:\n                caption_val = df_row[caption]\n                if caption in caption_transform:\n                    style_str = caption_transform[caption](caption_val)\n                    hoverbox_elements.append(\n                        html.P(\n                            f\"{caption} : {style_str}\",\n                            style={\n                                \"color\": \"black\",\n                                \"font-family\": fontfamily,\n                                \"fontSize\": fontsize,\n                            },\n                        )\n                    )\n                else:\n                    hoverbox_elements.append(\n                        html.P(\n                            f\"{caption} : {caption_val}\",\n                            style={\n                                \"color\": \"black\",\n                                \"font-family\": fontfamily,\n                                \"fontSize\": fontsize,\n                            },\n                        )\n                    )\n        children = [\n            html.Div(\n                hoverbox_elements,\n                style={\n                    \"width\": f\"{width}px\",\n                    \"white-space\": \"normal\",\n                },\n            )\n        ]\n\n        return True, bbox, children\n\n    return app\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molplotly.html#himatcal.utils.visualizer.molplotly.find_correct_column_order","title":"find_correct_column_order","text":"<pre><code>find_correct_column_order(cols, col_names)\n</code></pre> Source code in <code>himatcal/utils/visualizer/molplotly.py</code> <pre><code>def find_correct_column_order(cols, col_names):\n    correctly_ordered_cols = []\n    for col in col_names:\n        if col in cols:\n            correctly_ordered_cols.append(col)\n    return correctly_ordered_cols\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molplotly.html#himatcal.utils.visualizer.molplotly.find_grouping","title":"find_grouping","text":"<pre><code>find_grouping(fig: Figure, df_data: DataFrame, cols: list[str]) -&gt; tuple[DataFrameGroupBy, dict]\n</code></pre> Source code in <code>himatcal/utils/visualizer/molplotly.py</code> <pre><code>def find_grouping(\n    fig: Figure, df_data: pd.DataFrame, cols: list[str]\n) -&gt; tuple[DataFrameGroupBy, dict]:\n    if fig.data[0].hovertemplate is not None:\n        col_names = re.findall(r\"(.*?)=.*?&lt;.*?&gt;\", fig.data[0].hovertemplate)\n        col_names = [re.sub(r\"(.*)&gt;\", \"\", col_name) for col_name in col_names]\n        if set(cols).issubset(set(col_names)) is False:\n            raise ValueError(\n                f\"symbol_col/color_col/facet_col is misspecified because the specified dataframe grouping names {cols} don't match the names in the plotly figure {col_names}.\",\n            )\n\n        cols = find_correct_column_order(cols, col_names)\n        df_grouped = df_data.groupby(cols)\n\n        str_groups = {}\n        for name, group in df_grouped:\n            if isinstance(name, tuple):\n                str_groups[\", \".join(str(x) for x in name)] = group\n            else:\n                str_groups[name] = group\n\n        curve_dict = {}\n        for index, data in enumerate(fig.data):\n            curve_name = re.findall(r\".*?=(.*?)&lt;.*?&gt;\", data.hovertemplate)\n            curve_name = \", \".join(str(x) for x in curve_name)\n            if \"%{x}\" in curve_name:\n                unique_x_values = np.unique(data.x)\n                if len(unique_x_values) == 1 and len(data.x) != 1:\n                    curve_name = curve_name.replace(\"%{x}\", str(unique_x_values[0]))\n                else:\n                    curve_name = curve_name.replace(\", %{x}\", \"\")\n            if \"%{y}\" in curve_name:\n                unique_y_values = np.unique(data.y)\n                if len(unique_y_values) == 1 and len(data.y) != 1:\n                    curve_name = curve_name.replace(\"%{y}\", str(unique_y_values[0]))\n                else:\n                    curve_name = curve_name.replace(\", %{y}\", \"\")\n            if \"%{marker.size}\" in curve_name:\n                unique_size_values = np.unique(data.marker.size)\n                if len(unique_size_values) == 1 and len(data.marker.size) != 1:\n                    curve_name = curve_name.replace(\n                        \"%{marker.size}\", str(unique_size_values[0])\n                    )\n                else:\n                    curve_name = curve_name.replace(\", %{marker.size}\", \"\")\n            curve_dict[index] = str_groups[curve_name]\n\n        return df_grouped, curve_dict\n\n    else:\n        grouping_found = False\n        for combo in itertools.permutations(cols):\n            df_grouped_tmp = df_data.groupby(list(combo))\n            if test_groups(fig, df_grouped_tmp):\n                df_grouped = df_grouped_tmp\n                str_groups = {}\n                for name, group in df_grouped:\n                    if isinstance(name, tuple):\n                        str_groups[\", \".join(str(x) for x in name)] = group\n                    else:\n                        str_groups[name] = group\n                curve_dict = {\n                    index: str_groups[x[\"name\"]] for index, x in enumerate(fig.data)\n                }\n                grouping_found = True\n\n                return df_grouped, curve_dict\n\n            else:\n                continue\n\n        if not grouping_found:\n            raise ValueError(\n                \"symbol_col/color_col/facet_col is misspecified because the dataframe grouping names don't match the names in the plotly figure.\"\n            )\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molplotly.html#himatcal.utils.visualizer.molplotly.str2bool","title":"str2bool","text":"<pre><code>str2bool(v: str) -&gt; bool\n</code></pre> Source code in <code>himatcal/utils/visualizer/molplotly.py</code> <pre><code>def str2bool(v: str) -&gt; bool:\n    return v.lower() in (\"yes\", \"true\", \"t\", \"1\")\n</code></pre>"},{"location":"reference/himatcal/utils/visualizer/molplotly.html#himatcal.utils.visualizer.molplotly.test_groups","title":"test_groups","text":"<pre><code>test_groups(fig: Figure, df_grouped: DataFrameGroupBy)\n</code></pre> <p>Test if plotly figure curve names match up with pandas dataframe groups</p> <p>Args:     fig (plotly figure): description     groups (pandas groupby object): description</p> <p>Returns:     type: Bool describing whether or not groups is the correct dataframe grouping descbrining the data in fig</p> Source code in <code>himatcal/utils/visualizer/molplotly.py</code> <pre><code>def test_groups(fig: Figure, df_grouped: DataFrameGroupBy):\n    \"\"\"Test if plotly figure curve names match up with pandas dataframe groups\n\n    Args:\n        fig (plotly figure): _description_\n        groups (pandas groupby object): _description_\n\n    Returns:\n        _type_: Bool describing whether or not groups is the correct dataframe grouping descbrining the data in fig\n    \"\"\"\n    str_groups = {}\n    for name, group in df_grouped:\n        if isinstance(name, tuple):\n            str_groups[\", \".join(str(x) for x in name)] = group\n        else:\n            str_groups[name] = group\n\n    for data in fig.data:\n        if data.name in str_groups:\n            if len(data.y) == len(str_groups[data.name]):\n                continue\n        else:\n            return False\n    return True\n</code></pre>"}]}